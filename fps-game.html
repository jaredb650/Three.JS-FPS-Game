<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete 3D FPS Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            overflow: hidden;
        }
        
        canvas {
            display: block;
        }
        
        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: #fff;
            border-radius: 50%;
            opacity: 0.8;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.5);
        }
        
        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: #fff;
            opacity: 0.6;
        }
        
        .crosshair::before {
            width: 20px;
            height: 1px;
            top: 50%;
            left: -8px;
            transform: translateY(-50%);
        }
        
        .crosshair::after {
            width: 1px;
            height: 20px;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 99;
            font-family: 'Courier New', monospace;
        }
        
        .health-bar-container {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 200px;
            height: 20px;
            background: rgba(255, 0, 0, 0.3);
            border: 2px solid #fff;
            border-radius: 10px;
        }
        
        .health-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff0000 0%, #ffff00 50%, #00ff00 100%);
            border-radius: 8px;
            transition: width 0.3s ease;
        }
        
        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .ammo-display {
            position: fixed;
            bottom: 30px;
            right: 30px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            text-align: right;
        }
        
        .ammo-current {
            font-size: 36px;
            color: #00ff00;
        }
        
        .ammo-reserve {
            font-size: 18px;
            color: #ffff00;
        }
        
        .game-stats {
            position: fixed;
            top: 30px;
            left: 30px;
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .minimap {
            position: fixed;
            top: 30px;
            right: 30px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #fff;
            border-radius: 10px;
        }
        
        .damage-flash {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle, transparent 30%, rgba(255,0,0,0.3) 100%);
            opacity: 0;
            pointer-events: none;
            z-index: 98;
            transition: opacity 0.1s ease;
        }
        
        .kill-feed {
            position: fixed;
            top: 100px;
            right: 30px;
            width: 300px;
            color: white;
            font-size: 14px;
        }
        
        .kill-message {
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            margin: 2px 0;
            border-radius: 5px;
            animation: fadeInOut 4s ease;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateX(100px); }
            10% { opacity: 1; transform: translateX(0); }
            90% { opacity: 1; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(-100px); }
        }
        
        .fps-counter {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ff00;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            display: none;
        }
        
        .menu-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        .menu-title {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 30px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            color: #00ff00;
        }
        
        .menu-subtitle {
            font-size: 24px;
            margin-bottom: 40px;
            color: #ffff00;
        }
        
        .menu-instructions {
            font-size: 16px;
            text-align: center;
            line-height: 1.6;
            max-width: 600px;
        }
        
        .menu-controls {
            margin-top: 30px;
            font-size: 14px;
            text-align: center;
            color: #aaa;
        }
        
        .game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 0, 0, 0.9);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        .pause-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        .weapon-display {
            position: fixed;
            bottom: 0;
            right: 0;
            width: 300px;
            height: 200px;
            pointer-events: none;
            z-index: 50;
        }
        
        .reload-indicator {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffff00;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            display: none;
        }
        
        .debug-info {
            position: fixed;
            top: 200px;
            left: 30px;
            color: #00ff00;
            font-size: 12px;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
    </style>
</head>
<body>
    <!-- Crosshair -->
    <div class="crosshair"></div>
    
    <!-- HUD Elements -->
    <div class="hud">
        <!-- Health Bar -->
        <div class="health-bar-container">
            <div class="health-bar" id="healthBar"></div>
            <div class="health-text" id="healthText">100</div>
        </div>
        
        <!-- Ammo Display -->
        <div class="ammo-display">
            <div style="font-size: 14px; color: #aaa; margin-bottom: 5px;" id="weaponName">SMG</div>
            <div class="ammo-current" id="currentAmmo">30</div>
            <div class="ammo-reserve" id="reserveAmmo">90</div>
        </div>
        
        <!-- Game Stats -->
        <div class="game-stats">
            <div>Score: <span id="scoreDisplay">0</span></div>
            <div>Wave: <span id="waveDisplay">1</span></div>
            <div>Enemies: <span id="enemyCount">0</span></div>
        </div>
        
        <!-- Minimap -->
        <canvas class="minimap" id="minimap" width="150" height="150"></canvas>
        
        <!-- Kill Feed -->
        <div class="kill-feed" id="killFeed"></div>
        
        <!-- Damage Flash -->
        <div class="damage-flash" id="damageFlash"></div>
        
        <!-- FPS Counter -->
        <div class="fps-counter" id="fpsCounter">FPS: 60</div>
        
        <!-- Reload Indicator -->
        <div class="reload-indicator" id="reloadIndicator">RELOADING...</div>
        
        <!-- Debug Info -->
        <div class="debug-info" id="debugInfo"></div>
    </div>
    
    <!-- Menu Screen -->
    <div class="menu-screen" id="menuScreen">
        <div class="menu-title">FPS SURVIVAL</div>
        <div class="menu-subtitle">Wave-Based Combat Arena</div>
        <div class="menu-instructions">
            <p>Survive endless waves of enemies in this fast-paced FPS arena!</p>
            <p>Defeat enemies to earn points and progress through increasingly difficult waves.</p>
            <p>Collect health and ammo pickups to stay alive.</p>
        </div>
        <div class="menu-controls">
            <p><strong>CONTROLS:</strong></p>
            <p>WASD - Move | Mouse - Look | Left Click - Shoot | R - Reload</p>
            <p>Space - Jump | Shift - Sprint | ESC - Pause | F - FPS Counter | G - Debug</p>
            <p><br><strong>Click anywhere to start playing!</strong></p>
        </div>
    </div>
    
    <!-- Game Over Screen -->
    <div class="game-over-screen" id="gameOverScreen">
        <div class="menu-title">GAME OVER</div>
        <div class="menu-subtitle">You have been eliminated</div>
        <div id="finalStats"></div>
        <div class="menu-controls">
            <p>Press SPACE to restart</p>
            <p>Press ESC to return to menu</p>
        </div>
    </div>
    
    <!-- Pause Screen -->
    <div class="pause-screen" id="pauseScreen">
        <div class="menu-title">PAUSED</div>
        <div class="menu-controls">
            <p>Press ESC to resume</p>
            <p>Press R to restart</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Game States
        const GameState = {
            MENU: 'menu',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'game_over'
        };

        // Audio Manager using HTML5 Audio
        class AudioManager {
            constructor() {
                this.sounds = {};
                this.volume = 0.5;
                this.globalPlaybackRate = 1.0;
                this.init();
            }

            init() {
                // Preload all sound files
                this.sounds = {
                    shoot: this.createSound('sounds/smg_fire.mp3', 0.3),
                    shotgun: this.createSound('sounds/shotgun_fire.mp3', 0.32), // Reduced by 20%
                    rocket: this.createSound('sounds/rocket_fire.mp3', 0.4),
                    rocketExplosion: this.createSound('sounds/rocket_explosion.mp3', 0.5),
                    swordSwing: this.createSound('sounds/sword_swing.mp3', 0.5),
                    swordHit1: this.createSound('sounds/sword_hit1.mp3', 0.6),
                    swordHit2: this.createSound('sounds/sword_hit2.mp3', 0.6),
                    perkAdrenaline: this.createSound('sounds/perk_adrenaline.mp3', 0.7),
                    reload: this.createSound('sounds/smg_reload.mp3', 0.4),
                    enemyHit: this.createSound('sounds/enemy_hit.mp3', 0.4),
                    enemyDie: this.createSound('sounds/enemy_die.mp3', 0.5),
                    enemyGrunt: this.createSound('sounds/enemy_grunt.mp3', 0.4),
                    enemyDeathGrunt: this.createSound('sounds/enemy_deathgrunt.mp3', 0.5),
                    enemyHeadshot: this.createSound('sounds/enemy_headshot.mp3', 0.75), // Increased by 25%
                    enemyHeadshot2: this.createSound('sounds/enemy_headshot2.mp3', 0.5625), // Reduced by 25% from 0.75
                    enemyHeadshot3: this.createSound('sounds/enemy_headshot3.mp3', 0.75),
                    enemyExplode: this.createSound('sounds/enemy_explode.mp3', 0.5),
                    enemyShoot: this.createSound('sounds/enemy_shoot.mp3', 0.15), // 50% quieter
                    bulletWhizz: this.createSound('sounds/bullet_whizz.mp3', 0.4),
                    perkBloodthirsty: this.createSound('sounds/perk_bloodthirsty.mp3', 0.7),
                    bloodthirstyShot: this.createSound('sounds/bloodthirsty_shot.mp3', 1.0), // Doubled from 0.5
                    perkHellfire: this.createSound('sounds/perk_hellfire.mp3', 0.8),
                    hellfireShot: this.createSound('sounds/hellfire_shot.mp3', 0.6),
                    hellfireBulletExplode: this.createSound('sounds/hellfirebullet_explode.mp3', 0.5),
                    hellfireRocketExplode: this.createSound('sounds/hellfirerocket_explode.mp3', 1.4), // Doubled volume
                    perkBerserk1: this.createSound('sounds/perk_berserk1.mp3', 0.8),
                    perkBerserk2: this.createSound('sounds/perk_berserk2.mp3', 1.2), // Increased by 50%
                    perkBerserk3: this.createSound('sounds/perk_berserk3.mp3', 0.8),
                    berserkShot: this.createSound('sounds/berserk_shot.mp3', 0.7),
                    perkSlowmo: this.createSound('sounds/perk_slowmo.mp3', 0.8),
                    playerHit: this.createSound('sounds/enemy_hit.mp3', 0.6), // Reuse enemy_hit for player
                    bulletHit1: this.createSound('sounds/bullet_hit1.mp3', 0.3),
                    bulletHit2: this.createSound('sounds/bullet_hit2.mp3', 0.3),
                    bulletHit3: this.createSound('sounds/bulltet_hit3.mp3', 0.3), // Note: typo in filename
                    bulletHit4: this.createSound('sounds/bullet_hit4.mp3', 0.3),
                    slide_ground: this.createSound('sounds/slide_ground.mp3', 0.5), // Slide sound effect
                    player_footstep1: this.createSound('sounds/player_footstep1.mp3', 0.2), // Dynamic footstep sounds
                    player_footstep2: this.createSound('sounds/player_footstep2.mp3', 0.2),
                    player_footstep3: this.createSound('sounds/player_footstep3.mp3', 0.2),
                    player_jump: this.createSound('sounds/player_jump.mp3', 0.3), // Jump sound
                    player_land: this.createSound('sounds/player_land.mp3', 0.3), // Landing sound
                    pickup: this.createSound(null, 0.3), // Keep procedural for pickup
                    footstep: this.createSound(null, 0.1) // Keep procedural for footsteps (fallback)
                };
                
                // Initialize Web Audio for procedural sounds
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                } catch (error) {
                    console.warn('Web Audio API not supported:', error);
                }
            }

            createSound(filepath, volume) {
                if (!filepath) return null;
                
                const audio = new Audio(filepath);
                audio.volume = volume * this.volume;
                audio.preload = 'auto';
                
                // Create multiple instances for overlapping sounds
                const instances = [audio];
                for (let i = 0; i < 3; i++) {
                    const clone = audio.cloneNode();
                    clone.volume = volume * this.volume;
                    instances.push(clone);
                }
                
                const self = this;
                return {
                    instances: instances,
                    currentIndex: 0,
                    filepath: filepath,
                    play: function(startTime = 0) {
                        // Use round-robin to allow overlapping sounds
                        const instance = this.instances[this.currentIndex];
                        
                        // Skip silence at beginning of enemy_headshot3
                        if (this.filepath && this.filepath.includes('enemy_headshot3')) {
                            instance.currentTime = 1.0; // Skip first 1 second of silence
                        } else {
                            instance.currentTime = startTime;
                        }
                        
                        // Don't apply playback rate to perk_slowmo sound
                        if (this.filepath && this.filepath.includes('perk_slowmo')) {
                            instance.playbackRate = 1.0;
                        } else {
                            instance.playbackRate = self.globalPlaybackRate; // Apply global playback rate
                        }
                        instance.play().catch(e => console.log('Audio play failed:', e));
                        this.currentIndex = (this.currentIndex + 1) % this.instances.length;
                    }
                };
            }

            playPickup() {
                // Keep procedural pickup sound
                if (!this.context) return;
                
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.context.destination);
                
                oscillator.frequency.setValueAtTime(400, this.context.currentTime);
                oscillator.frequency.setValueAtTime(800, this.context.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(1200, this.context.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(this.volume * 0.3, this.context.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + 0.3);
                
                oscillator.start(this.context.currentTime);
                oscillator.stop(this.context.currentTime + 0.3);
            }

            playFootstep() {
                // Keep procedural footstep sound
                if (!this.context) return;
                
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                const filter = this.context.createBiquadFilter();
                
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.context.destination);
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(80, this.context.currentTime);
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, this.context.currentTime);
                
                gainNode.gain.setValueAtTime(this.volume * 0.1, this.context.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + 0.1);
                
                oscillator.start(this.context.currentTime);
                oscillator.stop(this.context.currentTime + 0.1);
            }

            play(soundName, position = null) {
                if (soundName === 'pickup') {
                    this.playPickup();
                } else if (soundName === 'footstep') {
                    this.playFootstep();
                } else if (soundName === 'bulletHit') {
                    // Play random bullet hit sound
                    this.playRandomBulletHit();
                } else if (this.sounds[soundName]) {
                    this.sounds[soundName].play();
                }
            }
            
            playRandomBulletHit() {
                const hitNumber = Math.floor(Math.random() * 4) + 1; // Random 1-4
                const soundName = `bulletHit${hitNumber}`;
                if (this.sounds[soundName]) {
                    this.sounds[soundName].play();
                }
            }
            
            setGlobalPlaybackRate(rate) {
                this.globalPlaybackRate = rate;
                // Update all currently playing sounds
                for (const soundName in this.sounds) {
                    if (this.sounds[soundName] && this.sounds[soundName].instances) {
                        this.sounds[soundName].instances.forEach(instance => {
                            instance.playbackRate = rate;
                        });
                    }
                }
            }
        }

        // Object Pool for performance optimization
        class ObjectPool {
            constructor(createFn, resetFn, initialSize = 50) {
                this.createFn = createFn;
                this.resetFn = resetFn;
                this.pool = [];
                this.active = [];
                
                // Pre-populate pool
                for (let i = 0; i < initialSize; i++) {
                    this.pool.push(this.createFn());
                }
            }

            get() {
                let obj = this.pool.pop();
                if (!obj) {
                    obj = this.createFn();
                }
                this.active.push(obj);
                return obj;
            }

            release(obj) {
                const index = this.active.indexOf(obj);
                if (index > -1) {
                    this.active.splice(index, 1);
                    this.resetFn(obj);
                    this.pool.push(obj);
                }
            }

            releaseAll() {
                while (this.active.length > 0) {
                    this.release(this.active[0]);
                }
            }
        }

        // Bullet class
        class Bullet {
            constructor(scene) {
                this.scene = scene;
                this.mesh = null;
                this.velocity = new THREE.Vector3();
                this.damage = 25;
                this.speed = 100;
                this.lifetime = 5; // seconds
                this.age = 0;
                this.active = false;
                this.hasWhizzed = false; // Track if whizz sound has played
                this.isEnemyBullet = false; // Track if this is an enemy bullet
                this.isRocket = false; // Track if this is a rocket
                this.blastRadius = 0; // Explosion radius for rockets
                this.isHellfireBullet = false; // Track if this is a Hellfire bullet
                this.isHellfireRocket = false; // Track if this is a Hellfire rocket
                
                this.createMesh();
            }

            createMesh() {
                const geometry = new THREE.SphereGeometry(0.05, 4, 4);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    transparent: false
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.visible = false;
                
                // Create separate rocket mesh
                const rocketGeometry = new THREE.CylinderGeometry(0.08, 0.06, 0.3, 6);
                const rocketMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff6600,
                    transparent: false
                });
                this.rocketMesh = new THREE.Mesh(rocketGeometry, rocketMaterial);
                this.rocketMesh.visible = false;
                this.scene.add(this.rocketMesh);
            }

            fire(position, direction) {
                this.age = 0;
                this.active = true;
                
                if (this.isRocket && this.rocketMesh) {
                    // Use rocket mesh for rockets
                    this.rocketMesh.position.copy(position);
                    this.rocketMesh.visible = true;
                    this.mesh.visible = false;
                    
                    // Orient rocket in direction of travel
                    this.rocketMesh.lookAt(position.clone().add(direction));
                    this.rocketMesh.rotateX(Math.PI / 2);
                    
                    // Ensure rocket mesh is in scene
                    if (!this.scene.getObjectById(this.rocketMesh.id)) {
                        this.scene.add(this.rocketMesh);
                    }
                } else {
                    // Use normal bullet mesh
                    this.mesh.position.copy(position);
                    this.mesh.visible = true;
                    if (this.rocketMesh) this.rocketMesh.visible = false;
                }
                
                this.velocity.copy(direction).multiplyScalar(this.speed);
                
                // Ensure mesh is in scene (for non-rocket bullets)
                if (!this.isRocket && !this.scene.getObjectById(this.mesh.id)) {
                    this.scene.add(this.mesh);
                }
            }

            update(deltaTime) {
                if (!this.active) return false;

                this.age += deltaTime;
                if (this.age >= this.lifetime) {
                    this.deactivate();
                    return false;
                }

                // Update appropriate mesh position
                if (this.isRocket && this.rocketMesh) {
                    this.rocketMesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                    
                    // Add smoke trail for rocket
                    if (Math.random() < 0.3) {
                        const smokePos = this.rocketMesh.position.clone();
                        smokePos.add(new THREE.Vector3(
                            (Math.random() - 0.5) * 0.2,
                            (Math.random() - 0.5) * 0.2,
                            (Math.random() - 0.5) * 0.2
                        ));
                    }
                } else {
                    this.mesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                }
                return true;
            }

            deactivate() {
                this.active = false;
                this.mesh.visible = false;
                if (this.rocketMesh) {
                    this.rocketMesh.visible = false;
                }
            }

            reset() {
                this.deactivate();
                this.age = 0;
                this.hasWhizzed = false;
                this.isEnemyBullet = false;
                this.isRocket = false;
                this.blastRadius = 0;
                this.speed = 100; // Reset to default speed
                this.isHellfireBullet = false; // Reset Hellfire bullet flag
                this.isHellfireRocket = false; // Reset Hellfire rocket flag
            }
        }

        // Particle System
        class ParticleSystem {
            constructor(scene) {
                this.scene = scene;
                this.particles = [];
            }

            createExplosion(position, color = 0xff4444, count = 20, isHellfire = false) {
                for (let i = 0; i < count; i++) {
                    // Make hellfire particles bigger and faster
                    const sizeMultiplier = isHellfire ? 2.5 : 1;
                    const speedMultiplier = isHellfire ? 1.8 : 1;
                    const lifeMultiplier = isHellfire ? 1.5 : 1;
                    
                    // Vary particle sizes more for hellfire
                    const baseSize = isHellfire ? 
                        (0.1 + Math.random() * 0.3) : // 0.1-0.4 for hellfire
                        0.1; // consistent 0.1 for normal
                    
                    const particle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(baseSize * sizeMultiplier, 4, 4),
                            new THREE.MeshBasicMaterial({ 
                                color: color,
                                emissive: isHellfire ? color : 0x000000,
                                emissiveIntensity: isHellfire ? 0.5 : 0,
                                transparent: isHellfire,
                                opacity: isHellfire ? 0.9 : 1
                            })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 10 * speedMultiplier,
                            Math.random() * 10 * speedMultiplier,
                            (Math.random() - 0.5) * 10 * speedMultiplier
                        ),
                        life: 1.0 * lifeMultiplier,
                        maxLife: 1.0 * lifeMultiplier,
                        isHellfire: isHellfire
                    };
                    
                    particle.mesh.position.copy(position);
                    this.scene.add(particle.mesh);
                    this.particles.push(particle);
                }
            }
            
            createShockwave(position, isHellfire = false) {
                // Create expanding sphere shockwave - white blast wave
                const shockwaveGeometry = new THREE.SphereGeometry(0.5, 16, 8);
                const shockwaveMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff, // White for realistic pressure wave
                    transparent: true,
                    opacity: 0.25, // Start at 25% opacity
                    side: THREE.DoubleSide,
                    wireframe: true
                });
                
                const shockwave = {
                    mesh: new THREE.Mesh(shockwaveGeometry, shockwaveMaterial),
                    expandSpeed: isHellfire ? 150 : 120, // EXTREMELY fast - near instant
                    maxSize: isHellfire ? 20 : 15, // Bigger for hellfire
                    currentSize: 0.5,
                    life: 0.1, // Very quick expansion (100ms)
                    maxLife: 0.1,
                    isShockwave: true
                };
                
                shockwave.mesh.position.copy(position);
                this.scene.add(shockwave.mesh);
                this.particles.push(shockwave);
            }

            createMuzzleFlash(position, direction) {
                const flash = new THREE.Mesh(
                    new THREE.ConeGeometry(0.2, 1, 4),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xffaa00,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                
                flash.position.copy(position);
                flash.lookAt(position.clone().add(direction));
                this.scene.add(flash);
                
                setTimeout(() => {
                    this.scene.remove(flash);
                    flash.geometry.dispose();
                    flash.material.dispose();
                }, 100);
            }
            
            createBloodJet(position, direction) {
                // Create a directional blood spray effect
                const jetParticles = 30;
                const baseSpeed = 15;
                
                for (let i = 0; i < jetParticles; i++) {
                    const particle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(0.08 + Math.random() * 0.12, 4, 4),
                            new THREE.MeshBasicMaterial({ color: 0xcc0000 })
                        ),
                        velocity: new THREE.Vector3(
                            direction.x * baseSpeed + (Math.random() - 0.5) * 3,
                            direction.y * baseSpeed + Math.random() * 5,
                            direction.z * baseSpeed + (Math.random() - 0.5) * 3
                        ),
                        life: 0.8 + Math.random() * 0.4,
                        maxLife: 1.2,
                        gravity: -15 // Blood drops fall
                    };
                    
                    particle.mesh.position.copy(position);
                    this.scene.add(particle.mesh);
                    this.particles.push(particle);
                }
                
                // Add some mist particles for spray effect
                for (let i = 0; i < 10; i++) {
                    const mist = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(0.15, 3, 3),
                            new THREE.MeshBasicMaterial({ 
                                color: 0xff4444,
                                transparent: true,
                                opacity: 0.6
                            })
                        ),
                        velocity: new THREE.Vector3(
                            direction.x * (baseSpeed * 0.5) + (Math.random() - 0.5) * 5,
                            direction.y * (baseSpeed * 0.5) + Math.random() * 3,
                            direction.z * (baseSpeed * 0.5) + (Math.random() - 0.5) * 5
                        ),
                        life: 0.4,
                        maxLife: 0.4,
                        isMist: true
                    };
                    
                    mist.mesh.position.copy(safePosition);
                    this.scene.add(mist.mesh);
                    this.particles.push(mist);
                }
            }
            
            createMassiveBloodSpurt(position, direction) {
                // Massive blood spurt for dismemberment
                if (!position || position.x === undefined) return;
                
                const spurtParticles = 40; // Many particles for dramatic effect
                const baseSpeed = 20; // Fast initial speed
                
                for (let i = 0; i < spurtParticles; i++) {
                    // Vary particle sizes - mix of droplets and chunks
                    const particleSize = i < 10 ? 
                        0.15 + Math.random() * 0.15 : // First 10 are larger chunks
                        0.08 + Math.random() * 0.08;   // Rest are smaller droplets
                    
                    const particle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(particleSize, 4, 3),
                            new THREE.MeshBasicMaterial({ 
                                color: i < 5 ? 0xff0000 : 0xcc0000, // Some bright red for intensity
                                transparent: true,
                                opacity: 0.9,
                                emissive: 0x660000,
                                emissiveIntensity: 0.3
                            })
                        ),
                        velocity: new THREE.Vector3(
                            direction.x * baseSpeed + (Math.random() - 0.5) * 8,
                            direction.y * baseSpeed + Math.random() * 10,
                            direction.z * baseSpeed + (Math.random() - 0.5) * 8
                        ),
                        life: 1.0 + Math.random() * 1.0,
                        maxLife: 2.0,
                        gravity: -20, // Heavy gravity for arc effect
                        isBlood: true
                    };
                    
                    // Add some particles with extra velocity for spray effect
                    if (i < 5) {
                        particle.velocity.multiplyScalar(1.5);
                    }
                    
                    particle.mesh.position.copy(position);
                    // Slight position variation for volume
                    particle.mesh.position.add(new THREE.Vector3(
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3
                    ));
                    
                    this.scene.add(particle.mesh);
                    this.particles.push(particle);
                }
            }
            
            createBloodDroplet(position, initialVelocity = null) {
                // Enhanced blood droplet for dramatic trails
                if (!position || position.x === undefined) return;
                
                // Vary droplet size for more interesting trails
                const size = 0.08 + Math.random() * 0.12; // Larger droplets
                
                const droplet = {
                    mesh: new THREE.Mesh(
                        new THREE.SphereGeometry(size, 4, 3), // More segments for smoother appearance
                        new THREE.MeshBasicMaterial({
                            color: Math.random() < 0.3 ? 0xff0000 : 0xcc0000, // Some brighter red
                            transparent: true,
                            opacity: 0.95,
                            emissive: 0x440000,
                            emissiveIntensity: 0.2
                        })
                    ),
                    velocity: initialVelocity || new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 1,
                        (Math.random() - 0.5) * 2
                    ),
                    life: 1.5 + Math.random() * 0.5,  // Longer lasting (1.5-2 seconds)
                    maxLife: 2.0,
                    gravity: -12,  // Slightly less gravity for more float time
                    isBlood: true
                };
                
                droplet.mesh.position.copy(position);
                this.scene.add(droplet.mesh);
                this.particles.push(droplet);
            }
            
            createLingeringBloodMist(position) {
                // Create a large, quickly dissipating blood cloud
                if (!position || position.x === undefined) return;
                
                const mistCount = 8;  // More particles for better cloud effect
                for (let i = 0; i < mistCount; i++) {
                    // Start closer together
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5
                    );
                    
                    // Use sprite for billboard effect (always faces camera)
                    const spriteMaterial = new THREE.SpriteMaterial({
                        color: Math.random() < 0.7 ? 0x990000 : 0x660000,
                        transparent: true,
                        opacity: 0.3,  // Much more transparent - never solid
                        fog: true
                    });
                    
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.scale.set(
                        0.5 + Math.random() * 0.3,  // Start smaller
                        0.5 + Math.random() * 0.3,
                        1
                    );
                    
                    // Calculate outward spread direction from center
                    const spreadDirection = new THREE.Vector3(
                        (Math.random() - 0.5),
                        (Math.random() - 0.5) * 0.5 + 0.2,  // Slight upward bias
                        (Math.random() - 0.5)
                    ).normalize();
                    
                    const mist = {
                        mesh: sprite,
                        velocity: spreadDirection.multiplyScalar(1.5 + Math.random() * 1.5),  // Slower spread (1.5-3 units/sec)
                        life: 1.5 + Math.random() * 1.5,  // Dissipate within 1.5-3 seconds
                        maxLife: 3.0,
                        isMist: true,
                        expandRate: 2.0,  // Less expansion - particles won't get huge
                        gravity: 0  // No gravity for mist - it floats
                    };
                    
                    mist.mesh.position.copy(position);
                    mist.mesh.position.add(offset);
                    this.scene.add(mist.mesh);
                    this.particles.push(mist);
                }
            }
            
            createHeadRemoval(position, forceDirection) {
                // Head splitting into large chunks - shotgun decapitation
                if (!position || position.x === undefined) {
                    console.warn('Invalid position for head removal');
                    return;
                }
                
                const safePos = position.clone();
                
                // Create 3 large head chunks
                for (let i = 0; i < 3; i++) {
                    // Large chunks to represent head pieces (25% smaller)
                    const gibSize = 0.26 + Math.random() * 0.11; // 0.26-0.37 units (was 0.35-0.5)
                    
                    // Use irregular geometry for chunks
                    let gibGeometry;
                    if (i === 0) {
                        // Front piece - slightly flattened sphere
                        gibGeometry = new THREE.SphereGeometry(gibSize, 4, 3);
                        gibGeometry.scale(1, 0.8, 0.7);
                    } else if (i === 1) {
                        // Side piece - elongated
                        gibGeometry = new THREE.BoxGeometry(gibSize * 0.8, gibSize * 1.2, gibSize * 0.6);
                    } else {
                        // Back piece - rounded
                        gibGeometry = new THREE.SphereGeometry(gibSize * 0.9, 3, 3);
                    }
                    
                    const gib = {
                        mesh: new THREE.Mesh(
                            gibGeometry,
                            new THREE.MeshBasicMaterial({ 
                                color: i === 0 ? 0xffaa88 : // Skin/skull piece
                                       i === 1 ? 0x992222 : // Dark red/brain
                                       0xcc0000,            // Blood/tissue
                                transparent: true,
                                opacity: 0.95
                            })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 6,  // Much slower (was 15)
                            Math.random() * 4 + 2,       // Less upward (was 10+5)
                            (Math.random() - 0.5) * 6    // Slower spread
                        ),
                        life: 3.0,  // Last longer since they're bigger
                        maxLife: 3.0,
                        gravity: -30,  // Heavier chunks
                        angularVelocity: new THREE.Vector3(  // Add tumbling
                            (Math.random() - 0.5) * 5,
                            (Math.random() - 0.5) * 5,
                            (Math.random() - 0.5) * 5
                        ),
                        isGiblet: true  // Use giblet physics for rotation
                    };
                    
                    // Add force from bullet direction (less than before)
                    if (forceDirection && forceDirection.x !== undefined) {
                        gib.velocity.add(forceDirection.clone().multiplyScalar(5)); // Reduced from 10
                    }
                    
                    gib.mesh.position.copy(safePos);
                    this.scene.add(gib.mesh);
                    this.particles.push(gib);
                }
                
                // Create blood mist from neck
                for (let i = 0; i < 5; i++) {
                    const mist = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(0.2 + Math.random() * 0.2, 3, 2),
                            new THREE.MeshBasicMaterial({ 
                                color: 0x660000,
                                transparent: true,
                                opacity: 0.6
                            })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 3,
                            Math.random() * 2 + 1,
                            (Math.random() - 0.5) * 3
                        ),
                        life: 0.6,
                        maxLife: 0.6,
                        isMist: true
                    };
                    
                    mist.mesh.position.copy(safePos);
                    this.scene.add(mist.mesh);
                    this.particles.push(mist);
                }
                
                // Create upward blood fountain effect
                this.createBloodJet(safePos, new THREE.Vector3(0, 1, 0));
            }
            
            createDismemberment(position, damageType = 'explosive', forceDirection = null) {
                // DISABLED - Causing crashes, using simple effects instead
                // Safety check for valid position
                if (!position || position.x === undefined || position.y === undefined || position.z === undefined) {
                    console.warn('Invalid position for dismemberment:', position);
                    return;
                }
                
                // Use simple but satisfying blood effects instead of complex dismemberment
                const safePosition = position.clone();
                
                // Create multiple blood explosions for impact
                this.createExplosion(safePosition, 0xcc0000, 25); // Red explosion
                this.createExplosion(safePosition, 0x880000, 15); // Dark red
                
                // Add directional blood spray
                if (forceDirection && forceDirection.x !== undefined) {
                    this.createBloodJet(safePosition, forceDirection);
                    // Create side sprays for more gore
                    const perpVector = new THREE.Vector3(-forceDirection.z, 0, forceDirection.x);
                    this.createBloodJet(safePosition, perpVector.normalize());
                }
                
                // Extra effects based on damage type
                if (damageType === 'explosive') {
                    // More explosions for explosive kills
                    setTimeout(() => this.createExplosion(safePosition, 0xff0000, 20), 50);
                } else if (damageType === 'headshot') {
                    // Extra blood jet upward for headshots
                    this.createBloodJet(safePosition, new THREE.Vector3(0, 1, 0));
                }
                
                return; // Skip all the complex dismemberment code below
                
                /* ORIGINAL DISMEMBERMENT CODE - DISABLED DUE TO CRASHES
                
                // Adjust particle counts based on damage type for more satisfying effects
                let gibletCount, bloodSplatterCount, mistCount;
                
                switch(damageType) {
                    case 'explosive':
                        gibletCount = 10 + Math.floor(Math.random() * 5);  // More giblets for explosions
                        bloodSplatterCount = 20;
                        mistCount = 10;
                        break;
                    case 'headshot':
                        gibletCount = 6 + Math.floor(Math.random() * 3);   // Fewer but more directed
                        bloodSplatterCount = 25;  // More blood for headshots
                        mistCount = 8;
                        break;
                    case 'melee':
                        gibletCount = 8 + Math.floor(Math.random() * 4);   // Chunky melee cuts
                        bloodSplatterCount = 15;
                        mistCount = 6;
                        break;
                    default:
                        gibletCount = 7 + Math.floor(Math.random() * 3);
                        bloodSplatterCount = 12;
                        mistCount = 5;
                }
                
                // Create giblets (body parts) with shared geometry for performance
                const sharedGeometries = {
                    small: new THREE.BoxGeometry(0.15, 0.15, 0.15),
                    medium: new THREE.SphereGeometry(0.2, 3, 2),
                    large: new THREE.BoxGeometry(0.25, 0.25, 0.2),
                    limb: new THREE.CylinderGeometry(0.08, 0.06, 0.4, 4)
                };
                
                for (let i = 0; i < gibletCount; i++) {
                    // Use shared geometry for performance
                    let geometry;
                    const gibletType = Math.random();
                    let scaleFactor = 0.8 + Math.random() * 0.4; // Vary size
                    
                    if (gibletType < 0.3) {
                        geometry = sharedGeometries.small;
                    } else if (gibletType < 0.6) {
                        geometry = sharedGeometries.medium;
                    } else if (gibletType < 0.85) {
                        geometry = sharedGeometries.limb;
                        scaleFactor *= 1.2; // Make limbs slightly bigger
                    } else {
                        geometry = sharedGeometries.large;
                    }
                    
                    // Vary colors between red flesh and darker meat
                    const gibletColor = Math.random() < 0.7 ? 
                        new THREE.Color(0.8 + Math.random() * 0.2, 0, 0) : // Red flesh
                        new THREE.Color(0.4 + Math.random() * 0.2, 0, 0); // Dark meat
                    
                    // Create material with slight variation
                    const material = new THREE.MeshBasicMaterial({ 
                        color: gibletColor,
                        opacity: 0.95,
                        transparent: true
                    });
                    
                    const giblet = {
                        mesh: new THREE.Mesh(geometry, material),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 25,  // Increased velocity
                            Math.random() * 20 + 8,      // More upward force
                            (Math.random() - 0.5) * 25
                        ),
                        angularVelocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 15,  // More spin
                            (Math.random() - 0.5) * 15,
                            (Math.random() - 0.5) * 15
                        ),
                        life: 2.5 + Math.random() * 1.5, // Slightly shorter lifetime
                        maxLife: 4.0,
                        gravity: -30,  // Stronger gravity
                        isGiblet: true,
                        bounces: 0,
                        maxBounces: 2 + Math.floor(Math.random() * 2),
                        scaleFactor: scaleFactor
                    };
                    
                    // Apply force direction if provided (from explosions, etc)
                    if (forceDirection && forceDirection.x !== undefined) {
                        const safeForce = forceDirection.clone();
                        const forceMultiplier = damageType === 'explosive' ? 30 : 20;
                        giblet.velocity.add(safeForce.multiplyScalar(forceMultiplier + Math.random() * 10));
                    }
                    
                    // Set scale
                    giblet.mesh.scale.setScalar(scaleFactor);
                    
                    // Add some rotational force for more realistic tumbling
                    giblet.mesh.rotation.set(
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2
                    );
                    
                    giblet.mesh.position.copy(safePosition);
                    giblet.mesh.position.add(new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        Math.random() * 0.5,
                        (Math.random() - 0.5) * 0.5
                    ));
                    
                    this.scene.add(giblet.mesh);
                    this.particles.push(giblet);
                }
                
                // Create blood splatter particles
                for (let i = 0; i < bloodSplatterCount; i++) {
                    const bloodSize = 0.05 + Math.random() * 0.15;
                    const bloodParticle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(bloodSize, 3, 2),  // Reduced segments
                            new THREE.MeshBasicMaterial({ 
                                color: 0xaa0000,
                                transparent: true,
                                opacity: 0.9
                            })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 25,
                            Math.random() * 20,
                            (Math.random() - 0.5) * 25
                        ),
                        life: 1.5 + Math.random() * 1.0,
                        maxLife: 2.5,
                        gravity: -20,
                        isBlood: true
                    };
                    
                    // Apply force direction if provided
                    if (forceDirection && forceDirection.x !== undefined) {
                        const safeForce = forceDirection.clone();
                        bloodParticle.velocity.add(safeForce.multiplyScalar(15));
                    }
                    
                    bloodParticle.mesh.position.copy(safePosition);
                    this.scene.add(bloodParticle.mesh);
                    this.particles.push(bloodParticle);
                }
                
                // Create blood mist cloud
                for (let i = 0; i < mistCount; i++) {
                    const mist = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(0.3 + Math.random() * 0.3, 3, 2),  // Reduced segments
                            new THREE.MeshBasicMaterial({ 
                                color: 0x660000,
                                transparent: true,
                                opacity: 0.4
                            })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 8,
                            Math.random() * 5,
                            (Math.random() - 0.5) * 8
                        ),
                        life: 0.8,
                        maxLife: 0.8,
                        isMist: true,
                        expandRate: 2.0 // Mist expands over time
                    };
                    
                    mist.mesh.position.copy(safePosition);
                    this.scene.add(mist.mesh);
                    this.particles.push(mist);
                }
                
                // Add extra blood burst for headshots
                if (damageType === 'headshot') {
                    this.createBloodJet(safePosition, forceDirection || new THREE.Vector3(0, 1, 0));
                }
                
                // Cleanup shared geometries after use
                // (They're reused within this call but can be disposed after)
                setTimeout(() => {
                    if (sharedGeometries.small) sharedGeometries.small.dispose();
                    if (sharedGeometries.medium) sharedGeometries.medium.dispose();
                    if (sharedGeometries.large) sharedGeometries.large.dispose();
                    if (sharedGeometries.limb) sharedGeometries.limb.dispose();
                }, 100);
                */
            }

            update(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.life -= deltaTime;
                    
                    if (particle.life <= 0) {
                        this.scene.remove(particle.mesh);
                        particle.mesh.geometry.dispose();
                        particle.mesh.material.dispose();
                        this.particles.splice(i, 1);
                        continue;
                    }
                    
                    // Handle shockwave expansion
                    if (particle.isShockwave) {
                        particle.currentSize += particle.expandSpeed * deltaTime;
                        if (particle.currentSize <= particle.maxSize) {
                            particle.mesh.scale.set(particle.currentSize, particle.currentSize, particle.currentSize);
                            // Fade out rapidly as it expands
                            const progress = particle.currentSize / particle.maxSize;
                            particle.mesh.material.opacity = 0.25 * (1 - progress * progress); // Start at 25%, squared for faster fade
                        }
                        continue; // Skip normal particle physics for shockwave
                    }
                    
                    // Apply gravity (custom gravity for particles, skip if gravity is 0)
                    if (particle.gravity !== undefined) {
                        if (particle.gravity !== 0) {
                            particle.velocity.y += particle.gravity * deltaTime;
                        }
                        // If gravity is 0, don't apply any gravity (for floating mist)
                    } else {
                        particle.velocity.y -= 20 * deltaTime; // default gravity
                    }
                    
                    // Handle giblet physics
                    if (particle.isGiblet) {
                        // Apply angular velocity for tumbling
                        if (particle.angularVelocity) {
                            particle.mesh.rotation.x += particle.angularVelocity.x * deltaTime;
                            particle.mesh.rotation.y += particle.angularVelocity.y * deltaTime;
                            particle.mesh.rotation.z += particle.angularVelocity.z * deltaTime;
                            
                            // Slow down angular velocity over time
                            particle.angularVelocity.multiplyScalar(0.98);
                        }
                        
                        // Check for ground collision (simple bounce)
                        if (particle.mesh.position.y <= 0.2 && particle.velocity.y < 0) {
                            particle.mesh.position.y = 0.2;
                            particle.velocity.y *= -0.4; // Bounce with energy loss
                            particle.velocity.x *= 0.7; // Friction
                            particle.velocity.z *= 0.7;
                            
                            particle.bounces++;
                            if (particle.bounces >= particle.maxBounces) {
                                // Stop bouncing after max bounces
                                particle.velocity.set(0, 0, 0);
                                if (particle.angularVelocity) {
                                    particle.angularVelocity.multiplyScalar(0.5);
                                }
                            }
                        }
                    }
                    
                    // Calculate alpha first
                    const alpha = particle.life / particle.maxLife;
                    
                    // Handle mist expansion
                    if (particle.isMist && particle.expandRate) {
                        const expansion = 1 + (1 - alpha) * particle.expandRate;
                        particle.mesh.scale.setScalar(expansion);
                    }
                    
                    particle.mesh.position.add(particle.velocity.clone().multiplyScalar(deltaTime));
                    
                    // Set opacity
                    particle.mesh.material.opacity = alpha;
                    
                    // Only scale down non-mist and non-giblet particles
                    if (!particle.isMist && !particle.isGiblet && !particle.isBlood) {
                        particle.mesh.scale.setScalar(alpha);
                    }
                }
            }
        }

        // Enemy class
        class Enemy {
            constructor(scene, position, type = 0, currentWave = 1) {
                this.scene = scene;
                this.type = type;
                this.position = position.clone();
                this.velocity = new THREE.Vector3();
                this.mesh = null;
                this.currentWave = currentWave;
                
                // Enemy types with different stats
                const types = [
                    { hp: 50, speed: 3, color: 0xff4444, size: 1.5, damage: 10, score: 100 },
                    { hp: 75, speed: 2.5, color: 0x44ff44, size: 1.8, damage: 15, score: 150 },
                    { hp: 100, speed: 2, color: 0x4444ff, size: 2.25, damage: 20, score: 200 }
                ];
                
                const typeData = types[type];
                this.maxHp = typeData.hp;
                this.hp = this.maxHp;
                this.speed = typeData.speed;
                this.damage = typeData.damage;
                this.scoreValue = typeData.score;
                this.size = typeData.size;
                this.color = typeData.color;
                
                this.active = true;
                this.lastAttackTime = 0;
                this.attackCooldown = 1.0; // seconds for melee
                
                // All enemies are now ranged attackers
                this.isRanged = true;
                this.lastRangedAttackTime = 0;
                this.rangedDamage = 5;
                this.projectileSpeed = 30;
                this.attackRange = 30; // Maximum shooting distance
                
                // Determine weapon type based on wave
                this.weaponType = 'pistol'; // default
                this.isBurstFire = false;
                this.burstCount = 0;
                this.burstDelay = 0.15; // Default burst delay between shots
                this.lastBurstShotTime = 0;
                
                // Wave-based weapon assignment
                if (currentWave >= 20 && Math.random() < 0.1) {
                    // 10% chance for SMG burst after wave 20
                    this.weaponType = 'smg';
                    this.isBurstFire = true;
                    this.burstCount = 0;
                    this.burstDelay = 0.1; // SMG fire rate (slower)
                    this.maxBurstShots = 10; // 10-round burst
                    this.rangedAttackCooldown = 4.0; // Much longer cooldown between bursts
                } else if (currentWave >= 15 && Math.random() < 0.1) {
                    // 10% chance for rocket after wave 15
                    this.weaponType = 'rocket';
                    this.rangedAttackCooldown = 5.0; // Slower rocket fire rate
                    this.projectileSpeed = 20; // Slower rockets
                } else if (currentWave >= 10 && Math.random() < 0.15) {
                    // 15% chance for shotgun after wave 10
                    this.weaponType = 'shotgun';
                    this.rangedAttackCooldown = 2.5; // Slower shotgun fire rate
                } else if (Math.random() < 0.25) {
                    // 25% chance for regular 3-round burst
                    this.isBurstFire = true;
                    this.maxBurstShots = 3;
                    this.rangedAttackCooldown = 1.5; // Slower burst cooldown
                } else {
                    // Single shot pistol
                    this.rangedAttackCooldown = 1.5; // Slower pistol fire rate
                }
                
                this.createMesh();
                this.createHealthBar();
                
                // Store reference to enemy bullets (will be set by game)
                this.enemyBullets = null;
            }

            createMesh() {
                // Create humanoid model group
                this.mesh = new THREE.Group();
                this.mesh.position.copy(this.position);
                
                // Material for body parts
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: this.color });
                const skinMaterial = new THREE.MeshLambertMaterial({ color: 0xffaa88 });
                
                // Create body parts with physics-ready separate meshes
                this.bodyParts = {
                    torso: null,
                    head: null,
                    leftArm: null,
                    rightArm: null,
                    leftLeg: null,
                    rightLeg: null
                };
                
                // Torso (main body)
                const torsoGeometry = new THREE.BoxGeometry(0.6 * this.size, 0.8 * this.size, 0.3 * this.size);
                this.bodyParts.torso = new THREE.Mesh(torsoGeometry, bodyMaterial);
                this.bodyParts.torso.position.y = 0.8;
                this.bodyParts.torso.castShadow = true;
                this.bodyParts.torso.name = 'torso';
                this.mesh.add(this.bodyParts.torso);
                
                // Head with hitbox
                const headGeometry = new THREE.SphereGeometry(0.25 * this.size, 8, 6);
                this.bodyParts.head = new THREE.Mesh(headGeometry, skinMaterial);
                this.bodyParts.head.position.y = 1.5;
                this.bodyParts.head.castShadow = true;
                this.bodyParts.head.name = 'head';
                // Store head reference for hitbox detection
                this.headMesh = this.bodyParts.head;
                this.mesh.add(this.bodyParts.head);
                
                // Arms
                const armGeometry = new THREE.BoxGeometry(0.15 * this.size, 0.6 * this.size, 0.15 * this.size);
                this.bodyParts.leftArm = new THREE.Mesh(armGeometry, skinMaterial);
                this.bodyParts.leftArm.position.set(-0.45 * this.size, 0.8, 0);
                this.bodyParts.leftArm.castShadow = true;
                this.bodyParts.leftArm.name = 'leftArm';
                this.mesh.add(this.bodyParts.leftArm);
                
                this.bodyParts.rightArm = new THREE.Mesh(armGeometry.clone(), skinMaterial);
                this.bodyParts.rightArm.position.set(0.45 * this.size, 0.8, 0);
                this.bodyParts.rightArm.castShadow = true;
                this.bodyParts.rightArm.name = 'rightArm';
                this.mesh.add(this.bodyParts.rightArm);
                
                // Legs
                const legGeometry = new THREE.BoxGeometry(0.2 * this.size, 0.8 * this.size, 0.2 * this.size);
                this.bodyParts.leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                this.bodyParts.leftLeg.position.set(-0.2 * this.size, 0.4, 0);
                this.bodyParts.leftLeg.castShadow = true;
                this.bodyParts.leftLeg.name = 'leftLeg';
                this.mesh.add(this.bodyParts.leftLeg);
                
                this.bodyParts.rightLeg = new THREE.Mesh(legGeometry.clone(), bodyMaterial);
                this.bodyParts.rightLeg.position.set(0.2 * this.size, 0.4, 0);
                this.bodyParts.rightLeg.castShadow = true;
                this.bodyParts.rightLeg.name = 'rightLeg';
                this.mesh.add(this.bodyParts.rightLeg);
                
                // Add glowing eyes
                const eyeGeometry = new THREE.SphereGeometry(0.05, 4, 4);
                const eyeMaterial = new THREE.MeshBasicMaterial({ 
                    color: this.isRanged ? 0xffff00 : 0xff0000,
                    emissive: this.isRanged ? 0xffff00 : 0xff0000,
                    emissiveIntensity: 0.5
                });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                
                leftEye.position.set(-0.08, 0.05, 0.2);
                rightEye.position.set(0.08, 0.05, 0.2);
                
                this.bodyParts.head.add(leftEye);
                this.bodyParts.head.add(rightEye);
                
                // Add gun to right arm for ranged enemies
                if (this.isRanged) {
                    let gunGeometry, gunColor;
                    
                    // Different gun models based on weapon type
                    switch(this.weaponType) {
                        case 'rocket':
                            gunGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 6); // Larger for rocket launcher
                            gunColor = 0x444400; // Dark yellow
                            break;
                        case 'shotgun':
                            gunGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.35, 8); // Wider, shorter
                            gunColor = 0x663300; // Brown
                            break;
                        case 'smg':
                            gunGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.45, 6); // Longer for SMG
                            gunColor = 0x333366; // Dark blue
                            break;
                        default: // pistol
                            gunGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 6);
                            gunColor = this.isBurstFire ? 0x888888 : 0x222222; // Silver for burst, black for single
                    }
                    
                    const gunMaterial = new THREE.MeshBasicMaterial({ color: gunColor });
                    this.gun = new THREE.Mesh(gunGeometry, gunMaterial);
                    this.gun.position.set(0, -0.2, 0.15);
                    this.gun.rotation.x = Math.PI / 2;
                    this.bodyParts.rightArm.add(this.gun);
                }
                
                // Animation properties
                this.walkCycle = 0;
                this.animationSpeed = 5;
                this.isDead = false;
                this.ragdollParts = [];
                
                this.scene.add(this.mesh);
            }

            createHealthBar() {
                // Create a simple health bar above the enemy
                this.healthBarContainer = new THREE.Group();
                
                const barWidth = 1;
                const barHeight = 0.1;
                
                // Background
                const bgGeometry = new THREE.PlaneGeometry(barWidth, barHeight);
                const bgMaterial = new THREE.MeshBasicMaterial({ color: 0x440000 });
                this.healthBarBg = new THREE.Mesh(bgGeometry, bgMaterial);
                
                // Health bar
                const hpGeometry = new THREE.PlaneGeometry(barWidth, barHeight);
                const hpMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                this.healthBar = new THREE.Mesh(hpGeometry, hpMaterial);
                
                this.healthBarContainer.add(this.healthBarBg);
                this.healthBarContainer.add(this.healthBar);
                this.healthBarContainer.position.set(0, this.size + 0.5, 0);
                
                this.mesh.add(this.healthBarContainer);
            }

            update(deltaTime, playerPosition, enemyBulletPool, particleSystem, audioManager) {
                if (!this.active || this.isDead) return;

                const distanceToPlayer = this.position.distanceTo(playerPosition);
                let isMoving = false;
                
                // All enemies are ranged now
                if (distanceToPlayer <= this.attackRange) {
                    // Ranged enemy: Stop at a distance and shoot
                    const stopDistance = 15; // Keep distance from player
                    
                    if (distanceToPlayer > stopDistance) {
                        // Move closer if too far
                        const direction = playerPosition.clone().sub(this.position).normalize();
                        this.velocity = direction.multiplyScalar(this.speed * 0.7); // Move slower
                        this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                        isMoving = true;
                    } else if (distanceToPlayer < stopDistance - 2) {
                        // Back away if too close
                        const direction = this.position.clone().sub(playerPosition).normalize();
                        this.velocity = direction.multiplyScalar(this.speed * 0.5);
                        this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                        isMoving = true;
                    }
                    
                    // Try to shoot at player
                    this.attemptRangedAttack(playerPosition, enemyBulletPool, particleSystem, audioManager);
                } else {
                    // Out of range: Move toward player
                    const direction = playerPosition.clone().sub(this.position).normalize();
                    this.velocity = direction.multiplyScalar(this.speed);
                    this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                    isMoving = true;
                }
                
                // Walking animation
                if (isMoving && this.bodyParts) {
                    this.walkCycle += deltaTime * this.animationSpeed;
                    const walkAmount = Math.sin(this.walkCycle) * 0.15;
                    const walkSway = Math.sin(this.walkCycle * 2) * 0.05;
                    
                    // Animate legs
                    if (this.bodyParts.leftLeg) {
                        this.bodyParts.leftLeg.rotation.x = walkAmount;
                        this.bodyParts.leftLeg.position.z = Math.sin(this.walkCycle) * 0.1;
                    }
                    if (this.bodyParts.rightLeg) {
                        this.bodyParts.rightLeg.rotation.x = -walkAmount;
                        this.bodyParts.rightLeg.position.z = -Math.sin(this.walkCycle) * 0.1;
                    }
                    
                    // Animate arms
                    if (this.bodyParts.leftArm) {
                        this.bodyParts.leftArm.rotation.x = -walkAmount * 0.5;
                    }
                    if (this.bodyParts.rightArm && !this.isRanged) {
                        // Only swing right arm if not holding gun
                        this.bodyParts.rightArm.rotation.x = walkAmount * 0.5;
                    }
                    
                    // Slight body sway
                    if (this.bodyParts.torso) {
                        this.bodyParts.torso.rotation.y = walkSway;
                    }
                }
                
                // Update mesh position
                this.mesh.position.copy(this.position);
                
                // Look at player
                this.mesh.lookAt(playerPosition);
                
                // Keep health bar facing camera (billboard effect)
                if (this.healthBarContainer) {
                    this.healthBarContainer.lookAt(playerPosition);
                    this.updateHealthBar();
                }
            }

            attemptRangedAttack(playerPosition, enemyBulletPool, particleSystem, audioManager) {
                if (!this.isRanged || !enemyBulletPool) return;
                
                const now = performance.now() / 1000;
                
                // Handle burst fire mode
                if (this.isBurstFire) {
                    // Check if we can start a new burst
                    if (this.burstCount === 0 && now - this.lastRangedAttackTime < this.rangedAttackCooldown) {
                        return;
                    }
                    
                    // Check if we're in the middle of a burst
                    if (this.burstCount > 0 && now - this.lastBurstShotTime < this.burstDelay) {
                        return;
                    }
                    
                    // Fire a shot
                    this.fireProjectile(playerPosition, enemyBulletPool, particleSystem, audioManager);
                    this.lastBurstShotTime = now;
                    this.burstCount++;
                    
                    // Reset burst after reaching max shots
                    if (this.burstCount >= this.maxBurstShots) {
                        this.burstCount = 0;
                        this.lastRangedAttackTime = now;
                    }
                } else {
                    // Single shot mode
                    if (now - this.lastRangedAttackTime < this.rangedAttackCooldown) return;
                    
                    this.fireProjectile(playerPosition, enemyBulletPool, particleSystem, audioManager);
                    this.lastRangedAttackTime = now;
                }
            }
            
            fireProjectile(playerPosition, enemyBulletPool, particleSystem, audioManager) {
                // Safety checks
                if (!enemyBulletPool || !playerPosition) return;
                
                const baseDirection = playerPosition.clone().sub(this.position).normalize();
                const startPos = this.position.clone();
                startPos.y += this.size * 0.3; // Shoot from mid-height
                startPos.add(baseDirection.clone().multiplyScalar(this.size));
                
                // Handle different weapon types
                if (this.weaponType === 'shotgun') {
                    // Fire 6 pellets with spread
                    for (let i = 0; i < 6; i++) {
                        const bullet = enemyBulletPool.get();
                        if (!bullet) continue;
                        
                        // Add spread to each pellet
                        const direction = baseDirection.clone();
                        direction.x += (Math.random() - 0.5) * 0.15;
                        direction.y += (Math.random() - 0.5) * 0.15;
                        direction.z += (Math.random() - 0.5) * 0.15;
                        direction.normalize();
                        
                        bullet.damage = 3; // Less damage per pellet
                        bullet.speed = 35; // Slightly faster
                        bullet.mesh.material.color.setHex(0xffaa00); // Orange pellets
                        bullet.isEnemyBullet = true;
                        bullet.isRocket = false;
                        bullet.isHellfireRocket = false;
                        bullet.isHellfireBullet = false;
                        bullet.fire(startPos.clone(), direction);
                    }
                } else if (this.weaponType === 'rocket') {
                    // Fire a single rocket
                    const bullet = enemyBulletPool.get();
                    if (!bullet) return;
                    
                    bullet.damage = 30; // High damage
                    bullet.speed = this.projectileSpeed; // Slower
                    bullet.isRocket = true; // Mark as rocket
                    bullet.blastRadius = 5; // Explosion radius
                    bullet.isEnemyBullet = true;
                    bullet.isHellfireRocket = false;
                    bullet.isHellfireBullet = false;
                    bullet.fire(startPos, baseDirection);
                } else {
                    // Regular bullet (pistol or SMG)
                    const bullet = enemyBulletPool.get();
                    if (!bullet) return;
                    
                    bullet.damage = this.weaponType === 'smg' ? 4 : this.rangedDamage;
                    bullet.speed = this.weaponType === 'smg' ? 40 : this.projectileSpeed;
                    bullet.mesh.material.color.setHex(this.weaponType === 'smg' ? 0x00ffff : 0xff0000);
                    bullet.isEnemyBullet = true;
                    bullet.isRocket = false;
                    bullet.isHellfireRocket = false;
                    bullet.isHellfireBullet = false;
                    bullet.fire(startPos, baseDirection);
                }
                
                // Shooting animation - recoil effect
                if (this.bodyParts && this.bodyParts.rightArm && !this.isDead) {
                    // Store original rotation for animation
                    const originalRotation = this.bodyParts.rightArm.rotation.x;
                    
                    // Kick arm back
                    this.bodyParts.rightArm.rotation.x -= 0.3;
                    
                    // Animate gun recoil if present
                    if (this.gun) {
                        const originalGunPos = this.gun.position.z;
                        this.gun.position.z -= 0.05;
                        
                        // Return gun to original position
                        setTimeout(() => {
                            if (this.gun && !this.isDead) {
                                this.gun.position.z = originalGunPos;
                            }
                        }, 100);
                    }
                    
                    // Return arm to original position after short delay
                    setTimeout(() => {
                        if (this.bodyParts && this.bodyParts.rightArm && !this.isDead) {
                            this.bodyParts.rightArm.rotation.x = originalRotation;
                        }
                    }, 100);
                }
                
                // Play enemy shoot sound
                if (audioManager) {
                    audioManager.play('enemyShoot');
                }
                
                // Create muzzle flash (only if particleSystem exists)
                // Disabled - no muzzle flash effect
                // if (particleSystem && particleSystem.createMuzzleFlash) {
                //     particleSystem.createMuzzleFlash(startPos, baseDirection);
                // }
            }

            updateHealthBar() {
                const healthPercent = this.hp / this.maxHp;
                this.healthBar.scale.x = healthPercent;
                this.healthBar.position.x = (1 - healthPercent) * -0.5;
                
                // Color transition: green -> yellow -> red
                if (healthPercent > 0.6) {
                    this.healthBar.material.color.setHex(0x00ff00);
                } else if (healthPercent > 0.3) {
                    this.healthBar.material.color.setHex(0xffff00);
                } else {
                    this.healthBar.material.color.setHex(0xff0000);
                }
            }

            takeDamage(damage) {
                this.hp -= damage;
                this.updateHealthBar();
                
                if (this.hp <= 0) {
                    this.destroy();
                    return true; // Enemy killed
                }
                return false;
            }

            canAttack(currentTime) {
                return currentTime - this.lastAttackTime >= this.attackCooldown;
            }

            attack(currentTime) {
                this.lastAttackTime = currentTime;
                return this.damage;
            }

            destroy(explosionForce = null, explosionPosition = null) {
                this.active = false;
                this.isDead = true;
                
                // Remove health bar immediately
                if (this.healthBarContainer) {
                    this.mesh.remove(this.healthBarContainer);
                    this.healthBar.geometry.dispose();
                    this.healthBar.material.dispose();
                    this.healthBarBg.geometry.dispose();
                    this.healthBarBg.material.dispose();
                }
                
                // Create ragdoll physics for body parts
                if (this.bodyParts && !explosionForce) {
                    // Regular death - create ragdoll
                    this.createRagdoll();
                } else if (this.bodyParts && explosionForce) {
                    // Explosion death - dismember and apply force
                    this.dismember(explosionForce, explosionPosition);
                } else {
                    // Fallback for old enemy models
                    if (this.mesh) {
                        this.scene.remove(this.mesh);
                        this.mesh.geometry.dispose();
                        this.mesh.material.dispose();
                    }
                }
            }
            
            createRagdoll() {
                // Store reference to scene for cleanup
                const scene = this.scene;
                
                // For non-explosion death, create joint-based ragdoll
                if (this.mesh && this.bodyParts) {
                    // Create main body physics with initial velocity
                    // Less upward force, more horizontal for realistic falling
                    const initialVelocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 3,
                        Math.random() * 1.5 + 0.5, // Reduced upward force
                        (Math.random() - 0.5) * 3
                    );
                    
                    // Main ragdoll object with joint physics
                    const ragdollBody = {
                        mesh: this.mesh,
                        velocity: initialVelocity.clone(),
                        angularVelocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 8, // Increased rotation for more dynamic falling
                            (Math.random() - 0.5) * 8,
                            (Math.random() - 0.5) * 8
                        ),
                        lifetime: 5, // Extended from 3 to 5 seconds for more realistic settling
                        isWholeBody: true,
                        joints: {} // Store joint angular velocities
                    };
                    
                    // Initialize joint physics for each limb
                    if (this.bodyParts.leftArm) {
                        ragdollBody.joints.leftArm = {
                            angularVel: new THREE.Vector3(
                                (Math.random() - 0.5) * 8,
                                0,
                                (Math.random() - 0.5) * 8
                            ),
                            maxAngle: { x: Math.PI/2, y: 0, z: Math.PI/3 }
                        };
                    }
                    if (this.bodyParts.rightArm) {
                        ragdollBody.joints.rightArm = {
                            angularVel: new THREE.Vector3(
                                (Math.random() - 0.5) * 8,
                                0,
                                (Math.random() - 0.5) * 8
                            ),
                            maxAngle: { x: Math.PI/2, y: 0, z: Math.PI/3 }
                        };
                    }
                    if (this.bodyParts.leftLeg) {
                        ragdollBody.joints.leftLeg = {
                            angularVel: new THREE.Vector3(
                                (Math.random() - 0.5) * 6,
                                0,
                                (Math.random() - 0.5) * 4
                            ),
                            maxAngle: { x: Math.PI/3, y: 0, z: Math.PI/6 }
                        };
                    }
                    if (this.bodyParts.rightLeg) {
                        ragdollBody.joints.rightLeg = {
                            angularVel: new THREE.Vector3(
                                (Math.random() - 0.5) * 6,
                                0,
                                (Math.random() - 0.5) * 4
                            ),
                            maxAngle: { x: Math.PI/3, y: 0, z: Math.PI/6 }
                        };
                    }
                    if (this.bodyParts.head) {
                        ragdollBody.joints.head = {
                            angularVel: new THREE.Vector3(
                                (Math.random() - 0.5) * 4,
                                (Math.random() - 0.5) * 4,
                                (Math.random() - 0.5) * 4
                            ),
                            maxAngle: { x: Math.PI/4, y: Math.PI/4, z: Math.PI/4 }
                        };
                    }
                    
                    this.ragdollParts.push(ragdollBody);
                }
                
                // Start ragdoll physics simulation
                this.simulateRagdollWithJoints(scene);
            }
            
            simulateRagdollWithJoints(scene) {
                const gravity = -9.8;
                const damping = 0.99; // Increased from 0.98 for slower energy loss
                const jointDamping = 0.96; // Increased from 0.92 for more active joints
                const groundLevel = 0;
                
                const animate = () => {
                    if (this.ragdollParts.length === 0) return;
                    
                    const deltaTime = 1/60;
                    
                    for (let i = this.ragdollParts.length - 1; i >= 0; i--) {
                        const part = this.ragdollParts[i];
                        
                        // Apply gravity to main body
                        part.velocity.y += gravity * deltaTime;
                        
                        // Update main body position
                        part.mesh.position.add(part.velocity.clone().multiplyScalar(deltaTime));
                        
                        // Update main body rotation
                        part.mesh.rotation.x += part.angularVelocity.x * deltaTime;
                        part.mesh.rotation.y += part.angularVelocity.y * deltaTime;
                        part.mesh.rotation.z += part.angularVelocity.z * deltaTime;
                        
                        // Update joint rotations if this is a whole body
                        if (part.isWholeBody && part.joints && this.bodyParts) {
                            // Animate each joint
                            for (let jointName in part.joints) {
                                const joint = part.joints[jointName];
                                const bodyPart = this.bodyParts[jointName];
                                
                                if (bodyPart && joint) {
                                    // Apply joint angular velocity
                                    bodyPart.rotation.x += joint.angularVel.x * deltaTime;
                                    bodyPart.rotation.y += joint.angularVel.y * deltaTime;
                                    bodyPart.rotation.z += joint.angularVel.z * deltaTime;
                                    
                                    // Clamp to max angles (joint limits)
                                    bodyPart.rotation.x = Math.max(-joint.maxAngle.x, Math.min(joint.maxAngle.x, bodyPart.rotation.x));
                                    bodyPart.rotation.y = Math.max(-joint.maxAngle.y, Math.min(joint.maxAngle.y, bodyPart.rotation.y));
                                    bodyPart.rotation.z = Math.max(-joint.maxAngle.z, Math.min(joint.maxAngle.z, bodyPart.rotation.z));
                                    
                                    // Apply joint damping
                                    joint.angularVel.multiplyScalar(jointDamping);
                                    
                                    // Add some gravity effect on limbs
                                    if (jointName.includes('Arm')) {
                                        joint.angularVel.z += gravity * 0.05 * deltaTime;
                                    }
                                }
                            }
                        }
                        
                        // Ground collision
                        if (part.mesh.position.y <= groundLevel) {
                            part.mesh.position.y = groundLevel;
                            part.velocity.y *= -0.2; // Very little bounce
                            part.velocity.x *= 0.6; // High friction
                            part.velocity.z *= 0.6;
                            part.angularVelocity.multiplyScalar(0.7);
                            
                            // Reduce joint velocities on ground impact
                            if (part.joints) {
                                for (let jointName in part.joints) {
                                    part.joints[jointName].angularVel.multiplyScalar(0.5);
                                }
                            }
                        }
                        
                        // Apply damping
                        part.velocity.multiplyScalar(damping);
                        part.angularVelocity.multiplyScalar(damping * 0.95);
                        
                        // Update lifetime
                        part.lifetime -= deltaTime;
                        
                        // Fade out only in last 0.5 seconds
                        if (part.lifetime < 0.5) {
                            const opacity = part.lifetime * 2; // Scale to 0-1 range
                            // Apply opacity to all materials in the mesh
                            part.mesh.traverse((child) => {
                                if (child.material) {
                                    child.material.opacity = opacity;
                                    child.material.transparent = true;
                                }
                            });
                        }
                        
                        // Remove when expired
                        if (part.lifetime <= 0) {
                            scene.remove(part.mesh);
                            part.mesh.traverse((child) => {
                                if (child.geometry) child.geometry.dispose();
                                if (child.material) {
                                    if (Array.isArray(child.material)) {
                                        child.material.forEach(m => m.dispose());
                                    } else {
                                        child.material.dispose();
                                    }
                                }
                            });
                            this.ragdollParts.splice(i, 1);
                        }
                    }
                    
                    if (this.ragdollParts.length > 0) {
                        requestAnimationFrame(animate);
                    }
                };
                
                requestAnimationFrame(animate);
            }
            
            dismember(explosionForce, explosionPosition) {
                const scene = this.scene;
                const bodyParts = this.bodyParts;
                
                // Remove the group mesh from scene
                if (this.mesh) {
                    scene.remove(this.mesh);
                }
                
                // Create massive blood spurt at dismemberment point
                const game = window.currentGame;
                if (game && game.particleSystem && this.position) {
                    const bodyCenter = this.position.clone();
                    bodyCenter.y += 1; // Center of torso
                    
                    // Calculate direction away from explosion
                    const spurDirection = bodyCenter.clone().sub(explosionPosition).normalize();
                    
                    // Create multiple blood jets for massive gore effect
                    for (let i = 0; i < 3; i++) {
                        // Vary the direction slightly for each jet
                        const jetDir = spurDirection.clone();
                        jetDir.x += (Math.random() - 0.5) * 0.3;
                        jetDir.y += Math.random() * 0.3; // Upward bias
                        jetDir.z += (Math.random() - 0.5) * 0.3;
                        jetDir.normalize();
                        
                        // Create intense blood jet
                        game.particleSystem.createMassiveBloodSpurt(bodyCenter, jetDir);
                    }
                }
                
                // 50% chance to play explosion sound
                if (Math.random() < 0.5) {
                    // Note: This will be called from game update
                    this.shouldPlayExplodeSound = true;
                }
                
                // Separate and launch each body part
                for (let partName in bodyParts) {
                    const part = bodyParts[partName];
                    if (!part) continue;
                    
                    // Get world position
                    const worldPos = new THREE.Vector3();
                    part.getWorldPosition(worldPos);
                    
                    // Calculate explosion direction and force
                    const direction = worldPos.clone().sub(explosionPosition).normalize();
                    const distance = worldPos.distanceTo(explosionPosition);
                    const force = explosionForce * Math.max(0, 1 - distance / 10);
                    
                    // Remove from parent and add to scene
                    this.mesh.remove(part);
                    part.position.copy(worldPos);
                    scene.add(part);
                    
                    // Create physics with explosion force
                    const ragdollPart = {
                        mesh: part,
                        velocity: direction.multiplyScalar(force).add(
                            new THREE.Vector3(0, force * 0.5, 0) // Add upward force
                        ),
                        angularVelocity: new THREE.Vector3(
                            (Math.random() - 0.5) * force * 2,
                            (Math.random() - 0.5) * force * 2,
                            (Math.random() - 0.5) * force * 2
                        ),
                        lifetime: 5 // longer lifetime for explosion parts
                    };
                    
                    // Add blood trail effect for dismembered parts
                    ragdollPart.hasBloodTrail = true;
                    
                    this.ragdollParts.push(ragdollPart);
                }
                
                // Start ragdoll physics simulation for dismembered parts
                this.simulateRagdollParts(scene);
            }
            
            simulateRagdollParts(scene, particleSystem = null) {
                const gravity = -9.8;
                const damping = 0.98;
                const groundLevel = 0;
                
                // Pass particleSystem from game for blood trails
                const game = window.currentGame;
                if (!particleSystem && game && game.particleSystem) {
                    particleSystem = game.particleSystem;
                }
                
                const animate = () => {
                    if (this.ragdollParts.length === 0) return;
                    
                    const deltaTime = 1/60; // Fixed timestep for consistency
                    
                    for (let i = this.ragdollParts.length - 1; i >= 0; i--) {
                        const part = this.ragdollParts[i];
                        
                        // Enhanced blood trail system - more dramatic
                        if (part.hasBloodTrail && particleSystem) {
                            // Emit based on velocity - faster parts bleed more
                            const speed = part.velocity.length();
                            if (speed > 1) { // Lower threshold for more trails
                                if (!part.lastBloodTime) part.lastBloodTime = 0;
                                part.lastBloodTime += deltaTime;
                                
                                // Emit more frequently when moving fast
                                const emitRate = Math.max(0.03, 0.1 - speed * 0.01); // Faster = more frequent
                                
                                if (part.lastBloodTime > emitRate) {
                                    // Only emit if not too many particles already
                                    if (particleSystem.particles.length < 400) {
                                        // Emit 2-3 droplets for more dramatic effect
                                        const dropletCount = speed > 5 ? 3 : 2;
                                        for (let d = 0; d < dropletCount; d++) {
                                            const randomOffset = new THREE.Vector3(
                                                (Math.random() - 0.5) * 0.2,
                                                (Math.random() - 0.5) * 0.2,
                                                (Math.random() - 0.5) * 0.2
                                            );
                                            const dropletPos = part.mesh.position.clone().add(randomOffset);
                                            const dropletVel = part.velocity.clone().multiplyScalar(-0.2 + Math.random() * 0.1);
                                            particleSystem.createBloodDroplet(dropletPos, dropletVel);
                                        }
                                    }
                                    part.lastBloodTime = 0;
                                }
                            }
                        }
                        
                        // Apply gravity
                        part.velocity.y += gravity * deltaTime;
                        
                        // Apply velocity
                        part.mesh.position.add(part.velocity.clone().multiplyScalar(deltaTime));
                        
                        // Apply rotation
                        part.mesh.rotation.x += part.angularVelocity.x * deltaTime;
                        part.mesh.rotation.y += part.angularVelocity.y * deltaTime;
                        part.mesh.rotation.z += part.angularVelocity.z * deltaTime;
                        
                        // Ground collision
                        if (part.mesh.position.y <= groundLevel) {
                            part.mesh.position.y = groundLevel;
                            part.velocity.y *= -0.3; // Bounce with energy loss
                            part.velocity.x *= 0.7; // Friction
                            part.velocity.z *= 0.7;
                            part.angularVelocity.multiplyScalar(0.8);
                        }
                        
                        // Apply damping
                        part.velocity.multiplyScalar(damping);
                        part.angularVelocity.multiplyScalar(damping * 0.95);
                        
                        // Update lifetime
                        part.lifetime -= deltaTime;
                        
                        // Fade out near end of lifetime
                        if (part.lifetime < 1) {
                            part.mesh.material.opacity = part.lifetime;
                            part.mesh.material.transparent = true;
                        }
                        
                        // Remove when lifetime expires
                        if (part.lifetime <= 0) {
                            scene.remove(part.mesh);
                            
                            // For whole body ragdoll, dispose all child meshes
                            if (part.isWholeBody) {
                                part.mesh.traverse((child) => {
                                    if (child.geometry) child.geometry.dispose();
                                    if (child.material) {
                                        if (Array.isArray(child.material)) {
                                            child.material.forEach(m => m.dispose());
                                        } else {
                                            child.material.dispose();
                                        }
                                    }
                                });
                            } else {
                                // Individual part cleanup
                                if (part.mesh.geometry) part.mesh.geometry.dispose();
                                if (part.mesh.material) part.mesh.material.dispose();
                            }
                            
                            this.ragdollParts.splice(i, 1);
                        }
                    }
                    
                    // Continue animation if parts remain
                    if (this.ragdollParts.length > 0) {
                        requestAnimationFrame(animate);
                    }
                };
                
                // Start animation
                requestAnimationFrame(animate);
            }

            getDistanceToPlayer(playerPosition) {
                return this.position.distanceTo(playerPosition);
            }
        }

        // Pickup class
        class Pickup {
            constructor(scene, position, type) {
                this.scene = scene;
                this.position = position.clone();
                this.type = type; // 'health' or 'ammo'
                this.active = true;
                this.rotationSpeed = 2;
                this.bobSpeed = 3;
                this.bobAmount = 0.3;
                this.time = Math.random() * Math.PI * 2;
                this.collected = false;
                
                this.createMesh();
            }

            createMesh() {
                let geometry, material;
                
                if (this.type === 'health') {
                    geometry = new THREE.BoxGeometry(0.8, 0.8, 0.2);
                    material = new THREE.MeshBasicMaterial({ 
                        color: 0x00ff00
                    });
                } else { // ammo
                    geometry = new THREE.BoxGeometry(0.6, 1.2, 0.6);
                    material = new THREE.MeshBasicMaterial({ 
                        color: 0xffff00
                    });
                }
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }

            update(deltaTime) {
                if (!this.active || this.collected) return;

                this.time += deltaTime;
                
                // Rotate
                this.mesh.rotation.y += this.rotationSpeed * deltaTime;
                
                // Bob up and down
                this.mesh.position.y = this.position.y + Math.sin(this.time * this.bobSpeed) * this.bobAmount;
            }

            collect() {
                if (this.collected) return null;
                
                this.collected = true;
                this.active = false;
                
                this.scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
                
                return this.type;
            }

            getPosition() {
                return this.position;
            }
        }

        // Weapon System
        class WeaponSystem {
            constructor(scene, camera, audioManager) {
                this.scene = scene;
                this.camera = camera;
                this.audioManager = audioManager;
                
                // Current weapon
                this.currentWeapon = 'smg'; // 'smg', 'shotgun', 'rocket', or 'sword'
                
                // Weapon definitions
                this.weapons = {
                    smg: {
                        maxAmmo: 30,
                        currentAmmo: 30,  // Store ammo per weapon
                        fireRate: 0.05,  // Doubled fire rate (was 0.1)
                        reloadTime: 1.0,  // Halved reload time (was 2.0)
                        damage: 25,
                        isAutomatic: true,
                        recoilAmount: 0.02,
                        soundName: 'shoot',
                        projectileCount: 1,
                        spread: 0,
                        screenShake: 0.004  // Slight screen shake (increased for visibility)
                    },
                    shotgun: {
                        maxAmmo: 6,
                        currentAmmo: 6,   // Store ammo per weapon
                        fireRate: 0.3,  // Halved time between shots (was 0.6)
                        reloadTime: 1.25,  // Halved reload time (was 2.5)
                        damage: 20,
                        isAutomatic: false,
                        recoilAmount: 0.08,
                        soundName: 'shotgun',
                        projectileCount: 6,
                        spread: 0.1,
                        screenShake: 0.02,   // Significant screen shake (increased for impact)
                        isShotgun: true      // Flag for Blood Thirst double pellets
                    },
                    rocket: {
                        maxAmmo: 1,
                        currentAmmo: 1,    // Single shot magazine
                        fireRate: 0.5,     // Even faster fire rate for rapid rockets
                        reloadTime: 1.5,   // Halved reload time (was 3.0)
                        damage: 100,       // High direct damage
                        isAutomatic: false,
                        recoilAmount: 0.12, // Heavy recoil
                        soundName: 'rocket',
                        projectileCount: 1,
                        spread: 0,
                        screenShake: 0.04,  // Maximum screen shake
                        isRocket: true,     // Special flag for rocket
                        blastRadius: 8,     // Explosion radius
                        projectileSpeed: 40 // Slower than bullets
                    },
                    sword: {
                        maxAmmo: 0,        // No ammo for melee
                        currentAmmo: 0,    // No ammo for melee
                        fireRate: 0.25,    // Faster swing speed (was 0.5)
                        reloadTime: 0,     // No reload
                        damage: 75,        // High damage (1-2 hit kill)
                        isAutomatic: false,
                        recoilAmount: 0,   // No recoil for melee
                        soundName: 'swordSwing',
                        projectileCount: 0,// No projectiles
                        spread: 0,
                        screenShake: 0.01,
                        isMelee: true,     // Flag for melee weapon
                        meleeRange: 5,     // Increased melee attack range (was 3)
                        swingAngle: 120    // Wider swing arc (was 90)
                    }
                };
                
                // Shared ammo pool
                this.reserveAmmo = 90;
                this.maxReserve = 120;
                this.lastShotTime = 0;
                this.isReloading = false;
                this.reloadStartTime = 0;
                this.triggerReleased = true;
                
                // Sword swing state
                this.isSwinging = false;
                this.swingProgress = 0;
                this.swingStartTime = 0;
                this.swingDuration = 0.2; // 200ms swing animation
                this.swingOffset = { rotation: { y: 0, z: 0 }, position: { x: 0, z: 0 } };
                
                // Blood Thirst state
                this.bloodThirstActive = false;
                
                // Hellfire state
                this.hellfireActive = false;
                
                // BERSERK state
                this.berserkActive = false;
                
                // Weapon sway and recoil
                this.weaponSway = { x: 0, y: 0 };
                this.recoil = { x: 0, y: 0 };
                this.swayAmount = 0.002;
                
                // Screen shake system
                this.screenShake = { x: 0, y: 0, intensity: 0, duration: 0 };
                
                // Create weapon models
                this.weaponModels = {};
                this.createSMGModel();
                this.createShotgunModel();
                this.createRocketLauncherModel();
                this.createSwordModel();
                
                // Show initial weapon
                this.switchWeapon('smg');
                this.updateAmmoDisplay();
            }

            createSMGModel() {
                // Create SMG model
                const smgGroup = new THREE.Group();
                
                // SMG body
                const bodyGeometry = new THREE.BoxGeometry(0.12, 0.2, 0.5);
                const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x666666 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.set(0, 0, 0);
                
                // SMG barrel
                const barrelGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 8);
                const barrelMaterial = new THREE.MeshBasicMaterial({ color: 0x444444 });
                const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                barrel.position.set(0, 0.03, -0.35);
                barrel.rotation.x = Math.PI / 2;
                
                // SMG grip
                const gripGeometry = new THREE.BoxGeometry(0.06, 0.12, 0.1);
                const gripMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
                const grip = new THREE.Mesh(gripGeometry, gripMaterial);
                grip.position.set(0, -0.12, 0.15);
                grip.rotation.z = -0.1;
                
                // SMG Magazine
                const magazine = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, 0.1, 0.08),
                    new THREE.MeshBasicMaterial({ color: 0x777777 })
                );
                magazine.position.set(0, -0.1, 0.05);
                
                // Muzzle flash
                const flashGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const muzzleFlash = new THREE.Mesh(
                    flashGeometry,
                    new THREE.MeshBasicMaterial({ 
                        color: 0xffff00, 
                        transparent: true, 
                        opacity: 0 
                    })
                );
                muzzleFlash.position.set(0, 0.03, -0.55);
                
                // Add all parts to SMG group
                smgGroup.add(body);
                smgGroup.add(barrel);
                smgGroup.add(grip);
                smgGroup.add(magazine);
                smgGroup.add(muzzleFlash);
                
                // Set render order
                smgGroup.traverse((child) => {
                    if (child.isMesh) child.renderOrder = 999;
                });
                muzzleFlash.renderOrder = 1000;
                
                // Store references
                smgGroup.userData.magazine = magazine;
                smgGroup.userData.muzzleFlash = muzzleFlash;
                
                this.weaponModels.smg = smgGroup;
                this.scene.add(smgGroup);
                smgGroup.visible = false;
            }

            createRocketLauncherModel() {
                // Create Rocket Launcher model
                const rocketGroup = new THREE.Group();
                
                // Launcher tube (large)
                const tubeGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.8, 8);
                const tubeMaterial = new THREE.MeshBasicMaterial({ color: 0x2a4d2a });
                const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                tube.position.set(0, 0, -0.2);
                tube.rotation.x = Math.PI / 2;
                
                // Front cone
                const coneGeometry = new THREE.ConeGeometry(0.1, 0.15, 8);
                const coneMaterial = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
                const frontCone = new THREE.Mesh(coneGeometry, coneMaterial);
                frontCone.position.set(0, 0, -0.65);
                frontCone.rotation.x = Math.PI / 2;
                
                // Rear exhaust
                const exhaustGeometry = new THREE.CylinderGeometry(0.09, 0.07, 0.2, 8);
                const exhaustMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
                const exhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
                exhaust.position.set(0, 0, 0.25);
                exhaust.rotation.x = Math.PI / 2;
                
                // Grip
                const gripGeometry = new THREE.BoxGeometry(0.06, 0.12, 0.1);
                const gripMaterial = new THREE.MeshBasicMaterial({ color: 0x444444 });
                const grip = new THREE.Mesh(gripGeometry, gripMaterial);
                grip.position.set(0, -0.14, 0);
                
                // Shoulder rest
                const shoulderGeometry = new THREE.BoxGeometry(0.15, 0.08, 0.2);
                const shoulderMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
                const shoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
                shoulder.position.set(0, -0.06, 0.35);
                
                // Sight
                const sightGeometry = new THREE.BoxGeometry(0.03, 0.06, 0.1);
                const sightMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const sight = new THREE.Mesh(sightGeometry, sightMaterial);
                sight.position.set(0, 0.11, -0.1);
                
                // Muzzle flash (larger for rocket)
                const flashGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const muzzleFlash = new THREE.Mesh(
                    flashGeometry,
                    new THREE.MeshBasicMaterial({ 
                        color: 0xff6600, 
                        transparent: true, 
                        opacity: 0 
                    })
                );
                muzzleFlash.position.set(0, 0, -0.75);
                
                // Add all parts
                rocketGroup.add(tube);
                rocketGroup.add(frontCone);
                rocketGroup.add(exhaust);
                rocketGroup.add(grip);
                rocketGroup.add(shoulder);
                rocketGroup.add(sight);
                rocketGroup.add(muzzleFlash);
                
                // Set render order
                rocketGroup.traverse((child) => {
                    if (child.isMesh) child.renderOrder = 999;
                });
                muzzleFlash.renderOrder = 1000;
                
                // Store references (no magazine for rocket launcher)
                rocketGroup.userData.magazine = shoulder; // Use shoulder rest for reload animation
                rocketGroup.userData.muzzleFlash = muzzleFlash;
                
                this.weaponModels.rocket = rocketGroup;
                this.scene.add(rocketGroup);
                rocketGroup.visible = false;
            }

            createShotgunModel() {
                // Create Shotgun model
                const shotgunGroup = new THREE.Group();
                
                // Shotgun body (wider and shorter)
                const bodyGeometry = new THREE.BoxGeometry(0.15, 0.22, 0.6);
                const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x4a4a4a });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.set(0, 0, 0);
                
                // Double barrel
                const barrel1Geometry = new THREE.CylinderGeometry(0.035, 0.035, 0.5, 8);
                const barrel1Material = new THREE.MeshBasicMaterial({ color: 0x333333 });
                const barrel1 = new THREE.Mesh(barrel1Geometry, barrel1Material);
                barrel1.position.set(-0.04, 0.05, -0.4);
                barrel1.rotation.x = Math.PI / 2;
                
                const barrel2 = barrel1.clone();
                barrel2.position.set(0.04, 0.05, -0.4);
                
                // Shotgun stock
                const stockGeometry = new THREE.BoxGeometry(0.1, 0.15, 0.3);
                const stockMaterial = new THREE.MeshBasicMaterial({ color: 0x654321 });
                const stock = new THREE.Mesh(stockGeometry, stockMaterial);
                stock.position.set(0, -0.05, 0.35);
                
                // Shotgun grip
                const gripGeometry = new THREE.BoxGeometry(0.07, 0.14, 0.12);
                const gripMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
                const grip = new THREE.Mesh(gripGeometry, gripMaterial);
                grip.position.set(0, -0.14, 0.1);
                grip.rotation.z = -0.15;
                
                // Pump handle (used as magazine for reload animation)
                const pump = new THREE.Mesh(
                    new THREE.BoxGeometry(0.12, 0.08, 0.12),
                    new THREE.MeshBasicMaterial({ color: 0x777777 })
                );
                pump.position.set(0, -0.05, -0.2);
                
                // Muzzle flash (wider for shotgun)
                const flashGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const muzzleFlash = new THREE.Mesh(
                    flashGeometry,
                    new THREE.MeshBasicMaterial({ 
                        color: 0xffaa00, 
                        transparent: true, 
                        opacity: 0 
                    })
                );
                muzzleFlash.position.set(0, 0.05, -0.65);
                
                // Add all parts to shotgun group
                shotgunGroup.add(body);
                shotgunGroup.add(barrel1);
                shotgunGroup.add(barrel2);
                shotgunGroup.add(stock);
                shotgunGroup.add(grip);
                shotgunGroup.add(pump);
                shotgunGroup.add(muzzleFlash);
                
                // Set render order
                shotgunGroup.traverse((child) => {
                    if (child.isMesh) child.renderOrder = 999;
                });
                muzzleFlash.renderOrder = 1000;
                
                // Store references
                shotgunGroup.userData.magazine = pump; // Use pump as 'magazine' for animations
                shotgunGroup.userData.muzzleFlash = muzzleFlash;
                
                this.weaponModels.shotgun = shotgunGroup;
                this.scene.add(shotgunGroup);
                shotgunGroup.visible = false;
            }
            
            createSwordModel() {
                // Create Sword model
                const swordGroup = new THREE.Group();
                
                // Sword blade
                const bladeGeometry = new THREE.BoxGeometry(0.08, 0.02, 1.0);
                const bladeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xc0c0c0,
                    side: THREE.DoubleSide
                });
                const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                blade.position.set(0, 0, -0.5);
                
                // Sword edge (sharper look)
                const edgeGeometry = new THREE.BoxGeometry(0.04, 0.01, 1.0);
                const edgeMaterial = new THREE.MeshBasicMaterial({ color: 0xe0e0e0 });
                const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
                edge.position.set(0, 0, -0.5);
                
                // Sword hilt
                const hiltGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.2, 8);
                const hiltMaterial = new THREE.MeshBasicMaterial({ color: 0x8b4513 });
                const hilt = new THREE.Mesh(hiltGeometry, hiltMaterial);
                hilt.position.set(0, 0, 0.05);
                hilt.rotation.x = Math.PI / 2;
                
                // Sword guard
                const guardGeometry = new THREE.BoxGeometry(0.25, 0.03, 0.03);
                const guardMaterial = new THREE.MeshBasicMaterial({ color: 0x696969 });
                const guard = new THREE.Mesh(guardGeometry, guardMaterial);
                guard.position.set(0, 0, -0.05);
                
                // Sword pommel
                const pommelGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                const pommelMaterial = new THREE.MeshBasicMaterial({ color: 0x8b4513 });
                const pommel = new THREE.Mesh(pommelGeometry, pommelMaterial);
                pommel.position.set(0, 0, 0.15);
                
                // Add all parts to sword group
                swordGroup.add(blade);
                swordGroup.add(edge);
                swordGroup.add(hilt);
                swordGroup.add(guard);
                swordGroup.add(pommel);
                
                // Position sword for first-person view (moved forward)
                swordGroup.position.set(0.3, -0.2, -0.9);
                swordGroup.rotation.x = -0.1;
                swordGroup.rotation.y = -0.2;
                
                // Set render order
                swordGroup.traverse((child) => {
                    if (child.isMesh) child.renderOrder = 999;
                });
                
                // Store references (no magazine or muzzle flash for sword)
                swordGroup.userData.magazine = null;
                swordGroup.userData.muzzleFlash = null;
                
                this.weaponModels.sword = swordGroup;
                this.scene.add(swordGroup);
                swordGroup.visible = false;
            }

            switchWeapon(weaponType) {
                // Hide all weapons
                Object.values(this.weaponModels).forEach(model => {
                    model.visible = false;
                });
                
                // Show selected weapon
                this.currentWeapon = weaponType;
                this.weaponGroup = this.weaponModels[weaponType];
                this.weaponGroup.visible = true;
                
                // Update references for animation
                this.magazine = this.weaponGroup.userData.magazine;
                this.muzzleFlash = this.weaponGroup.userData.muzzleFlash;
                
                // Cancel reload if switching
                this.isReloading = false;
                this.hideReloadIndicator();
                
                // Store weapon offset
                this.weaponOffset = new THREE.Vector3(0.35, -0.25, -0.6);
                this.weaponRotationOffset = new THREE.Euler(0, -0.15, 0);
                
                this.updateAmmoDisplay();
                console.log('Switched to', weaponType, 'with', this.weapons[weaponType].currentAmmo, 'rounds');
            }

            update(deltaTime, inputManager) {
                // Update weapon position to follow camera
                const camera = this.camera;
                
                // Update sword swing animation if active
                if (this.isSwinging) {
                    const now = performance.now() / 1000;
                    this.swingProgress = Math.min((now - this.swingStartTime) / this.swingDuration, 1.0);
                    
                    if (this.swingProgress >= 1.0) {
                        this.isSwinging = false;
                        this.swingProgress = 0;
                        this.swingOffset = { rotation: { y: 0, z: 0 }, position: { x: 0, z: 0 } };
                    } else {
                        // Smooth swing animation using sine wave
                        const swing = Math.sin(this.swingProgress * Math.PI);
                        this.swingOffset.rotation.y = swing * 0.8;  // Horizontal sweep
                        this.swingOffset.rotation.z = -swing * 0.3; // Tilt
                        this.swingOffset.position.x = -swing * 0.4; // Move across
                        this.swingOffset.position.z = -swing * 0.3; // Thrust forward
                    }
                }
                
                // Calculate weapon world position based on camera
                const offset = this.weaponOffset.clone();
                offset.x += this.swingOffset.position.x;
                offset.z += this.swingOffset.position.z;
                offset.applyQuaternion(camera.quaternion);
                this.weaponGroup.position.copy(camera.position).add(offset);
                
                // Update weapon rotation to match camera with offset
                this.weaponGroup.rotation.copy(camera.rotation);
                this.weaponGroup.rotation.y += this.weaponRotationOffset.y + this.swingOffset.rotation.y;
                this.weaponGroup.rotation.z += this.swingOffset.rotation.z;
                
                // Update weapon sway based on mouse movement
                if (inputManager.isPointerLocked) {
                    const mouseDelta = inputManager.getMouseDelta();
                    this.weaponSway.x += mouseDelta.x * this.swayAmount;
                    this.weaponSway.y += mouseDelta.y * this.swayAmount;
                }
                
                // Smooth weapon sway
                this.weaponSway.x *= 0.95;
                this.weaponSway.y *= 0.95;
                
                // Smooth recoil
                this.recoil.x *= 0.92;
                this.recoil.y *= 0.92;
                
                // Update screen shake
                if (this.screenShake && this.screenShake.duration > 0) {
                    this.screenShake.duration -= deltaTime * 1000; // Convert to ms
                    
                    if (this.screenShake.duration > 0) {
                        // Apply shake offset
                        const shakeX = (Math.random() - 0.5) * this.screenShake.intensity;
                        const shakeY = (Math.random() - 0.5) * this.screenShake.intensity;
                        
                        // Temporarily offset camera rotation
                        this.camera.rotation.x += shakeY;
                        this.camera.rotation.z += shakeX;
                        
                        // Immediately reset on next frame (creates snap effect)
                        setTimeout(() => {
                            this.camera.rotation.x -= shakeY;
                            this.camera.rotation.z -= shakeX;
                        }, 16); // ~1 frame at 60fps
                    } else {
                        // Ensure camera is reset when shake ends
                        this.screenShake.intensity = 0;
                    }
                }
                
                // Apply sway and recoil to weapon
                this.weaponGroup.rotation.x += this.weaponSway.y + this.recoil.y;
                this.weaponGroup.rotation.y += this.weaponSway.x + this.recoil.x;
                
                // Update trigger state for semi-auto weapons
                if (!inputManager.isMousePressed()) {
                    this.triggerReleased = true;
                }
                
                // Handle reloading with animation
                if (this.isReloading) {
                    const weaponData = this.weapons[this.currentWeapon];
                    const reloadProgress = (performance.now() / 1000 - this.reloadStartTime) / weaponData.reloadTime;
                    
                    // Reload animation
                    if (reloadProgress < 0.3) {
                        // Drop magazine
                        const dropPhase = reloadProgress / 0.3;
                        this.magazine.position.y = -0.1 - dropPhase * 0.25;
                        this.weaponGroup.rotation.x += dropPhase * 0.2;
                    } else if (reloadProgress < 0.7) {
                        // Insert new magazine
                        const insertPhase = (reloadProgress - 0.3) / 0.4;
                        this.magazine.position.y = -0.35 + insertPhase * 0.25;
                        this.weaponGroup.rotation.x += 0.2 * (1 - insertPhase);
                    } else {
                        // Rack slide
                        const rackPhase = (reloadProgress - 0.7) / 0.3;
                        this.magazine.position.y = -0.1;
                        // Move weapon forward and back
                        const rackOffset = Math.sin(rackPhase * Math.PI) * 0.1;
                        this.weaponOffset.z = -0.6 + rackOffset;
                    }
                    
                    if (reloadProgress >= 1.0) {
                        this.finishReload();
                        // Reset magazine position
                        this.magazine.position.y = -0.1;
                        this.weaponOffset.z = -0.6;
                    }
                }
            }

            canShoot(isMousePressed) {
                const now = performance.now() / 1000;
                const weaponData = this.weapons[this.currentWeapon];
                
                // Calculate effective fire rate with BERSERK bonus
                let effectiveFireRate = weaponData.fireRate;
                if (this.berserkActive) {
                    if (this.currentWeapon === 'smg') {
                        effectiveFireRate *= 0.75; // 25% faster fire rate
                    } else if (this.currentWeapon === 'rocket') {
                        effectiveFireRate *= 0.5; // Double fire rate
                    }
                }
                
                // Sword doesn't need ammo checks
                if (weaponData.isMelee) {
                    if (this.isSwinging) return false;
                    if ((now - this.lastShotTime) < effectiveFireRate) return false;
                } else {
                    // Check basic conditions (Blood Thirst bypasses ammo check)
                    if (this.isReloading) return false;
                    if (!this.bloodThirstActive && weaponData.currentAmmo <= 0) return false;
                    if ((now - this.lastShotTime) < effectiveFireRate) return false;
                }
                
                // For non-automatic weapons, require trigger release between shots
                if (!weaponData.isAutomatic) {
                    if (!this.triggerReleased) return false;
                    if (isMousePressed) {
                        this.triggerReleased = false;
                    }
                }
                
                return true;
            }

            shoot(bulletPool, particleSystem, isMousePressed, enemies, player, gameManager, uiManager) {
                if (!this.canShoot(isMousePressed)) return [];

                const weaponData = this.weapons[this.currentWeapon];
                
                // Handle sword swing (melee attack)
                if (weaponData.isMelee) {
                    return this.performMeleeAttack(enemies, player, particleSystem, gameManager, uiManager);
                }
                // Don't decrement ammo during Blood Thirst (bottomless magazine)
                if (!this.bloodThirstActive) {
                    weaponData.currentAmmo--;  // Decrement the weapon's own ammo
                }
                this.lastShotTime = performance.now() / 1000;
                
                // Add recoil
                this.recoil.x += (Math.random() - 0.5) * weaponData.recoilAmount;
                this.recoil.y -= weaponData.recoilAmount;
                
                // Add screen shake
                if (weaponData.screenShake) {
                    this.addScreenShake(weaponData.screenShake);
                }
                
                // Muzzle flash effect
                if (this.muzzleFlash) {
                    this.muzzleFlash.material.opacity = 1;
                    setTimeout(() => {
                        if (this.muzzleFlash) this.muzzleFlash.material.opacity = 0;
                    }, 50);
                }
                
                // Get base shoot direction from camera
                const baseDirection = new THREE.Vector3(0, 0, -1);
                baseDirection.applyQuaternion(this.camera.quaternion);
                
                const bullets = [];
                const startPos = this.camera.position.clone();
                startPos.add(baseDirection.clone().multiplyScalar(0.5));
                
                // Modify shotgun pellets based on perks
                let projectileCount = weaponData.projectileCount;
                if (weaponData.isShotgun) {
                    if (this.berserkActive && this.bloodThirstActive) {
                        projectileCount = 36; // BERSERK + Blood Thirst: 6 * 2 * 3 = 36
                    } else if (this.berserkActive) {
                        projectileCount = 18; // BERSERK only: 6 * 3 = 18
                    } else if (this.bloodThirstActive) {
                        projectileCount = 12; // Blood Thirst only: 6 * 2 = 12
                    }
                }
                
                // Fire multiple projectiles for shotgun or single for others
                for (let i = 0; i < projectileCount; i++) {
                    const bullet = bulletPool.get();
                    
                    // Apply spread
                    const direction = baseDirection.clone();
                    if (weaponData.spread > 0) {
                        direction.x += (Math.random() - 0.5) * weaponData.spread;
                        direction.y += (Math.random() - 0.5) * weaponData.spread;
                        direction.normalize();
                    }
                    
                    // Configure bullet properties (apply Blood Thirst multiplier)
                    const damageMultiplier = this.player && this.player.getDamageMultiplier ? 
                        this.player.getDamageMultiplier() : 1.0;
                    bullet.damage = weaponData.damage * damageMultiplier;
                    
                    // Special properties for rockets
                    if (weaponData.isRocket) {
                        bullet.isRocket = true;
                        // Increase blast radius by 2.5x during Hellfire (doubles base + 25%)
                        bullet.blastRadius = this.hellfireActive ? weaponData.blastRadius * 2.5 : weaponData.blastRadius;
                        bullet.speed = weaponData.projectileSpeed;
                        bullet.isHellfireRocket = this.hellfireActive; // Mark Hellfire rockets
                    } else {
                        // Hellfire makes all bullets explosive
                        if (this.hellfireActive) {
                            bullet.isRocket = true; // Make bullet explosive
                            bullet.blastRadius = 2; // 25% of rocket's normal 8 radius
                            bullet.isHellfireBullet = true; // Mark for smaller particle effect
                            bullet.speed = 100; // Keep normal bullet speed
                            // Increase damage by 25% for Hellfire bullets
                            bullet.damage = bullet.damage * 1.25;
                        } else {
                            // Reset to normal bullet properties
                            bullet.isRocket = false;
                            bullet.isHellfireBullet = false;
                            bullet.isHellfireRocket = false;
                            bullet.speed = 100; // Default bullet speed
                        }
                    }
                    
                    // Set weapon type on bullet for dismemberment checks
                    bullet.weapon = this.currentWeapon;
                    
                    bullet.fire(startPos, direction);
                    bullets.push(bullet);
                }
                
                // Create muzzle flash - Disabled
                // const muzzlePos = startPos.clone().add(baseDirection.clone().multiplyScalar(0.3));
                // particleSystem.createMuzzleFlash(muzzlePos, baseDirection);
                
                // Play appropriate sound
                this.audioManager.play(weaponData.soundName);
                
                // Layer Blood Thirst shot sound when perk is active
                if (this.bloodThirstActive) {
                    this.audioManager.play('bloodthirstyShot');
                }
                
                // Layer BERSERK shot sound when perk is active
                if (this.berserkActive) {
                    this.audioManager.play('berserkShot');
                }
                
                // Layer Hellfire shot sound when perk is active
                if (this.hellfireActive) {
                    this.audioManager.play('hellfireShot');
                }
                
                this.updateAmmoDisplay();
                return bullets;
            }

            startReload() {
                const weaponData = this.weapons[this.currentWeapon];
                if (this.isReloading || weaponData.currentAmmo >= weaponData.maxAmmo || this.reserveAmmo <= 0) {
                    return false;
                }
                
                this.isReloading = true;
                this.reloadStartTime = performance.now() / 1000;
                this.audioManager.play('reload');
                this.showReloadIndicator();
                return true;
            }

            finishReload() {
                const weaponData = this.weapons[this.currentWeapon];
                const needed = weaponData.maxAmmo - weaponData.currentAmmo;
                const toReload = Math.min(needed, this.reserveAmmo);
                
                weaponData.currentAmmo += toReload;
                this.reserveAmmo -= toReload;
                this.isReloading = false;
                
                this.updateAmmoDisplay();
                this.hideReloadIndicator();
            }

            addAmmo(amount) {
                this.reserveAmmo = Math.min(this.reserveAmmo + amount, this.maxReserve);
                this.updateAmmoDisplay();
            }
            
            addScreenShake(intensity) {
                if (!this.screenShake) {
                    this.screenShake = { x: 0, y: 0, intensity: 0, duration: 0 };
                }
                // Set shake intensity and duration (quick snap)
                this.screenShake.intensity = intensity;
                this.screenShake.duration = 50; // 50ms duration for quick snap effect
            }

            activateBloodThirst() {
                this.bloodThirstActive = true;
                
                // Instantly fill all weapon magazines
                for (let weaponName in this.weapons) {
                    this.weapons[weaponName].currentAmmo = this.weapons[weaponName].maxAmmo;
                }
                
                // Update display
                this.updateAmmoDisplay();
            }
            
            deactivateBloodThirst() {
                this.bloodThirstActive = false;
                this.updateAmmoDisplay();
            }
            
            activateHellfire() {
                this.hellfireActive = true;
            }
            
            deactivateHellfire() {
                this.hellfireActive = false;
            }
            
            activateBerserk() {
                this.berserkActive = true;
            }
            
            deactivateBerserk() {
                this.berserkActive = false;
            }
            
            performMeleeAttack(enemies, player, particleSystem, gameManager, uiManager) {
                const weaponData = this.weapons[this.currentWeapon];
                this.lastShotTime = performance.now() / 1000;
                
                // Start swing animation
                this.isSwinging = true;
                this.swingStartTime = performance.now() / 1000;
                this.swingProgress = 0;
                
                // Play swing sound
                this.audioManager.play('swordSwing');
                
                // Check for hits
                const hitEnemies = [];
                let enemiesKilledCount = 0; // Just count how many we killed
                const playerPos = this.camera.position;
                const lookDirection = new THREE.Vector3(0, 0, -1);
                lookDirection.applyQuaternion(this.camera.quaternion);
                
                // Check each enemy for melee hit
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (!enemy || !enemy.active) continue;
                    
                    const distance = playerPos.distanceTo(enemy.position);
                    
                    // Check if enemy is in range
                    if (distance <= weaponData.meleeRange) {
                        // Check if enemy is in front of player (within swing arc)
                        const toEnemy = enemy.position.clone().sub(playerPos).normalize();
                        const angle = Math.acos(lookDirection.dot(toEnemy)) * (180 / Math.PI);
                        
                        if (angle <= weaponData.swingAngle / 2) {
                            // Hit detected!
                            hitEnemies.push(enemy);
                            
                            // Get hit position for effects
                            const hitPosition = enemy.position.clone();
                            hitPosition.y += enemy.size * 0.5; // Hit at mid-height
                            
                            // Play all hit sounds
                            this.audioManager.play('swordHit1');
                            this.audioManager.play('swordHit2');
                            this.audioManager.play('enemyHit');
                            
                            // Create blood particle effect
                            if (particleSystem) {
                                particleSystem.createExplosion(hitPosition, 0xff4444, 15);
                            }
                            
                            // 10% chance to play grunt sound
                            if (Math.random() < 0.1) {
                                this.audioManager.play('enemyGrunt');
                            }
                            
                            // Apply damage with Blood Thirst multiplier
                            const damageMultiplier = player && player.getDamageMultiplier ? 
                                player.getDamageMultiplier() : 1.0;
                            const damage = weaponData.damage * damageMultiplier;
                            
                            const killed = enemy.takeDamage(damage);
                            
                            if (killed) {
                                // Enemy killed - play death sound
                                this.audioManager.play('enemyDie');
                                
                                // 1/6 chance to play death grunt
                                if (Math.random() < 1/6) {
                                    this.audioManager.play('enemyDeathGrunt');
                                }
                                
                                // Check for dismemberment (high damage melee kills)
                                if (damage >= 100 && particleSystem) {
                                    // Dismember on high damage sword kills
                                    try {
                                        const enemyPos = enemy.position ? enemy.position.clone() : new THREE.Vector3();
                                        const playerPos = player.position ? player.position.clone() : new THREE.Vector3();
                                        const forceDirection = enemyPos.sub(playerPos).normalize();
                                        particleSystem.createDismemberment(enemy.position, 'melee', forceDirection);
                                    } catch (error) {
                                        console.warn('Dismemberment error in melee kill:', error);
                                    }
                                }
                                
                                // Add score and kills
                                if (gameManager) {
                                    gameManager.addScore(enemy.scoreValue);
                                    gameManager.addKill();
                                }
                                
                                // Register kill for perks
                                if (player) {
                                    if (player.registerKill) {
                                        player.registerKill(); // For Blood Thirst and Hellfire
                                    }
                                    if (player.registerSwordKill) {
                                        player.registerSwordKill(); // For Adrenaline
                                    }
                                }
                                
                                // Update UI
                                if (uiManager) {
                                    uiManager.addKillMessage(`Enemy eliminated +${enemy.scoreValue}`);
                                }
                                
                                // Random pickup chance
                                if (Math.random() < 0.3) {
                                    const pickupType = Math.random() < 0.5 ? 'health' : 'ammo';
                                    // Note: Need spawnPickup function passed in or accessible
                                    if (this.spawnPickup) {
                                        this.spawnPickup(pickupType, enemy.position.clone());
                                    }
                                }
                                
                                // Increment killed count
                                enemiesKilledCount++;
                                
                                // The main game loop will remove dead enemies
                            }
                        }
                    }
                }
                
                // The main game loop will handle updating enemy count when it removes dead enemies
                
                // Add screen shake if we hit something
                if (hitEnemies.length > 0 && weaponData.screenShake) {
                    this.addScreenShake(weaponData.screenShake);
                }
                
                return []; // No bullets for melee
            }
            
            updateAmmoDisplay() {
                const weaponData = this.weapons[this.currentWeapon];
                
                // Handle sword (no ammo display)
                if (weaponData.isMelee) {
                    document.getElementById('currentAmmo').textContent = '-';
                    document.getElementById('reserveAmmo').textContent = '-';
                } else if (this.bloodThirstActive) {
                    // Show infinity symbol during Blood Thirst
                    document.getElementById('currentAmmo').textContent = '';
                    document.getElementById('reserveAmmo').textContent = '';
                } else {
                    document.getElementById('currentAmmo').textContent = weaponData.currentAmmo;
                    document.getElementById('reserveAmmo').textContent = this.reserveAmmo;
                }
                
                // Update weapon name
                const weaponNames = {
                    'smg': 'SMG',
                    'shotgun': 'SHOTGUN',
                    'rocket': 'ROCKET',
                    'sword': 'SWORD'
                };
                document.getElementById('weaponName').textContent = weaponNames[this.currentWeapon] || 'WEAPON';
                
                // Color code based on ammo level
                const ammoElement = document.getElementById('currentAmmo');
                const ammoPercent = weaponData.currentAmmo / weaponData.maxAmmo;
                
                if (ammoPercent === 0) {
                    ammoElement.style.color = '#ff0000';
                } else if (ammoPercent <= 0.33) {
                    ammoElement.style.color = '#ffaa00';
                } else {
                    ammoElement.style.color = '#00ff00';
                }
            }

            showReloadIndicator() {
                document.getElementById('reloadIndicator').style.display = 'block';
            }

            hideReloadIndicator() {
                document.getElementById('reloadIndicator').style.display = 'none';
            }
        }

        // Input handling system
        class InputManager {
            constructor() {
                this.keys = {};
                this.mouse = { x: 0, y: 0, deltaX: 0, deltaY: 0, leftButton: false };
                this.isPointerLocked = false;
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // Keyboard events
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // Mouse events
                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        this.mouse.deltaX = e.movementX || 0;
                        this.mouse.deltaY = e.movementY || 0;
                    }
                });

                document.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        this.mouse.leftButton = true;
                    }
                });

                document.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        this.mouse.leftButton = false;
                    }
                });
                
                // Pointer lock events
                document.addEventListener('click', (e) => {
                    if (!this.isPointerLocked) {
                        this.requestPointerLock();
                    }
                });
                
                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === document.body;
                });

                // Prevent context menu
                document.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            }
            
            requestPointerLock() {
                document.body.requestPointerLock();
            }
            
            releasePointerLock() {
                document.exitPointerLock();
            }
            
            isKeyPressed(keyCode) {
                return !!this.keys[keyCode];
            }

            isMousePressed() {
                return this.mouse.leftButton;
            }
            
            getMouseDelta() {
                const delta = { x: this.mouse.deltaX, y: this.mouse.deltaY };
                this.mouse.deltaX = 0;
                this.mouse.deltaY = 0;
                return delta;
            }
        }

        // Player class with FPS movement and combat
        class Player {
            constructor(camera, scene, audioManager) {
                this.camera = camera;
                this.scene = scene;
                this.audioManager = audioManager;
                
                // Movement properties
                this.velocity = new THREE.Vector3();
                this.position = new THREE.Vector3(0, 2, 0);
                this.rotation = { x: 0, y: 0 };
                
                // Physics constants
                this.speed = 8;
                this.sprintMultiplier = 1.8;
                this.jumpForce = 8;
                this.gravity = -25;
                this.friction = 0.85;
                this.airFriction = 0.95;
                this.mouseSensitivity = 0.002;
                
                // Combat properties
                this.maxHealth = 100;
                this.health = this.maxHealth;
                this.healthRegenRate = 5; // HP per second
                this.healthRegenDelay = 3; // seconds after taking damage
                this.lastDamageTime = 0;
                
                // Blood Thirst perk system
                this.killTimes = []; // Track kill timestamps
                this.bloodThirstActive = false;
                this.bloodThirstEndTime = 0;
                this.bloodThirstDuration = 10; // seconds
                this.bloodThirstKillsRequired = 4; // kills needed in rapid succession
                this.bloodThirstTimeWindow = 5; // seconds to get 4 kills
                
                // Hellfire perk system
                this.hellfireActive = false;
                this.hellfireEndTime = 0;
                this.hellfireDuration = 5; // seconds
                this.hellfireKillsRequired = 10; // kills needed in rapid succession
                this.hellfireTimeWindow = 10; // seconds to get 10 kills
                
                // Adrenaline perk system
                this.adrenalineActive = false;
                this.adrenalineStacks = 0;
                this.adrenalineEndTime = 0;
                this.adrenalineDuration = 5; // seconds per stack
                this.adrenalineKillsRequired = 3; // sword kills needed in rapid succession
                this.adrenalineTimeWindow = 3; // seconds to get 3 sword kills
                this.swordKillTimes = []; // Track sword kill timestamps
                this.baseSpeed = 7.5; // Store base speed
                this.maxAdrenalineStacks = 3;
                
                // BERSERK perk system
                this.berserkActive = false;
                this.berserkEndTime = 0;
                this.berserkDuration = 10; // seconds
                this.berserkKillsRequired = 15; // kills needed in a combo
                this.comboKillCount = 0; // Current combo count
                this.lastKillTime = 0;
                this.comboTimeWindow = 5; // seconds between kills to maintain combo
                
                // SLOWMO perk system
                this.slowmoActive = false;
                this.slowmoEndTime = 0;
                this.slowmoDuration = 5; // seconds
                this.slowmoHeadshotsRequired = 3; // headshots needed in rapid succession
                this.headshotTimes = []; // Track headshot timestamps
                this.headshotTimeWindow = 3; // seconds to get 3 headshots
                this.timeScale = 1.0; // Normal time scale
                
                // State
                this.isGrounded = false;
                this.canJump = true;
                this.height = 1.8;
                this.standingHeight = 1.8;
                this.crouchHeight = 0.9;
                this.isMoving = false;
                this.lastFootstepTime = 0;
                this.footstepInterval = 0.5; // seconds
                
                // Crouch and slide mechanics
                this.isCrouching = false;
                this.isSliding = false;
                this.slideVelocity = new THREE.Vector3();
                this.slideSpeed = 15; // Base slide speed
                this.slideFriction = 0.98; // Initial friction (very low)
                this.slideTimer = 0; // Track slide duration
                this.slideMinSpeed = 2; // Minimum speed to maintain slide
                this.wasInAir = false; // Track if player was in air last frame
                this.isSprinting = false; // Track sprint state
                
                // Momentum system
                this.momentumMultiplier = 1.0; // Current momentum multiplier
                this.slideChainCount = 0; // Number of successful slide chains
                this.lastSlideEndTime = 0; // Time when last slide ended
                this.slideHopWindow = 0.3; // Window for perfect slide-hop (seconds)
                this.inFlowState = false; // Flow state from chaining
                this.currentSpeed = 0; // Track current movement speed
                this.maxSpeed = 30; // Maximum possible speed
                
                // FOV for speed effects
                this.baseFOV = 75;
                this.currentFOV = 75;
                this.targetFOV = 75;
                
                this.setupCamera();
                this.updateHealthDisplay();
            }
            
            setupCamera() {
                this.camera.position.copy(this.position);
                this.camera.rotation.order = 'YXZ';
            }
            
            update(deltaTime, inputManager, collisionObjects) {
                // Track air state before collision updates
                this.wasInAir = !this.isGrounded;
                
                this.handleMouseLook(inputManager);
                this.handleMovement(deltaTime, inputManager);
                this.handlePhysics(deltaTime);
                this.handleCollisions(collisionObjects);
                this.handleHealthRegen(deltaTime);
                this.updateCamera();
                this.handleFootsteps(deltaTime);
            }
            
            handleMouseLook(inputManager) {
                if (!inputManager.isPointerLocked) return;
                
                const mouseDelta = inputManager.getMouseDelta();
                
                this.rotation.y -= mouseDelta.x * this.mouseSensitivity;
                this.rotation.x -= mouseDelta.y * this.mouseSensitivity;
                
                // Clamp vertical rotation
                this.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.rotation.x));
            }
            
            handleMovement(deltaTime, inputManager) {
                if (!inputManager.isPointerLocked) return;
                
                // Track previous states
                const wasCrouching = this.isCrouching;
                const wasGrounded = this.isGrounded;
                const wasSprinting = this.isSprinting;
                
                // Update current states
                this.isCrouching = inputManager.isKeyPressed('KeyC');
                this.isSprinting = inputManager.isKeyPressed('ShiftLeft') && !this.isCrouching;
                
                // Update camera height for crouch
                if (this.isCrouching && !wasCrouching) {
                    // Start crouching - lower camera smoothly
                    this.height = this.crouchHeight;
                } else if (!this.isCrouching && wasCrouching && !this.isSliding) {
                    // Stop crouching - raise camera (unless sliding)
                    this.height = this.standingHeight;
                }
                
                // Calculate current speed for momentum tracking
                this.currentSpeed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.z * this.velocity.z);
                
                // Check for slide initiation
                const justLanded = this.wasInAir && this.isGrounded;
                const landingWithCrouch = justLanded && this.isCrouching;
                const sprintToCrouch = wasSprinting && !wasCrouching && this.isCrouching && this.isGrounded;
                const walkToCrouch = !wasSprinting && !wasCrouching && this.isCrouching && this.isGrounded && this.isMoving;
                
                if ((landingWithCrouch || sprintToCrouch || walkToCrouch) && !this.isSliding) {
                    // Initiate slide with momentum-based speed
                    this.isSliding = true;
                    this.slideTimer = 0;
                    
                    // Calculate speed multiplier based on entry type
                    let speedMultiplier = 1.0;
                    if (landingWithCrouch) {
                        speedMultiplier = 1.8; // Air  Slide bonus
                    } else if (sprintToCrouch) {
                        speedMultiplier = 1.5; // Sprint  Slide bonus
                    } else if (walkToCrouch) {
                        speedMultiplier = 1.3; // Walk  Slide bonus
                    }
                    
                    // Apply chain bonus if within hop window
                    const timeSinceLastSlide = performance.now() / 1000 - this.lastSlideEndTime;
                    if (timeSinceLastSlide < this.slideHopWindow) {
                        this.slideChainCount++;
                        if (this.slideChainCount >= 3) {
                            this.inFlowState = true;
                            speedMultiplier *= 1.2; // Flow state bonus
                        } else {
                            speedMultiplier *= 1.1; // Chain bonus
                        }
                    } else {
                        this.slideChainCount = 0;
                        this.inFlowState = false;
                    }
                    
                    // Set slide velocity with momentum
                    const velocityMagnitude = this.currentSpeed;
                    if (velocityMagnitude > 1) {
                        // Use current velocity direction
                        this.slideVelocity.set(this.velocity.x, 0, this.velocity.z);
                        this.slideVelocity.normalize().multiplyScalar(Math.max(this.slideSpeed, velocityMagnitude) * speedMultiplier);
                    } else {
                        // Use camera forward if not moving
                        const forward = new THREE.Vector3();
                        forward.x = Math.sin(this.rotation.y);
                        forward.z = Math.cos(this.rotation.y);
                        forward.normalize();
                        this.slideVelocity.copy(forward).multiplyScalar(this.slideSpeed * speedMultiplier);
                    }
                    
                    // Cap at max speed
                    if (this.slideVelocity.length() > this.maxSpeed) {
                        this.slideVelocity.normalize().multiplyScalar(this.maxSpeed);
                    }
                    
                    // Play slide sound
                    this.audioManager.play('slide_ground');
                    
                    // Update FOV for speed effect
                    const speedRatio = this.slideVelocity.length() / this.maxSpeed;
                    this.targetFOV = this.baseFOV + (15 * speedRatio); // Up to +15 FOV at max speed
                }
                
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                
                // Calculate movement directions based on Y rotation only
                forward.x = Math.sin(this.rotation.y);
                forward.z = Math.cos(this.rotation.y);
                forward.normalize();
                
                right.x = Math.cos(this.rotation.y);
                right.z = -Math.sin(this.rotation.y);
                right.normalize();
                
                // Handle slide physics
                if (this.isSliding) {
                    this.slideTimer += deltaTime;
                    
                    // Dynamic friction based on slide duration
                    let currentFriction;
                    if (this.slideTimer < 0.5) {
                        currentFriction = 0.98; // Almost no friction initially
                    } else if (this.slideTimer < 1.0) {
                        currentFriction = 0.95; // Gentle slowdown
                    } else {
                        currentFriction = 0.90; // Noticeable but not harsh
                    }
                    
                    // Apply friction
                    this.slideVelocity.multiplyScalar(currentFriction);
                    
                    // Check for slide end conditions
                    const shouldEndSlide = (this.slideVelocity.length() < this.slideMinSpeed && this.slideTimer > 0.5) || 
                                          !this.isCrouching || 
                                          (!this.isGrounded && !inputManager.isKeyPressed('Space'));
                    
                    if (shouldEndSlide) {
                        // End slide
                        this.isSliding = false;
                        this.lastSlideEndTime = performance.now() / 1000;
                        
                        // Preserve momentum on crouch release
                        if (!this.isCrouching) {
                            this.height = this.standingHeight;
                            // Transfer some slide velocity to normal movement
                            this.velocity.x = this.slideVelocity.x * 0.5;
                            this.velocity.z = this.slideVelocity.z * 0.5;
                        }
                        
                        this.slideVelocity.set(0, 0, 0);
                        this.targetFOV = this.baseFOV;
                    } else {
                        // Apply slide velocity
                        this.velocity.x = this.slideVelocity.x;
                        this.velocity.z = this.slideVelocity.z;
                        
                        // Allow slight directional control based on speed
                        const slideControlFactor = 0.1 + (0.1 * (this.slideVelocity.length() / this.maxSpeed)); // More control at higher speeds
                        const moveVector = new THREE.Vector3();
                        
                        if (inputManager.isKeyPressed('KeyW')) moveVector.sub(forward);
                        if (inputManager.isKeyPressed('KeyS')) moveVector.add(forward);
                        if (inputManager.isKeyPressed('KeyA')) moveVector.sub(right);
                        if (inputManager.isKeyPressed('KeyD')) moveVector.add(right);
                        
                        if (moveVector.length() > 0) {
                            moveVector.normalize();
                            this.slideVelocity.add(moveVector.multiplyScalar(slideControlFactor));
                        }
                    }
                    
                    this.isMoving = this.slideVelocity.length() > 0;
                } else {
                    // Normal movement when not sliding
                    const moveVector = new THREE.Vector3();
                    this.isMoving = false;
                    
                    // Movement input
                    if (inputManager.isKeyPressed('KeyW')) {
                        moveVector.sub(forward);
                        this.isMoving = true;
                    }
                    if (inputManager.isKeyPressed('KeyS')) {
                        moveVector.add(forward);
                        this.isMoving = true;
                    }
                    if (inputManager.isKeyPressed('KeyA')) {
                        moveVector.sub(right);
                        this.isMoving = true;
                    }
                    if (inputManager.isKeyPressed('KeyD')) {
                        moveVector.add(right);
                        this.isMoving = true;
                    }
                    
                    // Normalize diagonal movement
                    if (moveVector.length() > 0) {
                        moveVector.normalize();
                        
                        // Apply sprint multiplier and perk boosts
                        let currentSpeed = this.speed;
                        
                        // Apply Adrenaline speed boost (10% per stack)
                        if (this.adrenalineActive) {
                            currentSpeed = this.baseSpeed * (1 + 0.1 * this.adrenalineStacks);
                        }
                        
                        // Apply BERSERK speed boost (15% increase)
                        if (this.berserkActive) {
                            currentSpeed *= 1.15;
                        }
                        
                        if (this.isSprinting) {
                            currentSpeed *= this.sprintMultiplier;
                        } else if (this.isCrouching) {
                            currentSpeed *= 0.4; // Slower movement when crouched
                        }
                        
                        // Apply movement to velocity
                        const acceleration = moveVector.multiplyScalar(currentSpeed * deltaTime * 10);
                        this.velocity.x += acceleration.x;
                        this.velocity.z += acceleration.z;
                    }
                }
                
                // Jumping - special handling for slide-hop
                if (inputManager.isKeyPressed('Space') && this.isGrounded && this.canJump) {
                    // Play jump sound
                    this.audioManager.play('player_jump');
                    
                    if (this.isSliding) {
                        // Slide-hop mechanics
                        const slideProgress = this.slideTimer / 1.5; // Assume 1.5s is full slide
                        let momentumPreservation = 0.5; // Default preservation
                        
                        if (slideProgress >= 0.8) {
                            momentumPreservation = 0.9; // Perfect timing
                        } else if (slideProgress >= 0.6) {
                            momentumPreservation = 0.7; // Good timing
                        }
                        
                        // End slide but preserve momentum
                        this.velocity.x = this.slideVelocity.x * momentumPreservation;
                        this.velocity.z = this.slideVelocity.z * momentumPreservation;
                        this.velocity.y = this.jumpForce;
                        
                        this.isSliding = false;
                        this.slideVelocity.set(0, 0, 0);
                        this.lastSlideEndTime = performance.now() / 1000;
                        this.isGrounded = false;
                        this.canJump = false;
                        
                        // Stand up from slide
                        this.isCrouching = false;
                        this.height = this.standingHeight;
                        
                        // Maintain higher FOV briefly
                        this.targetFOV = this.baseFOV + 5;
                    } else {
                        // Normal jump
                        this.velocity.y = this.jumpForce;
                        this.isGrounded = false;
                        this.canJump = false;
                        
                        // If jumping while crouched, stand up
                        if (this.isCrouching) {
                            this.isCrouching = false;
                            this.height = this.standingHeight;
                        }
                    }
                }
                
                if (!inputManager.isKeyPressed('Space')) {
                    this.canJump = true;
                }
            }

            handleFootsteps(deltaTime) {
                // No footsteps while sliding or in air
                if (!this.isMoving || !this.isGrounded || this.isSliding) {
                    return;
                }
                
                // Adjust footstep interval based on movement state
                let currentInterval = 0.5; // Base interval (half second)
                
                if (this.isSprinting) {
                    currentInterval = 0.35; // Faster footsteps while sprinting
                } else if (this.isCrouching) {
                    currentInterval = 0.7; // Slower footsteps while crouched
                }
                
                const now = performance.now() / 1000;
                if (now - this.lastFootstepTime >= currentInterval) {
                    // Randomly select one of the three footstep sounds
                    const footstepNumber = Math.floor(Math.random() * 3) + 1;
                    const footstepSound = `player_footstep${footstepNumber}`;
                    
                    // Play the selected footstep sound
                    this.audioManager.play(footstepSound);
                    this.lastFootstepTime = now;
                }
            }
            
            handlePhysics(deltaTime) {
                // Apply gravity
                this.velocity.y += this.gravity * deltaTime;
                
                // Apply friction (unless sliding)
                if (!this.isSliding) {
                    if (this.isGrounded) {
                        this.velocity.x *= Math.pow(this.friction, deltaTime * 60);
                        this.velocity.z *= Math.pow(this.friction, deltaTime * 60);
                    } else {
                        this.velocity.x *= Math.pow(this.airFriction, deltaTime * 60);
                        this.velocity.z *= Math.pow(this.airFriction, deltaTime * 60);
                    }
                }
                
                // Update position
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
            }
            
            handleCollisions(collisionObjects) {
                // Track if we just landed
                const wasAirborne = this.wasInAir;
                
                // Ground collision
                if (this.position.y <= this.height) {
                    this.position.y = this.height;
                    if (this.velocity.y < 0) {
                        this.velocity.y = 0;
                        
                        // Check if we just landed
                        if (!this.isGrounded && wasAirborne) {
                            // Play landing sound
                            this.audioManager.play('player_land');
                        }
                        
                        this.isGrounded = true;
                    }
                } else {
                    this.isGrounded = false;
                }
                
                // Wall collisions (simple AABB)
                const playerRadius = 0.5;
                
                for (let obj of collisionObjects) {
                    const box = new THREE.Box3().setFromObject(obj);
                    
                    // Expand box by player radius
                    box.expandByScalar(playerRadius);
                    
                    if (box.containsPoint(this.position)) {
                        // Find closest point on the box to push player out
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        
                        const dx = this.position.x - center.x;
                        const dz = this.position.z - center.z;
                        
                        // Push out in the direction of least penetration
                        if (Math.abs(dx / size.x) > Math.abs(dz / size.z)) {
                            // Push out in X direction
                            this.position.x = center.x + Math.sign(dx) * (size.x / 2);
                            this.velocity.x = 0;
                        } else {
                            // Push out in Z direction
                            this.position.z = center.z + Math.sign(dz) * (size.z / 2);
                            this.velocity.z = 0;
                        }
                    }
                }
            }

            handleHealthRegen(deltaTime) {
                const now = performance.now() / 1000;
                if (this.health < this.maxHealth && 
                    (now - this.lastDamageTime) >= this.healthRegenDelay) {
                    this.health = Math.min(this.health + this.healthRegenRate * deltaTime, this.maxHealth);
                    this.updateHealthDisplay();
                }
            }

            takeDamage(damage) {
                // Invulnerable during BERSERK
                if (this.berserkActive) {
                    return false; // No damage taken
                }
                
                this.health = Math.max(0, this.health - damage);
                this.lastDamageTime = performance.now() / 1000;
                this.updateHealthDisplay();
                this.showDamageFlash();
                this.audioManager.play('playerHit');
                return this.health <= 0;
            }

            heal(amount) {
                this.health = Math.min(this.health + amount, this.maxHealth);
                this.updateHealthDisplay();
            }

            updateHealthDisplay() {
                const healthPercent = (this.health / this.maxHealth) * 100;
                document.getElementById('healthBar').style.width = healthPercent + '%';
                document.getElementById('healthText').textContent = Math.ceil(this.health);
            }

            showDamageFlash() {
                const flash = document.getElementById('damageFlash');
                flash.style.opacity = '1';
                setTimeout(() => {
                    flash.style.opacity = '0';
                }, 200);
            }
            
            updateCamera() {
                this.camera.position.copy(this.position);
                this.camera.rotation.x = this.rotation.x;
                this.camera.rotation.y = this.rotation.y;
                
                // Smooth FOV transitions for speed effects
                if (Math.abs(this.currentFOV - this.targetFOV) > 0.1) {
                    this.currentFOV += (this.targetFOV - this.currentFOV) * 0.1;
                    this.camera.fov = this.currentFOV;
                    this.camera.updateProjectionMatrix();
                }
                
                // Add slight camera tilt during slide
                if (this.isSliding) {
                    const tiltAmount = (this.slideVelocity.length() / this.maxSpeed) * 0.1; // Up to 0.1 radians tilt
                    this.camera.rotation.z = Math.sin(performance.now() * 0.003) * tiltAmount;
                } else {
                    // Smooth return to normal
                    this.camera.rotation.z *= 0.9;
                }
            }

            getPosition() {
                return this.position.clone();
            }

            isDead() {
                return this.health <= 0;
            }
            
            registerKill() {
                const now = performance.now() / 1000;
                
                // Add kill to tracking
                this.killTimes.push(now);
                
                // Update combo kill count for BERSERK
                if (now - this.lastKillTime <= this.comboTimeWindow) {
                    this.comboKillCount++;
                } else {
                    this.comboKillCount = 1; // Reset combo if too much time passed
                }
                this.lastKillTime = now;
                
                // Check for BERSERK (15 kill combo)
                if (this.comboKillCount >= this.berserkKillsRequired && !this.berserkActive) {
                    this.activateBerserk();
                    this.comboKillCount = 0; // Reset combo after activation
                }
                
                // Check for Blood Thirst (4 kills in 5 seconds)
                const recentKillsForBloodThirst = this.killTimes.filter(time => now - time <= this.bloodThirstTimeWindow);
                if (recentKillsForBloodThirst.length >= this.bloodThirstKillsRequired && !this.bloodThirstActive) {
                    this.activateBloodThirst();
                }
                
                // Check for Hellfire (10 kills in 10 seconds)
                const recentKillsForHellfire = this.killTimes.filter(time => now - time <= this.hellfireTimeWindow);
                if (recentKillsForHellfire.length >= this.hellfireKillsRequired && !this.hellfireActive) {
                    this.activateHellfire();
                }
                
                // Clean up old kills beyond either time window
                const maxWindow = Math.max(this.bloodThirstTimeWindow, this.hellfireTimeWindow);
                this.killTimes = this.killTimes.filter(time => now - time <= maxWindow);
            }
            
            activateBloodThirst() {
                this.bloodThirstActive = true;
                this.bloodThirstEndTime = performance.now() / 1000 + this.bloodThirstDuration;
                
                // Play activation sound
                if (this.audioManager) {
                    this.audioManager.play('perkBloodthirsty');
                }
                
                // Show on-screen notification
                this.showBloodThirstNotification();
                
                // Instant reload all weapons (will be handled in weapon system)
                if (this.weaponSystem) {
                    this.weaponSystem.activateBloodThirst();
                }
            }
            
            updateBloodThirst(deltaTime) {
                if (this.bloodThirstActive) {
                    const now = performance.now() / 1000;
                    if (now >= this.bloodThirstEndTime) {
                        this.deactivateBloodThirst();
                    } else {
                        // Update UI with remaining time
                        const remaining = this.bloodThirstEndTime - now;
                        this.updateBloodThirstDisplay(remaining);
                    }
                }
            }
            
            deactivateBloodThirst() {
                this.bloodThirstActive = false;
                
                // Notify weapon system
                if (this.weaponSystem) {
                    this.weaponSystem.deactivateBloodThirst();
                }
                
                // Hide UI
                this.hideBloodThirstDisplay();
            }
            
            showBloodThirstNotification() {
                // Create or show Blood Thirst UI element
                let bloodThirstUI = document.getElementById('bloodThirstUI');
                if (!bloodThirstUI) {
                    bloodThirstUI = document.createElement('div');
                    bloodThirstUI.id = 'bloodThirstUI';
                    bloodThirstUI.style.cssText = `
                        position: fixed;
                        top: 80px;
                        left: 50%;
                        transform: translateX(-50%);
                        color: #ff0000;
                        font-size: 24px;
                        font-weight: bold;
                        text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 20px rgba(255,0,0,0.5);
                        z-index: 1000;
                        pointer-events: none;
                        animation: pulse 0.5s ease-in-out infinite alternate;
                    `;
                    document.body.appendChild(bloodThirstUI);
                    
                    // Add animation if not already added
                    if (!document.getElementById('bloodThirstStyle')) {
                        const style = document.createElement('style');
                        style.id = 'bloodThirstStyle';
                        style.textContent = `
                            @keyframes pulse {
                                from { transform: translateX(-50%) scale(1); }
                                to { transform: translateX(-50%) scale(1.1); }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                }
                bloodThirstUI.textContent = 'BLOOD THIRST';
                bloodThirstUI.style.display = 'block';
            }
            
            updateBloodThirstDisplay(timeRemaining) {
                const bloodThirstUI = document.getElementById('bloodThirstUI');
                if (bloodThirstUI) {
                    bloodThirstUI.textContent = `BLOOD THIRST [${timeRemaining.toFixed(1)}s]`;
                }
            }
            
            hideBloodThirstDisplay() {
                const bloodThirstUI = document.getElementById('bloodThirstUI');
                if (bloodThirstUI) {
                    bloodThirstUI.style.display = 'none';
                }
            }
            
            getDamageMultiplier() {
                return this.bloodThirstActive ? 2.0 : 1.0;
            }
            
            registerSwordKill() {
                const now = performance.now() / 1000;
                
                // Add sword kill to tracking
                this.swordKillTimes.push(now);
                
                // Check for Adrenaline (3 sword kills in 3 seconds)
                const recentSwordKills = this.swordKillTimes.filter(time => now - time <= this.adrenalineTimeWindow);
                if (recentSwordKills.length >= this.adrenalineKillsRequired) {
                    this.activateOrStackAdrenaline();
                    // Reset sword kill tracking after activation
                    this.swordKillTimes = [];
                }
                
                // Clean up old sword kills
                this.swordKillTimes = this.swordKillTimes.filter(time => now - time <= this.adrenalineTimeWindow);
            }
            
            activateOrStackAdrenaline() {
                const now = performance.now() / 1000;
                
                if (!this.adrenalineActive) {
                    // First activation
                    this.adrenalineActive = true;
                    this.adrenalineStacks = 1;
                    this.adrenalineEndTime = now + this.adrenalineDuration;
                    
                    // Play activation sound
                    if (this.audioManager) {
                        this.audioManager.play('perkAdrenaline');
                    }
                    
                    this.showAdrenalineNotification();
                } else if (this.adrenalineStacks < this.maxAdrenalineStacks) {
                    // Stack the perk
                    this.adrenalineStacks++;
                    this.adrenalineEndTime = now + this.adrenalineDuration; // Reset timer
                    
                    // Play activation sound again
                    if (this.audioManager) {
                        this.audioManager.play('perkAdrenaline');
                    }
                    
                    this.updateAdrenalineDisplay();
                } else {
                    // Max stacks - just reset timer
                    this.adrenalineEndTime = now + this.adrenalineDuration;
                    this.updateAdrenalineDisplay();
                }
            }
            
            updateAdrenaline(deltaTime) {
                if (this.adrenalineActive) {
                    const now = performance.now() / 1000;
                    if (now >= this.adrenalineEndTime) {
                        this.deactivateAdrenaline();
                    } else {
                        // Update UI with remaining time
                        const remaining = this.adrenalineEndTime - now;
                        this.updateAdrenalineDisplayTime(remaining);
                    }
                }
            }
            
            deactivateAdrenaline() {
                this.adrenalineActive = false;
                this.adrenalineStacks = 0;
                this.hideAdrenalineDisplay();
            }
            
            showAdrenalineNotification() {
                // Create or show Adrenaline UI element
                let adrenalineUI = document.getElementById('adrenalineUI');
                if (!adrenalineUI) {
                    adrenalineUI = document.createElement('div');
                    adrenalineUI.id = 'adrenalineUI';
                    adrenalineUI.style.cssText = `
                        position: fixed;
                        top: 140px;
                        left: 50%;
                        transform: translateX(-50%);
                        color: #00ff00;
                        font-size: 24px;
                        font-weight: bold;
                        text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 20px rgba(0,255,0,0.5);
                        z-index: 1000;
                        pointer-events: none;
                        animation: speedPulse 0.3s ease-in-out infinite alternate;
                    `;
                    document.body.appendChild(adrenalineUI);
                    
                    // Add animation if not already added
                    if (!document.getElementById('adrenalineStyle')) {
                        const style = document.createElement('style');
                        style.id = 'adrenalineStyle';
                        style.textContent = `
                            @keyframes speedPulse {
                                from { transform: translateX(-50%) scale(1) rotate(-2deg); }
                                to { transform: translateX(-50%) scale(1.05) rotate(2deg); }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                }
                this.updateAdrenalineDisplay();
                adrenalineUI.style.display = 'block';
            }
            
            updateAdrenalineDisplay() {
                const adrenalineUI = document.getElementById('adrenalineUI');
                if (adrenalineUI) {
                    const stackText = this.adrenalineStacks > 1 ? ` x${this.adrenalineStacks}` : '';
                    adrenalineUI.textContent = `ADRENALINE${stackText}`;
                }
            }
            
            updateAdrenalineDisplayTime(timeRemaining) {
                const adrenalineUI = document.getElementById('adrenalineUI');
                if (adrenalineUI) {
                    const stackText = this.adrenalineStacks > 1 ? ` x${this.adrenalineStacks}` : '';
                    adrenalineUI.textContent = `ADRENALINE${stackText} [${timeRemaining.toFixed(1)}s]`;
                }
            }
            
            hideAdrenalineDisplay() {
                const adrenalineUI = document.getElementById('adrenalineUI');
                if (adrenalineUI) {
                    adrenalineUI.style.display = 'none';
                }
            }
            
            activateHellfire() {
                this.hellfireActive = true;
                this.hellfireEndTime = performance.now() / 1000 + this.hellfireDuration;
                
                // Play activation sound
                if (this.audioManager) {
                    this.audioManager.play('perkHellfire');
                }
                
                // Show on-screen notification
                this.showHellfireNotification();
                
                // Notify weapon system
                if (this.weaponSystem) {
                    this.weaponSystem.activateHellfire();
                }
            }
            
            updateHellfire(deltaTime) {
                if (this.hellfireActive) {
                    const now = performance.now() / 1000;
                    if (now >= this.hellfireEndTime) {
                        this.deactivateHellfire();
                    } else {
                        // Update UI with remaining time
                        const remaining = this.hellfireEndTime - now;
                        this.updateHellfireDisplay(remaining);
                    }
                }
            }
            
            deactivateHellfire() {
                this.hellfireActive = false;
                
                // Notify weapon system
                if (this.weaponSystem) {
                    this.weaponSystem.deactivateHellfire();
                }
                
                // Hide UI
                this.hideHellfireDisplay();
            }
            
            showHellfireNotification() {
                // Create or show Hellfire UI element
                let hellfireUI = document.getElementById('hellfireUI');
                if (!hellfireUI) {
                    hellfireUI = document.createElement('div');
                    hellfireUI.id = 'hellfireUI';
                    hellfireUI.style.cssText = `
                        position: fixed;
                        top: 110px;
                        left: 50%;
                        transform: translateX(-50%);
                        color: #ff6600;
                        font-size: 24px;
                        font-weight: bold;
                        text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 20px rgba(255,165,0,0.7);
                        z-index: 1000;
                        pointer-events: none;
                        animation: fireFlicker 0.3s ease-in-out infinite alternate;
                    `;
                    document.body.appendChild(hellfireUI);
                    
                    // Add fire flicker animation if not already added
                    if (!document.getElementById('hellfireStyle')) {
                        const style = document.createElement('style');
                        style.id = 'hellfireStyle';
                        style.textContent = `
                            @keyframes fireFlicker {
                                from { 
                                    transform: translateX(-50%) scale(1); 
                                    filter: brightness(1);
                                }
                                to { 
                                    transform: translateX(-50%) scale(1.05); 
                                    filter: brightness(1.3);
                                }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                }
                hellfireUI.textContent = 'HELLFIRE';
                hellfireUI.style.display = 'block';
            }
            
            updateHellfireDisplay(timeRemaining) {
                const hellfireUI = document.getElementById('hellfireUI');
                if (hellfireUI) {
                    hellfireUI.textContent = `HELLFIRE [${timeRemaining.toFixed(1)}s]`;
                }
            }
            
            hideHellfireDisplay() {
                const hellfireUI = document.getElementById('hellfireUI');
                if (hellfireUI) {
                    hellfireUI.style.display = 'none';
                }
            }
            
            activateBerserk() {
                this.berserkActive = true;
                this.berserkEndTime = performance.now() / 1000 + this.berserkDuration;
                
                // Play all three activation sounds simultaneously
                if (this.audioManager) {
                    this.audioManager.play('perkBerserk1');
                    this.audioManager.play('perkBerserk2');
                    this.audioManager.play('perkBerserk3');
                }
                
                // Show on-screen notification
                this.showBerserkNotification();
                
                // Notify weapon system
                if (this.weaponSystem) {
                    this.weaponSystem.activateBerserk();
                }
            }
            
            updateBerserk(deltaTime) {
                if (this.berserkActive) {
                    const now = performance.now() / 1000;
                    if (now >= this.berserkEndTime) {
                        this.deactivateBerserk();
                    } else {
                        // Update UI with remaining time
                        const remaining = this.berserkEndTime - now;
                        this.updateBerserkDisplay(remaining);
                    }
                }
            }
            
            deactivateBerserk() {
                this.berserkActive = false;
                this.comboKillCount = 0; // Reset combo
                
                // Notify weapon system
                if (this.weaponSystem) {
                    this.weaponSystem.deactivateBerserk();
                }
                
                // Hide UI
                this.hideBerserkDisplay();
            }
            
            showBerserkNotification() {
                // Create or show BERSERK UI element
                let berserkUI = document.getElementById('berserkUI');
                if (!berserkUI) {
                    berserkUI = document.createElement('div');
                    berserkUI.id = 'berserkUI';
                    berserkUI.style.cssText = `
                        position: fixed;
                        top: 140px;
                        left: 50%;
                        transform: translateX(-50%);
                        color: #ff0000;
                        font-size: 32px;
                        font-weight: bold;
                        text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
                        animation: pulse 0.5s infinite;
                        z-index: 1000;
                    `;
                    document.body.appendChild(berserkUI);
                }
                berserkUI.textContent = 'BERSERK ACTIVATED!';
                berserkUI.style.display = 'block';
                
                // Add pulse animation
                if (!document.getElementById('berserkStyle')) {
                    const style = document.createElement('style');
                    style.id = 'berserkStyle';
                    style.textContent = `
                        @keyframes pulse {
                            0% { transform: translateX(-50%) scale(1); }
                            50% { transform: translateX(-50%) scale(1.1); }
                            100% { transform: translateX(-50%) scale(1); }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }
            
            updateBerserkDisplay(remainingTime) {
                const berserkUI = document.getElementById('berserkUI');
                if (berserkUI) {
                    berserkUI.textContent = `BERSERK! ${remainingTime.toFixed(1)}s`;
                }
            }
            
            hideBerserkDisplay() {
                const berserkUI = document.getElementById('berserkUI');
                if (berserkUI) {
                    berserkUI.style.display = 'none';
                }
            }
            
            registerHeadshot() {
                const now = performance.now() / 1000;
                
                // Add headshot to tracking
                this.headshotTimes.push(now);
                
                // Check for SLOWMO (3 headshots in 3 seconds)
                const recentHeadshots = this.headshotTimes.filter(time => now - time <= this.headshotTimeWindow);
                if (recentHeadshots.length >= this.slowmoHeadshotsRequired && !this.slowmoActive) {
                    this.activateSlowmo();
                    // Reset headshot tracking after activation
                    this.headshotTimes = [];
                }
                
                // Clean up old headshots
                this.headshotTimes = this.headshotTimes.filter(time => now - time <= this.headshotTimeWindow);
            }
            
            activateSlowmo() {
                this.slowmoActive = true;
                this.slowmoEndTime = performance.now() / 1000 + this.slowmoDuration;
                this.timeScale = 0.25; // Slow down to 25% speed (75% reduction)
                
                // Play activation sound
                if (this.audioManager) {
                    this.audioManager.play('perkSlowmo');
                    // Set playback rate for all sounds
                    this.audioManager.setGlobalPlaybackRate(0.25);
                }
                
                // Show on-screen notification
                this.showSlowmoNotification();
            }
            
            updateSlowmo(deltaTime) {
                if (this.slowmoActive) {
                    const now = performance.now() / 1000;
                    if (now >= this.slowmoEndTime) {
                        this.deactivateSlowmo();
                    } else {
                        // Update UI with remaining time
                        const remaining = this.slowmoEndTime - now;
                        this.updateSlowmoDisplay(remaining);
                    }
                }
            }
            
            deactivateSlowmo() {
                this.slowmoActive = false;
                this.timeScale = 1.0; // Return to normal speed
                
                // Reset audio playback rate
                if (this.audioManager) {
                    this.audioManager.setGlobalPlaybackRate(1.0);
                }
                
                // Hide UI
                this.hideSlowmoDisplay();
            }
            
            showSlowmoNotification() {
                // Create or show SLOWMO UI element
                let slowmoUI = document.getElementById('slowmoUI');
                if (!slowmoUI) {
                    slowmoUI = document.createElement('div');
                    slowmoUI.id = 'slowmoUI';
                    slowmoUI.style.cssText = `
                        position: fixed;
                        top: 170px;
                        left: 50%;
                        transform: translateX(-50%);
                        color: #00ffff;
                        font-size: 24px;
                        font-weight: bold;
                        text-shadow: 0 0 10px #00ffff;
                        z-index: 1000;
                    `;
                    document.body.appendChild(slowmoUI);
                }
                slowmoUI.textContent = 'SLOWMO ACTIVATED!';
                slowmoUI.style.display = 'block';
            }
            
            updateSlowmoDisplay(remainingTime) {
                const slowmoUI = document.getElementById('slowmoUI');
                if (slowmoUI) {
                    slowmoUI.textContent = `SLOWMO [${remainingTime.toFixed(1)}s]`;
                }
            }
            
            hideSlowmoDisplay() {
                const slowmoUI = document.getElementById('slowmoUI');
                if (slowmoUI) {
                    slowmoUI.style.display = 'none';
                }
            }
            
            getTimeScale() {
                return this.timeScale;
            }
        }

        // Wave System
        class WaveSystem {
            constructor() {
                this.currentWave = 1;
                this.enemiesPerWave = 10; // Back to original higher count
                this.enemySpawnRate = 1; // Back to faster spawn rate (1 enemy per second)
                this.lastSpawnTime = 0;
                this.enemiesSpawned = 0;
                this.waveActive = false;
                this.waveCompleteTime = 0;
                this.nextWaveDelay = 5; // seconds between waves
            }

            startWave() {
                this.waveActive = true;
                this.enemiesSpawned = 0;
                this.lastSpawnTime = performance.now() / 1000;
                this.updateWaveDisplay();
            }

            update(deltaTime, enemies) {
                if (!this.waveActive) {
                    // Check if we should start next wave
                    const now = performance.now() / 1000;
                    if (enemies.length === 0 && (now - this.waveCompleteTime) >= this.nextWaveDelay) {
                        this.nextWave();
                    }
                    return null;
                }

                // Check if wave is complete
                if (this.enemiesSpawned >= this.getEnemiesForWave() && enemies.length === 0) {
                    this.completeWave();
                    return null;
                }

                // Spawn enemies
                const now = performance.now() / 1000;
                if (this.enemiesSpawned < this.getEnemiesForWave() && 
                    (now - this.lastSpawnTime) >= this.enemySpawnRate) {
                    this.lastSpawnTime = now;
                    this.enemiesSpawned++;
                    return this.getRandomEnemyType();
                }

                return null;
            }

            completeWave() {
                this.waveActive = false;
                this.waveCompleteTime = performance.now() / 1000;
            }

            nextWave() {
                this.currentWave++;
                this.startWave();
            }

            getEnemiesForWave() {
                // Doubled base (10) plus increased scaling per wave
                return this.enemiesPerWave + Math.floor(this.currentWave * 2);
            }

            getRandomEnemyType() {
                // Higher waves have tougher enemies
                if (this.currentWave >= 5 && Math.random() < 0.3) {
                    return 2; // Strong enemy
                } else if (this.currentWave >= 3 && Math.random() < 0.4) {
                    return 1; // Medium enemy
                } else {
                    return 0; // Basic enemy
                }
            }

            getCurrentWave() {
                return this.currentWave;
            }

            updateWaveDisplay() {
                document.getElementById('waveDisplay').textContent = this.currentWave;
            }
        }

        // Game Manager
        class GameManager {
            constructor() {
                this.score = 0;
                this.highScore = this.loadHighScore();
                this.kills = 0;
                
                this.updateScoreDisplay();
            }

            addScore(points) {
                this.score += points;
                this.updateScoreDisplay();
            }

            addKill() {
                this.kills++;
            }

            getScore() {
                return this.score;
            }

            getKills() {
                return this.kills;
            }

            checkHighScore() {
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    this.saveHighScore();
                    return true;
                }
                return false;
            }

            loadHighScore() {
                const saved = localStorage.getItem('fps_highscore');
                return saved ? parseInt(saved) : 0;
            }

            saveHighScore() {
                localStorage.setItem('fps_highscore', this.highScore.toString());
            }

            updateScoreDisplay() {
                document.getElementById('scoreDisplay').textContent = this.score;
            }

            reset() {
                this.score = 0;
                this.kills = 0;
                this.updateScoreDisplay();
            }
        }

        // UI Manager
        class UIManager {
            constructor() {
                this.killFeed = document.getElementById('killFeed');
                this.showFPS = false;
                this.showDebug = false;
                this.fpsCounter = document.getElementById('fpsCounter');
                this.debugInfo = document.getElementById('debugInfo');
                
                this.frameCount = 0;
                this.lastFPSTime = performance.now();
            }

            addKillMessage(message) {
                const killMessage = document.createElement('div');
                killMessage.className = 'kill-message';
                killMessage.textContent = message;
                
                this.killFeed.appendChild(killMessage);
                
                // Remove message after animation
                setTimeout(() => {
                    if (killMessage.parentNode) {
                        killMessage.parentNode.removeChild(killMessage);
                    }
                }, 4000);
                
                // Limit number of messages
                while (this.killFeed.children.length > 5) {
                    this.killFeed.removeChild(this.killFeed.firstChild);
                }
            }

            updateFPS(deltaTime) {
                if (!this.showFPS) return;

                this.frameCount++;
                const now = performance.now();
                
                if (now - this.lastFPSTime >= 1000) {
                    const fps = Math.round(this.frameCount * 1000 / (now - this.lastFPSTime));
                    this.fpsCounter.textContent = `FPS: ${fps}`;
                    this.frameCount = 0;
                    this.lastFPSTime = now;
                }
            }

            updateDebugInfo(player, enemies, bullets) {
                if (!this.showDebug) return;

                const pos = player.getPosition();
                const debugText = `
Position: ${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}
Health: ${player.health.toFixed(0)} / ${player.maxHealth}
Enemies: ${enemies.length}
Active Bullets: ${bullets.length}
Velocity: ${player.velocity.length().toFixed(2)}
                `.trim();
                
                this.debugInfo.textContent = debugText;
            }

            toggleFPS() {
                this.showFPS = !this.showFPS;
                this.fpsCounter.style.display = this.showFPS ? 'block' : 'none';
            }

            toggleDebug() {
                this.showDebug = !this.showDebug;
                this.debugInfo.style.display = this.showDebug ? 'block' : 'none';
            }

            updateEnemyCount(count) {
                document.getElementById('enemyCount').textContent = count;
            }

            drawMinimap(canvas, player, enemies, pickups) {
                const ctx = canvas.getContext('2d');
                const size = 150;
                const scale = 1; // 1 pixel per unit
                const centerX = size / 2;
                const centerY = size / 2;
                
                // Clear canvas
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, size, size);
                
                // Draw boundaries
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.strokeRect(1, 1, size - 2, size - 2);
                
                // Draw player
                const playerPos = player.getPosition();
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.arc(
                    centerX + playerPos.x * scale,
                    centerY - playerPos.z * scale, // Flip Z for screen coords
                    3, 0, Math.PI * 2
                );
                ctx.fill();
                
                // Draw player direction
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyEuler(new THREE.Euler(0, player.rotation.y, 0));
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX + playerPos.x * scale, centerY - playerPos.z * scale);
                ctx.lineTo(
                    centerX + (playerPos.x + direction.x * 10) * scale,
                    centerY - (playerPos.z + direction.z * 10) * scale
                );
                ctx.stroke();
                
                // Draw enemies
                ctx.fillStyle = '#ff4444';
                for (let enemy of enemies) {
                    if (enemy.active) {
                        const enemyPos = enemy.position;
                        ctx.beginPath();
                        ctx.arc(
                            centerX + enemyPos.x * scale,
                            centerY - enemyPos.z * scale,
                            2, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
                
                // Draw pickups
                ctx.fillStyle = '#ffff00';
                for (let pickup of pickups) {
                    if (pickup.active) {
                        const pickupPos = pickup.getPosition();
                        ctx.beginPath();
                        ctx.arc(
                            centerX + pickupPos.x * scale,
                            centerY - pickupPos.z * scale,
                            1.5, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
            }
        }

        // Main game class
        class FPSGame {
            constructor() {
                this.state = GameState.MENU;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.player = null;
                this.inputManager = null;
                this.audioManager = null;
                this.weaponSystem = null;
                this.particleSystem = null;
                this.waveSystem = null;
                this.gameManager = null;
                this.uiManager = null;
                
                this.collisionObjects = [];
                this.enemies = [];
                this.pickups = [];
                
                // Object pools
                this.bulletPool = null;
                
                // Time tracking
                this.clock = new THREE.Clock();
                this.lastTime = 0;
                this.pickupSpawnTimer = 0;
                this.pickupSpawnInterval = 10; // seconds
                
                this.init();
                this.createEnvironment();
                this.setupGameSystems();
                this.bindEvents();
                this.animate();
            }
            
            init() {
                // Create scene
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
                
                // Create camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                
                // Create renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);
                
                // Setup lighting
                this.setupLighting();
                
                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
            }

            setupGameSystems() {
                // Create input manager
                this.inputManager = new InputManager();
                
                // Create audio manager
                this.audioManager = new AudioManager();
                
                // Create player
                this.player = new Player(this.camera, this.scene, this.audioManager);
                
                // Create weapon system
                this.weaponSystem = new WeaponSystem(this.scene, this.camera, this.audioManager);
                
                // Connect player and weapon system for Blood Thirst
                this.player.weaponSystem = this.weaponSystem;
                this.weaponSystem.player = this.player;
                
                // Create particle system
                this.particleSystem = new ParticleSystem(this.scene);
                
                // Store reference for ragdoll blood trails
                window.currentGame = this;
                
                // Create wave system
                this.waveSystem = new WaveSystem();
                
                // Create game manager
                this.gameManager = new GameManager();
                
                // Create UI manager
                this.uiManager = new UIManager();
                
                // Create bullet pools
                this.bulletPool = new ObjectPool(
                    () => new Bullet(this.scene),
                    (bullet) => bullet.reset(),
                    100
                );
                
                // Enemy bullet pool (smaller, red bullets)
                this.enemyBulletPool = new ObjectPool(
                    () => {
                        const bullet = new Bullet(this.scene);
                        bullet.mesh.material.color.setHex(0xff0000);
                        return bullet;
                    },
                    (bullet) => bullet.reset(),
                    50
                );
            }

            bindEvents() {
                document.addEventListener('keydown', (e) => {
                    this.handleKeyDown(e.code);
                });
            }

            handleKeyDown(keyCode) {
                switch (keyCode) {
                    case 'Escape':
                        this.handleEscapeKey();
                        break;
                    case 'KeyR':
                        if (this.state === GameState.PLAYING) {
                            if (this.state === GameState.PAUSED) {
                                this.restartGame();
                            } else {
                                this.weaponSystem.startReload();
                            }
                        }
                        break;
                    case 'Space':
                        if (this.state === GameState.GAME_OVER) {
                            this.restartGame();
                        }
                        break;
                    case 'KeyF':
                        this.uiManager.toggleFPS();
                        break;
                    case 'KeyG':
                        this.uiManager.toggleDebug();
                        break;
                    case 'Digit1':
                        if (this.state === GameState.PLAYING) {
                            this.weaponSystem.switchWeapon('smg');
                        }
                        break;
                    case 'Digit2':
                        if (this.state === GameState.PLAYING) {
                            this.weaponSystem.switchWeapon('shotgun');
                        }
                        break;
                    case 'Digit3':
                        if (this.state === GameState.PLAYING) {
                            this.weaponSystem.switchWeapon('rocket');
                        }
                        break;
                    case 'Digit4':
                        if (this.state === GameState.PLAYING) {
                            this.weaponSystem.switchWeapon('sword');
                        }
                        break;
                }
            }

            handleEscapeKey() {
                switch (this.state) {
                    case GameState.PLAYING:
                        this.pauseGame();
                        break;
                    case GameState.PAUSED:
                        this.resumeGame();
                        break;
                    case GameState.GAME_OVER:
                        this.showMenu();
                        break;
                }
            }

            startGame() {
                this.state = GameState.PLAYING;
                this.hideAllScreens();
                
                // Reset game state
                this.gameManager.reset();
                this.player.health = this.player.maxHealth;
                this.player.updateHealthDisplay();
                
                // Reset weapon ammo
                this.weaponSystem.weapons.smg.currentAmmo = 30;
                this.weaponSystem.weapons.shotgun.currentAmmo = 6;
                this.weaponSystem.weapons.rocket.currentAmmo = 1;
                this.weaponSystem.reserveAmmo = 90;
                this.weaponSystem.updateAmmoDisplay();
                
                // Clear entities
                this.clearEnemies();
                this.clearPickups();
                this.bulletPool.releaseAll();
                this.enemyBulletPool.releaseAll();
                
                // Start first wave
                this.waveSystem = new WaveSystem();
                this.waveSystem.startWave();
            }

            pauseGame() {
                if (this.state !== GameState.PLAYING) return;
                this.state = GameState.PAUSED;
                this.inputManager.releasePointerLock();
                document.getElementById('pauseScreen').style.display = 'flex';
            }

            resumeGame() {
                if (this.state !== GameState.PAUSED) return;
                this.state = GameState.PLAYING;
                document.getElementById('pauseScreen').style.display = 'none';
            }

            restartGame() {
                this.startGame();
            }

            endGame() {
                this.state = GameState.GAME_OVER;
                this.inputManager.releasePointerLock();
                
                const isHighScore = this.gameManager.checkHighScore();
                const finalStats = `
                    <p>Final Score: ${this.gameManager.getScore()}</p>
                    <p>Kills: ${this.gameManager.getKills()}</p>
                    <p>Wave Reached: ${this.waveSystem.getCurrentWave()}</p>
                    ${isHighScore ? '<p style="color: #ffff00;">NEW HIGH SCORE!</p>' : ''}
                    <p>High Score: ${this.gameManager.highScore}</p>
                `;
                
                document.getElementById('finalStats').innerHTML = finalStats;
                document.getElementById('gameOverScreen').style.display = 'flex';
            }

            showMenu() {
                this.state = GameState.MENU;
                this.hideAllScreens();
                document.getElementById('menuScreen').style.display = 'flex';
            }

            hideAllScreens() {
                document.getElementById('menuScreen').style.display = 'none';
                document.getElementById('gameOverScreen').style.display = 'none';
                document.getElementById('pauseScreen').style.display = 'none';
            }
            
            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                // Directional light (sun)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                
                // Configure shadow properties
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -100;
                directionalLight.shadow.camera.right = 100;
                directionalLight.shadow.camera.top = 100;
                directionalLight.shadow.camera.bottom = -100;
                
                this.scene.add(directionalLight);
            }
            
            createEnvironment() {
                // Ground
                const groundGeometry = new THREE.PlaneGeometry(200, 200);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x4a5d23,
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Create walls and obstacles
                this.createWalls();
                this.createObstacles();
                
                // Add some decorative elements
                this.createDecorations();
            }
            
            createWalls() {
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                
                // Boundary walls
                const walls = [
                    { pos: [0, 2.5, -50], size: [100, 5, 2] },    // North wall
                    { pos: [0, 2.5, 50], size: [100, 5, 2] },     // South wall
                    { pos: [-50, 2.5, 0], size: [2, 5, 100] },    // West wall
                    { pos: [50, 2.5, 0], size: [2, 5, 100] },     // East wall
                ];
                
                walls.forEach(wall => {
                    const geometry = new THREE.BoxGeometry(wall.size[0], wall.size[1], wall.size[2]);
                    const mesh = new THREE.Mesh(geometry, wallMaterial);
                    mesh.position.set(wall.pos[0], wall.pos[1], wall.pos[2]);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    this.scene.add(mesh);
                    this.collisionObjects.push(mesh);
                });
            }
            
            createObstacles() {
                const obstacleMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                
                // Interior walls/obstacles
                const obstacles = [
                    { pos: [20, 2, -20], size: [4, 4, 15] },
                    { pos: [-25, 2, 10], size: [8, 4, 4] },
                    { pos: [15, 2, 25], size: [6, 4, 6] },
                    { pos: [-10, 2, -30], size: [12, 4, 4] },
                    { pos: [30, 1.5, 0], size: [4, 3, 8] },
                ];
                
                obstacles.forEach(obstacle => {
                    const geometry = new THREE.BoxGeometry(obstacle.size[0], obstacle.size[1], obstacle.size[2]);
                    const mesh = new THREE.Mesh(geometry, obstacleMaterial);
                    mesh.position.set(obstacle.pos[0], obstacle.pos[1], obstacle.pos[2]);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    this.scene.add(mesh);
                    this.collisionObjects.push(mesh);
                });
            }
            
            createDecorations() {
                // Add some crates
                const crateMaterial = new THREE.MeshLambertMaterial({ color: 0xDEB887 });
                
                for (let i = 0; i < 10; i++) {
                    const size = 1 + Math.random() * 1.5;
                    const geometry = new THREE.BoxGeometry(size, size, size);
                    const crate = new THREE.Mesh(geometry, crateMaterial);
                    
                    crate.position.set(
                        (Math.random() - 0.5) * 80,
                        size / 2,
                        (Math.random() - 0.5) * 80
                    );
                    
                    crate.rotation.y = Math.random() * Math.PI * 2;
                    crate.castShadow = true;
                    crate.receiveShadow = true;
                    
                    this.scene.add(crate);
                    this.collisionObjects.push(crate);
                }
                
                // Add some pillars
                const pillarMaterial = new THREE.MeshLambertMaterial({ color: 0x708090 });
                
                for (let i = 0; i < 5; i++) {
                    const geometry = new THREE.CylinderGeometry(1, 1.5, 8, 8);
                    const pillar = new THREE.Mesh(geometry, pillarMaterial);
                    
                    pillar.position.set(
                        (Math.random() - 0.5) * 60,
                        4,
                        (Math.random() - 0.5) * 60
                    );
                    
                    pillar.castShadow = true;
                    pillar.receiveShadow = true;
                    
                    this.scene.add(pillar);
                    this.collisionObjects.push(pillar);
                }
            }

            spawnEnemy(type) {
                // Find a spawn position away from player
                const playerPos = this.player.getPosition();
                let spawnPos;
                let attempts = 0;
                
                do {
                    spawnPos = new THREE.Vector3(
                        (Math.random() - 0.5) * 80,
                        0,  // Spawn at ground level
                        (Math.random() - 0.5) * 80
                    );
                    attempts++;
                } while (spawnPos.distanceTo(playerPos) < 15 && attempts < 20);
                
                const enemy = new Enemy(this.scene, spawnPos, type, this.waveSystem.currentWave);
                this.enemies.push(enemy);
                
                // Log enemy weapon type
                let weaponDesc = 'pistol';
                if (enemy.weaponType === 'rocket') weaponDesc = 'ROCKET LAUNCHER';
                else if (enemy.weaponType === 'shotgun') weaponDesc = 'SHOTGUN';
                else if (enemy.weaponType === 'smg') weaponDesc = 'SMG (10-round burst)';
                else if (enemy.isBurstFire) weaponDesc = '3-round burst pistol';
                
                console.log(`Wave ${this.waveSystem.currentWave}: Spawned enemy with ${weaponDesc}`);
                
                this.uiManager.updateEnemyCount(this.enemies.length);
            }

            spawnPickup(type, position) {
                const pickup = new Pickup(this.scene, position, type);
                this.pickups.push(pickup);
            }

            clearEnemies() {
                this.enemies.forEach(enemy => enemy.destroy());
                this.enemies = [];
                this.uiManager.updateEnemyCount(0);
            }

            handleRocketExplosion(position, blastRadius, damage, isHellfireBullet = false, isHellfireRocket = false) {
                // Play explosion sound based on projectile type
                if (isHellfireBullet) {
                    // Hellfire bullet explosion uses special sound
                    this.audioManager.play('hellfireBulletExplode');
                } else if (isHellfireRocket) {
                    // Hellfire rocket plays both sounds layered
                    this.audioManager.play('rocketExplosion');
                    this.audioManager.play('hellfireRocketExplode');
                } else {
                    // Normal rocket explosion
                    this.audioManager.play('rocketExplosion');
                }
                
                // Create explosion effect
                if (isHellfireBullet) {
                    // Smaller explosions for Hellfire bullets (25% size)
                    this.particleSystem.createExplosion(position, 0xff6600, 12);
                    this.particleSystem.createExplosion(position, 0xffaa00, 8);
                } else if (isHellfireRocket) {
                    // MASSIVE explosion for Hellfire rockets with dramatic fireball
                    this.particleSystem.createExplosion(position, 0xffff00, 120, true); // Bright yellow core
                    this.particleSystem.createExplosion(position, 0xffaa00, 100, true); // Orange mid layer
                    this.particleSystem.createExplosion(position, 0xff6600, 80, true);  // Red-orange outer
                    this.particleSystem.createExplosion(position, 0xff0000, 60, true);  // Deep red edge
                    // Add massive shockwave for hellfire
                    this.particleSystem.createShockwave(position, true);
                } else {
                    // Normal rocket explosion
                    this.particleSystem.createExplosion(position, 0xff6600, 50);
                    this.particleSystem.createExplosion(position, 0xffaa00, 30);
                    // Add shockwave for normal rockets
                    this.particleSystem.createShockwave(position, false);
                }
                
                // Add screen shake
                if (this.weaponSystem) {
                    if (isHellfireRocket) {
                        // Massive screen shake for Hellfire rockets (4x intensity)
                        this.weaponSystem.addScreenShake(0.24);
                        // Double the duration by setting it after the call
                        if (this.weaponSystem.screenShake) {
                            this.weaponSystem.screenShake.duration = 100; // 100ms instead of 50ms
                        }
                    } else {
                        // Normal screen shake
                        this.weaponSystem.addScreenShake(0.06);
                    }
                }
                
                // Check all enemies in blast radius
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    if (!enemy.active) continue;
                    
                    const distance = position.distanceTo(enemy.position);
                    if (distance <= blastRadius) {
                        // Hellfire rockets instakill everything in blast radius
                        let blastDamage;
                        if (isHellfireRocket) {
                            blastDamage = 99999; // Instakill
                        } else {
                            // Normal damage falls off with distance
                            const falloff = 1 - (distance / blastRadius) * 0.5;
                            blastDamage = damage * falloff;
                        }
                        
                        // Play hit sound for each enemy in blast
                        this.audioManager.play('enemyHit');
                        this.particleSystem.createExplosion(enemy.position, 0xff4444, 10);
                        
                        const killed = enemy.takeDamage(blastDamage);
                        
                        if (killed) {
                            this.audioManager.play('enemyDie');
                            
                            // DISABLED blood mist - focusing on blood trails instead
                            // const enemyPos = enemy.position ? enemy.position.clone() : new THREE.Vector3();
                            // enemyPos.y += 1; // Center of enemy body
                            // this.particleSystem.createLingeringBloodMist(enemyPos);
                            
                            // Always dismember on explosive kills (removed old dismemberment call since enemy.destroy handles it)
                            
                            // Check if enemy should play explode sound
                            enemy.destroy(10, position); // Pass explosion force and position for dismemberment
                            if (enemy.shouldPlayExplodeSound) {
                                this.audioManager.play('enemyExplode');
                            }
                            
                            this.gameManager.addScore(enemy.scoreValue);
                            this.gameManager.addKill();
                            this.player.registerKill(); // Register kill for Blood Thirst
                            this.uiManager.addKillMessage(`Enemy eliminated +${enemy.scoreValue}`);
                            
                            // Chance for pickups
                            if (Math.random() < 0.3) {
                                const pickupType = Math.random() < 0.5 ? 'health' : 'ammo';
                                this.spawnPickup(pickupType, enemy.position.clone());
                            }
                            
                            this.enemies.splice(i, 1);
                            this.uiManager.updateEnemyCount(this.enemies.length);
                        }
                    }
                }
                
                // Check if player is in blast radius
                const playerPos = this.player.getPosition();
                const playerDistance = position.distanceTo(playerPos);
                if (playerDistance <= blastRadius) {
                    // Player takes damage from their own rocket
                    const falloff = 1 - (playerDistance / blastRadius) * 0.5;
                    const blastDamage = damage * falloff * 0.5; // Reduced self-damage
                    this.player.takeDamage(blastDamage);
                }
            }

            clearPickups() {
                this.pickups.forEach(pickup => {
                    if (pickup.active) {
                        pickup.collect(); // This will clean up the mesh
                    }
                });
                this.pickups = [];
            }

            updateGame(deltaTime) {
                if (this.state !== GameState.PLAYING) return;
                
                // Apply time scale for SLOWMO
                const timeScale = this.player.getTimeScale();
                const scaledDeltaTime = deltaTime * timeScale;

                // Update player (always use real deltaTime for player controls)
                this.player.update(deltaTime, this.inputManager, this.collisionObjects);
                
                // Update Blood Thirst perk
                this.player.updateBloodThirst(deltaTime);
                
                // Update Hellfire perk
                this.player.updateHellfire(deltaTime);
                
                // Update Adrenaline perk
                this.player.updateAdrenaline(deltaTime);
                
                // Update BERSERK perk
                this.player.updateBerserk(deltaTime);
                
                // Update SLOWMO perk
                this.player.updateSlowmo(deltaTime);
                
                // Check if player is dead
                if (this.player.isDead()) {
                    this.endGame();
                    return;
                }

                // Update weapon system (use scaled time for animations)
                this.weaponSystem.update(scaledDeltaTime, this.inputManager);

                // Handle shooting
                if (this.inputManager.isMousePressed() && this.inputManager.isPointerLocked) {
                    const bullets = this.weaponSystem.shoot(this.bulletPool, this.particleSystem, true, this.enemies, this.player, this.gameManager, this.uiManager);
                }

                // Update bullets (use scaled time for movement)
                const activeBullets = this.bulletPool.active.slice();
                for (let bullet of activeBullets) {
                    if (!bullet.update(scaledDeltaTime)) {
                        this.bulletPool.release(bullet);
                        continue;
                    }

                    // Check bullet-enemy collisions
                    for (let i = this.enemies.length - 1; i >= 0; i--) {
                        const enemy = this.enemies[i];
                        if (!enemy.active) continue;

                        const bulletPos = bullet.isRocket && bullet.rocketMesh ? 
                            bullet.rocketMesh.position : bullet.mesh.position;
                        
                        // Check for headshot first (if enemy has head mesh)
                        let isHeadshot = false;
                        let hitDetected = false;
                        let hitPosition = enemy.position.clone();
                        
                        if (enemy.headMesh && enemy.mesh) {
                            // Get world position of head
                            const headWorldPos = new THREE.Vector3();
                            enemy.headMesh.getWorldPosition(headWorldPos);
                            
                            // Check if bullet hits head (50% larger hitbox)
                            const headDistance = bulletPos.distanceTo(headWorldPos);
                            if (headDistance < 0.45 * enemy.size) { // Increased from 0.3 to 0.45 (50% larger)
                                isHeadshot = true;
                                hitDetected = true;
                                hitPosition = headWorldPos;
                            }
                        }
                        
                        // If not headshot, check body hit
                        if (!hitDetected) {
                            // Adjust hit detection for larger enemy models
                            // Enemy position is at ground level, torso is at y=0.8
                            const torsoPos = enemy.position.clone();
                            torsoPos.y += 0.8 * enemy.size;
                            const bodyDistance = bulletPos.distanceTo(torsoPos);
                            // Hit radius should scale with enemy size
                            if (bodyDistance < 0.8 * enemy.size) {
                                hitDetected = true;
                                hitPosition = torsoPos;
                            }
                        }
                        
                        if (hitDetected) {
                            // Handle rocket explosion
                            if (bullet.isRocket) {
                                const explosionPos = bullet.rocketMesh ? 
                                    bullet.rocketMesh.position.clone() : bullet.mesh.position.clone();
                                this.handleRocketExplosion(explosionPos, bullet.blastRadius, bullet.damage, bullet.isHellfireBullet, bullet.isHellfireRocket);
                                this.bulletPool.release(bullet);
                                break;
                            }
                            
                            // Calculate damage (double for headshot)
                            let finalDamage = bullet.damage;
                            
                            // Check if headshot will kill
                            const willKill = (isHeadshot && finalDamage * 2 >= enemy.hp);
                            
                            if (isHeadshot) {
                                finalDamage *= 2;
                                // Headshot effects
                                this.particleSystem.createExplosion(hitPosition, 0xffff00, 20); // Yellow explosion for headshot
                                
                                // Layer all three headshot sounds
                                this.audioManager.play('enemyHeadshot');
                                this.audioManager.play('enemyHeadshot2');
                                this.audioManager.play('enemyHeadshot3');
                                
                                // Create blood jet effect only for non-lethal headshots
                                // (Lethal headshots will use dismemberment effects instead)
                                if (!willKill) {
                                    this.particleSystem.createBloodJet(hitPosition, bulletPos.clone().sub(hitPosition).normalize());
                                }
                                
                                // Award headshot bonus points
                                this.gameManager.addScore(50);
                                this.uiManager.addKillMessage('HEADSHOT! +50');
                                
                                // Register headshot for SLOWMO perk
                                this.player.registerHeadshot();
                            } else {
                                // Normal hit effects
                                this.particleSystem.createExplosion(hitPosition, 0xff4444, 15);
                                this.audioManager.play('enemyHit');
                            }
                            
                            // 10% chance to play grunt sound when hit (body shot only)
                            if (!isHeadshot && Math.random() < 0.1) {
                                this.audioManager.play('enemyGrunt');
                            }
                            
                            const killed = enemy.takeDamage(finalDamage);
                            this.bulletPool.release(bullet);
                            
                            if (killed) {
                                // Enemy killed - play death sound
                                this.audioManager.play('enemyDie');
                                
                                // 1/6 chance to play death grunt
                                if (Math.random() < 1/6) {
                                    this.audioManager.play('enemyDeathGrunt');
                                }
                                
                                // Check for shotgun headshot decapitation
                                if (isHeadshot && bullet.weapon === 'shotgun') {
                                    // Remove head for shotgun headshot kills
                                    if (enemy.bodyParts && enemy.bodyParts.head) {
                                        // Hide the head
                                        enemy.bodyParts.head.visible = false;
                                        
                                        // Get neck position for gibs
                                        const neckPos = enemy.mesh.position.clone();
                                        neckPos.y += 1.3; // Approximate neck height
                                        
                                        // Create head removal effect
                                        this.particleSystem.createHeadRemoval(neckPos, bulletPos.clone().sub(neckPos).normalize());
                                    }
                                }
                                
                                // Check for other dismemberment conditions
                                const distanceToEnemy = bulletPos.distanceTo(enemy.position);
                                const shouldDismember = 
                                    (isHeadshot && bullet.weapon !== 'shotgun') || // Non-shotgun headshots use normal dismemberment
                                    (bullet.weapon === 'shotgun' && distanceToEnemy < 10 && !isHeadshot) || // Close range shotgun body shots
                                    finalDamage >= 150; // Very high damage kills
                                
                                if (shouldDismember) {
                                    try {
                                        // Use hitPosition for headshots, enemy.position for others
                                        const dismemberPosition = isHeadshot && hitPosition ? hitPosition.clone() : 
                                                                 (enemy.position ? enemy.position.clone() : new THREE.Vector3());
                                        const bulletPosition = bulletPos ? bulletPos.clone() : new THREE.Vector3();
                                        const forceDirection = bulletPosition.sub(dismemberPosition).normalize();
                                        const dismemberType = isHeadshot ? 'headshot' : 'ballistic';
                                        this.particleSystem.createDismemberment(dismemberPosition, dismemberType, forceDirection);
                                    } catch (error) {
                                        console.warn('Dismemberment error in bullet kill:', error);
                                    }
                                }
                                
                                this.gameManager.addScore(enemy.scoreValue);
                                this.gameManager.addKill();
                                this.player.registerKill(); // Register kill for Blood Thirst
                                this.uiManager.addKillMessage(`Enemy eliminated +${enemy.scoreValue}`);
                                
                                // Random pickup chance
                                if (Math.random() < 0.3) {
                                    const pickupType = Math.random() < 0.5 ? 'health' : 'ammo';
                                    this.spawnPickup(pickupType, enemy.position.clone());
                                }
                                
                                enemy.destroy();
                                this.enemies.splice(i, 1);
                                this.uiManager.updateEnemyCount(this.enemies.length);
                            }
                            break;
                        }
                    }

                    // Get bullet position
                    const bulletPos = bullet.isRocket && bullet.rocketMesh ? 
                        bullet.rocketMesh.position : bullet.mesh.position;
                    
                    // Check ground collision (y <= 0)
                    if (bulletPos.y <= 0) {
                        // Handle rocket explosion on ground impact
                        if (bullet.isRocket) {
                            this.handleRocketExplosion(bulletPos.clone(), bullet.blastRadius, bullet.damage, bullet.isHellfireBullet, bullet.isHellfireRocket);
                        } else if (bullet.isHellfireBullet) {
                            // Hellfire bullet creates small explosion
                            this.handleRocketExplosion(new THREE.Vector3(bulletPos.x, 0, bulletPos.z), bullet.blastRadius, bullet.damage, true, false);
                        } else {
                            this.particleSystem.createExplosion(new THREE.Vector3(bulletPos.x, 0, bulletPos.z), 0x888888, 8);
                            this.audioManager.play('bulletHit'); // Play random bullet hit sound
                        }
                        this.bulletPool.release(bullet);
                        continue;
                    }
                    
                    // Check bullet-wall collisions
                    for (let obj of this.collisionObjects) {
                        const box = new THREE.Box3().setFromObject(obj);
                        
                        if (box.containsPoint(bulletPos)) {
                            // Handle rocket explosion on wall impact
                            if (bullet.isRocket) {
                                this.handleRocketExplosion(bulletPos.clone(), bullet.blastRadius, bullet.damage, bullet.isHellfireBullet, bullet.isHellfireRocket);
                            } else if (bullet.isHellfireBullet) {
                                // Hellfire bullet creates small explosion
                                this.handleRocketExplosion(bulletPos.clone(), bullet.blastRadius, bullet.damage, true, false);
                            } else {
                                this.particleSystem.createExplosion(bulletPos, 0x888888, 8);
                                this.audioManager.play('bulletHit'); // Play random bullet hit sound
                            }
                            this.bulletPool.release(bullet);
                            break;
                        }
                    }
                }

                // Update enemies (use scaled time for movement)
                const playerPos = this.player.getPosition();
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    enemy.update(scaledDeltaTime, playerPos, this.enemyBulletPool, this.particleSystem, this.audioManager);
                    
                    // Remove dead enemies from array (important for sword kills)
                    if (!enemy.active || enemy.isDead) {
                        this.enemies.splice(i, 1);
                        this.uiManager.updateEnemyCount(this.enemies.length);
                    }
                }
                
                // Update enemy bullets (use scaled time)
                const activeEnemyBullets = this.enemyBulletPool.active.slice();
                for (let bullet of activeEnemyBullets) {
                    if (!bullet.update(scaledDeltaTime)) {
                        this.enemyBulletPool.release(bullet);
                        continue;
                    }
                    
                    // Check distance to player for whizz sound
                    const bulletPos = bullet.isRocket && bullet.rocketMesh ? 
                        bullet.rocketMesh.position : bullet.mesh.position;
                    const distance = bulletPos.distanceTo(playerPos);
                    
                    // Check ground collision (y <= 0)
                    if (bulletPos.y <= 0) {
                        if (bullet.isRocket) {
                            // Enemy rocket ground explosion (never Hellfire)
                            this.handleRocketExplosion(new THREE.Vector3(bulletPos.x, 0, bulletPos.z), bullet.blastRadius || 5, bullet.damage, false, false);
                        } else {
                            this.particleSystem.createExplosion(new THREE.Vector3(bulletPos.x, 0, bulletPos.z), 0xff4444, 5);
                            this.audioManager.play('bulletHit'); // Play random bullet hit sound
                        }
                        this.enemyBulletPool.release(bullet);
                        continue;
                    }
                    
                    // Play whizz sound when bullet passes near player (within 3 units)
                    if (distance < 3 && !bullet.hasWhizzed) {
                        this.audioManager.play('bulletWhizz');
                        bullet.hasWhizzed = true; // Only play once per bullet
                    }
                    
                    // Check if enemy bullet hits player
                    if (distance < 1) {
                        // Handle enemy rockets
                        if (bullet.isRocket) {
                            // Explosion affects area (never Hellfire)
                            this.handleRocketExplosion(bulletPos.clone(), bullet.blastRadius || 5, bullet.damage, false, false);
                            this.enemyBulletPool.release(bullet);
                        } else {
                            this.player.takeDamage(bullet.damage);
                            this.particleSystem.createExplosion(playerPos, 0xff0000, 10);
                            this.enemyBulletPool.release(bullet);
                        }
                    }
                    
                    // Check bullet-wall collisions
                    for (let obj of this.collisionObjects) {
                        const box = new THREE.Box3().setFromObject(obj);
                        const checkPos = bullet.isRocket && bullet.rocketMesh ? 
                            bullet.rocketMesh.position : bullet.mesh.position;
                        
                        if (box.containsPoint(checkPos)) {
                            if (bullet.isRocket) {
                                // Enemy rocket explosion (never Hellfire)
                                this.handleRocketExplosion(checkPos.clone(), bullet.blastRadius || 5, bullet.damage, false, false);
                            } else {
                                this.particleSystem.createExplosion(checkPos, 0xff4444, 5);
                                this.audioManager.play('bulletHit'); // Play random bullet hit sound
                            }
                            this.enemyBulletPool.release(bullet);
                            break;
                        }
                    }
                }

                // Update pickups
                for (let i = this.pickups.length - 1; i >= 0; i--) {
                    const pickup = this.pickups[i];
                    pickup.update(deltaTime);
                    
                    // Check pickup-player collision
                    if (pickup.getPosition().distanceTo(playerPos) < 2) {
                        const type = pickup.collect();
                        if (type === 'health') {
                            this.player.heal(30);
                            this.uiManager.addKillMessage('Health restored +30');
                        } else if (type === 'ammo') {
                            this.weaponSystem.addAmmo(30);
                            this.uiManager.addKillMessage('Ammo collected +30');
                        }
                        this.audioManager.play('pickup');
                        this.pickups.splice(i, 1);
                    }
                }

                // Update wave system (use scaled time for spawn timing)
                const newEnemyType = this.waveSystem.update(scaledDeltaTime, this.enemies);
                if (newEnemyType !== null) {
                    this.spawnEnemy(newEnemyType);
                }

                // Spawn random pickups
                this.pickupSpawnTimer += deltaTime;
                if (this.pickupSpawnTimer >= this.pickupSpawnInterval) {
                    this.pickupSpawnTimer = 0;
                    if (this.pickups.length < 3 && Math.random() < 0.7) {
                        const pickupType = Math.random() < 0.6 ? 'ammo' : 'health';
                        const spawnPos = new THREE.Vector3(
                            (Math.random() - 0.5) * 80,
                            1,
                            (Math.random() - 0.5) * 80
                        );
                        this.spawnPickup(pickupType, spawnPos);
                    }
                }

                // Update particle system (use scaled time for animations)
                this.particleSystem.update(scaledDeltaTime);

                // Update UI
                this.uiManager.updateDebugInfo(this.player, this.enemies, this.bulletPool.active);
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const currentTime = this.clock.getElapsedTime();
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                // Clamp delta time to prevent large jumps
                const clampedDeltaTime = Math.min(deltaTime, 1/30);
                
                // Handle different game states
                switch (this.state) {
                    case GameState.MENU:
                        // Handle menu input
                        if (this.inputManager.isPointerLocked) {
                            this.startGame();
                        }
                        break;
                    
                    case GameState.PLAYING:
                        this.updateGame(clampedDeltaTime);
                        break;
                    
                    case GameState.PAUSED:
                        // Game is paused, don't update anything
                        break;
                    
                    case GameState.GAME_OVER:
                        // Maybe show some effects or cleanup
                        break;
                }

                // Update UI elements
                this.uiManager.updateFPS(clampedDeltaTime);
                
                // Update minimap
                if (this.state === GameState.PLAYING) {
                    const minimap = document.getElementById('minimap');
                    this.uiManager.drawMinimap(minimap, this.player, this.enemies, this.pickups);
                }
                
                // Always render
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Start the game when page loads
        window.addEventListener('load', () => {
            new FPSGame();
        });
    </script>
</body>
</html>