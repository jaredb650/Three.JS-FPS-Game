<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OVERPOWERED - Ultimate FPS Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            overflow: hidden;
        }
        
        canvas {
            display: block;
        }
        
        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: #fff;
            border-radius: 50%;
            opacity: 0.8;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.5);
        }
        
        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: #fff;
            opacity: 0.6;
        }
        
        .crosshair::before {
            width: 20px;
            height: 1px;
            top: 50%;
            left: -8px;
            transform: translateY(-50%);
        }
        
        .crosshair::after {
            width: 1px;
            height: 20px;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 99;
            font-family: 'Courier New', monospace;
        }
        
        .health-bar-container {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 200px;
            height: 20px;
            background: rgba(255, 0, 0, 0.3);
            border: 2px solid #fff;
            border-radius: 10px;
        }
        
        .health-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff0000 0%, #ffff00 50%, #00ff00 100%);
            border-radius: 8px;
            transition: width 0.3s ease;
        }
        
        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .ammo-display {
            position: fixed;
            bottom: 30px;
            right: 30px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            text-align: right;
        }
        
        .ammo-current {
            font-size: 36px;
            color: #00ff00;
        }
        
        .ammo-reserve {
            font-size: 18px;
            color: #ffff00;
        }
        
        .game-stats {
            position: fixed;
            top: 30px;
            left: 30px;
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .minimap {
            position: fixed;
            top: 30px;
            right: 30px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #fff;
            border-radius: 10px;
        }
        
        .damage-flash {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle, transparent 30%, rgba(255,0,0,0.3) 100%);
            opacity: 0;
            pointer-events: none;
            z-index: 98;
            transition: opacity 0.1s ease;
        }
        
        .kill-feed {
            position: fixed;
            top: 100px;
            right: 30px;
            width: 300px;
            color: white;
            font-size: 14px;
        }
        
        .kill-message {
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            margin: 2px 0;
            border-radius: 5px;
            animation: fadeInOut 4s ease;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateX(100px); }
            10% { opacity: 1; transform: translateX(0); }
            90% { opacity: 1; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(-100px); }
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        
        .fps-counter {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ff00;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            display: none;
        }
        
        .menu-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        .menu-title {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 30px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            color: #00ff00;
        }
        
        .menu-subtitle {
            font-size: 24px;
            margin-bottom: 40px;
            color: #ffff00;
        }
        
        .menu-instructions {
            font-size: 16px;
            text-align: center;
            line-height: 1.6;
            max-width: 600px;
        }
        
        .menu-controls {
            margin-top: 30px;
            font-size: 14px;
            text-align: center;
            color: #aaa;
        }
        
        .game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 0, 0, 0.9);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        .pause-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        .weapon-display {
            position: fixed;
            bottom: 0;
            right: 0;
            width: 300px;
            height: 200px;
            pointer-events: none;
            z-index: 50;
        }
        
        .reload-indicator {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffff00;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            display: none;
        }
        
        .debug-info {
            position: fixed;
            top: 200px;
            left: 30px;
            color: #00ff00;
            font-size: 12px;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
    </style>
</head>
<body>
    <!-- Crosshair -->
    <div class="crosshair"></div>
    
    <!-- HUD Elements -->
    <div class="hud">
        <!-- Health Bar -->
        <div class="health-bar-container">
            <div class="health-bar" id="healthBar"></div>
            <div class="health-text" id="healthText">100</div>
        </div>
        
        <!-- Ammo Display -->
        <div class="ammo-display">
            <div style="font-size: 14px; color: #aaa; margin-bottom: 5px;" id="weaponName">SMG</div>
            <div class="ammo-current" id="currentAmmo">30</div>
            <div class="ammo-reserve" id="reserveAmmo">90</div>
        </div>
        
        <!-- Game Stats -->
        <div class="game-stats">
            <div>Score: <span id="scoreDisplay">0</span></div>
            <div>Wave: <span id="waveDisplay">1</span></div>
            <div>Enemies: <span id="enemyCount">0</span></div>
        </div>
        
        <!-- Minimap -->
        <canvas class="minimap" id="minimap" width="150" height="150"></canvas>
        
        <!-- Kill Feed -->
        <div class="kill-feed" id="killFeed"></div>
        
        <!-- Damage Flash -->
        <div class="damage-flash" id="damageFlash"></div>
        
        <!-- FPS Counter -->
        <div class="fps-counter" id="fpsCounter">FPS: 60</div>
        
        <!-- Reload Indicator -->
        <div class="reload-indicator" id="reloadIndicator">RELOADING...</div>
        
        <!-- Debug Info -->
        <div class="debug-info" id="debugInfo"></div>
    </div>
    
    <!-- Splash Screen -->
    <div class="menu-screen" id="splashScreen" style="display: flex; cursor: pointer;">
        <div style="text-align: center;">
            <div class="menu-title" style="font-size: 72px; margin-bottom: 50px;">OVERPOWERED</div>
            <div class="menu-subtitle" style="font-size: 24px; color: #888; animation: pulse 2s infinite;">Click Anywhere</div>
        </div>
    </div>
    
    <!-- Menu Screen -->
    <div class="menu-screen" id="menuScreen" style="display: none;">
        <div class="menu-title">OVERPOWERED</div>
        <div class="menu-subtitle">Unleash Chaos. Survive the Onslaught.</div>
        <div class="menu-instructions">
            <p>Survive endless waves of enemies with an arsenal of devastating weapons!</p>
            <p>Chain kills to unlock PERKS and call in AIRSTRIKES for maximum destruction.</p>
            <p>Collect health and ammo pickups to stay in the fight.</p>
        </div>
        <div class="menu-controls">
            <p><strong>MOVEMENT:</strong></p>
            <p>WASD - Move | Mouse - Look | Space - Jump | Shift - Sprint</p>
            <p><strong>COMBAT:</strong></p>
            <p>Left Click - Fire | Right Click - Alt Fire/Zoom | R - Reload</p>
            <p><strong>WEAPONS:</strong></p>
            <p>1 - SMG | 2 - Shotgun | 3 - Rocket | 4 - Autocannon | 5 - Sword</p>
            <p><strong>STRIKES:</strong></p>
            <p>X - Airstrike | Z - Warthog Strike</p>
            <p><strong>SYSTEM:</strong></p>
            <p>ESC - Pause | F - FPS Counter | G - Debug</p>
        </div>
        <div class="menu-buttons">
            <button id="startButton" style="padding: 15px 30px; font-size: 20px; margin: 10px; background: #00ff00; color: #000; border: none; cursor: pointer;">START GAME</button>
            <button id="guideButton" style="padding: 15px 30px; font-size: 20px; margin: 10px; background: #ff6600; color: #fff; border: none; cursor: pointer;">GAME GUIDE</button>
        </div>
    </div>
    
    <!-- Game Over Screen -->
    <div class="game-over-screen" id="gameOverScreen">
        <div class="menu-title">GAME OVER</div>
        <div class="menu-subtitle">You have been eliminated</div>
        <div id="finalStats"></div>
        <div class="menu-controls">
            <p>Press SPACE to restart</p>
            <p>Press ESC to return to menu</p>
        </div>
    </div>
    
    <!-- Pause Screen -->
    <div class="pause-screen" id="pauseScreen">
        <div class="menu-title">PAUSED</div>
        <div class="menu-controls">
            <p>Press ESC to resume</p>
            <p>Press R to restart</p>
        </div>
    </div>
    
    <!-- Game Guide Screen -->
    <div class="guide-screen" id="guideScreen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); color: white; z-index: 2000; overflow-y: auto; padding: 20px;">
        <div style="max-width: 800px; margin: 0 auto;">
            <h1 style="color: #00ff00; text-align: center; font-size: 48px; margin-bottom: 30px;">OVERPOWERED - GAME GUIDE</h1>
            
            <h2 style="color: #ff6600; border-bottom: 2px solid #ff6600; padding-bottom: 5px;">PERKS SYSTEM</h2>
            <div style="margin-bottom: 30px;">
                <p><strong style="color: #ffff00;">BLOOD THIRST</strong> - 4 kills in 5 seconds</p>
                <p style="margin-left: 20px;">• Infinite ammo for 10 seconds</p>
                <p style="margin-left: 20px;">• 2x damage multiplier</p>
                
                <p><strong style="color: #ff0000;">HELLFIRE</strong> - 10 kills in 10 seconds</p>
                <p style="margin-left: 20px;">• All bullets become explosive for 5 seconds</p>
                <p style="margin-left: 20px;">• Instakill damage</p>
                
                <p><strong style="color: #ff00ff;">BERSERK</strong> - 15 kill combo</p>
                <p style="margin-left: 20px;">• 3x shotgun pellets</p>
                <p style="margin-left: 20px;">• Increased fire rate for 10 seconds</p>
                <p style="margin-left: 20px;">• 15% movement speed boost</p>
                
                <p><strong style="color: #00ffff;">SLOWMO</strong> - 3 headshots in 3 seconds</p>
                <p style="margin-left: 20px;">• Time slows to 25% speed</p>
                <p style="margin-left: 20px;">• You move at normal speed for 5 seconds</p>
                
                <p><strong style="color: #00ff00;">ADRENALINE</strong> - 3 sword kills in 3 seconds</p>
                <p style="margin-left: 20px;">• 10% speed boost per stack (up to 3 stacks)</p>
                <p style="margin-left: 20px;">• Each stack lasts 5 seconds</p>
                <p style="margin-left: 20px;">• New stacks refresh the timer</p>
            </div>
            
            <h2 style="color: #ff6600; border-bottom: 2px solid #ff6600; padding-bottom: 5px;">AIRSTRIKES</h2>
            <div style="margin-bottom: 30px;">
                <p><strong style="color: #ff6600;">AIRSTRIKE</strong> - 8 kill combo</p>
                <p style="margin-left: 20px;">• Press X to activate targeting</p>
                <p style="margin-left: 20px;">• Click to call in 15 rockets + 1 hellfire missile</p>
                <p style="margin-left: 20px;">• 30 second cooldown</p>
                
                <p><strong style="color: #00ff00;">WARTHOG STRIKE</strong> - 12 kill combo</p>
                <p style="margin-left: 20px;">• Press Z to activate targeting</p>
                <p style="margin-left: 20px;">• Click to call in A-10 Warthog gun run</p>
                <p style="margin-left: 20px;">• Fires 50 explosive 30mm shells</p>
                <p style="margin-left: 20px;">• 45 second cooldown</p>
            </div>
            
            <h2 style="color: #ff6600; border-bottom: 2px solid #ff6600; padding-bottom: 5px;">WEAPON TIPS</h2>
            <div style="margin-bottom: 30px;">
                <p><strong>SMG</strong> - High fire rate, reliable damage</p>
                <p><strong>SHOTGUN</strong> - Devastating at close range, headshots decapitate</p>
                <p><strong>ROCKET</strong> - Area damage, great for groups</p>
                <p><strong>AUTOCANNON</strong> - 30mm explosive rounds, right-click to zoom, headshots decapitate</p>
                <p><strong>SWORD</strong> - Combo attacks, right-click for heavy slam</p>
            </div>
            
            <h2 style="color: #ff6600; border-bottom: 2px solid #ff6600; padding-bottom: 5px;">SURVIVAL TIPS</h2>
            <div style="margin-bottom: 30px;">
                <p>• Chain headshots to trigger SLOWMO</p>
                <p>• Use sword for Adrenaline speed boost</p>
                <p>• Save airstrikes for overwhelming waves</p>
                <p>• Combo perks stack for devastating power</p>
                <p>• Keep moving - enemies spawn from all directions</p>
                <p>• Collect pickups quickly before they disappear</p>
            </div>
            
            <button id="closeGuideButton" style="display: block; margin: 30px auto; padding: 15px 30px; font-size: 20px; background: #ff0000; color: #fff; border: none; cursor: pointer;">CLOSE GUIDE</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Game States
        const GameState = {
            SPLASH: 'splash',
            MENU: 'menu',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'game_over'
        };

        // Audio Manager using HTML5 Audio
        class AudioManager {
            constructor() {
                this.sounds = {};
                this.volume = 0.5;
                this.globalPlaybackRate = 1.0;
                this.init();
            }

            init() {
                // Preload all sound files
                this.sounds = {
                    shoot: this.createSound('sounds/smg_fire.mp3', 0.3),
                    shotgun: this.createSound('sounds/shotgun_fire.mp3', 0.32), // Reduced by 20%
                    rocket: this.createSound('sounds/rocket_fire.mp3', 0.4),
                    rocketExplosion: this.createSound('sounds/rocket_explosion.mp3', 0.5),
                    swordSwing: this.createSound('sounds/sword_swing.mp3', 0.5),
                    swordHit1: this.createSound('sounds/sword_hit1.mp3', 0.6),
                    swordHit2: this.createSound('sounds/sword_hit2.mp3', 0.6),
                    swordSlam: this.createSound('sounds/sword_slam.mp3', 0.7),
                    perkAdrenaline: this.createSound('sounds/perk_adrenaline.mp3', 0.7),
                    reload: this.createSound('sounds/smg_reload.mp3', 0.4),
                    enemyHit: this.createSound('sounds/enemy_hit.mp3', 0.4),
                    enemyDie: this.createSound('sounds/enemy_die.mp3', 0.5),
                    enemyGrunt: this.createSound('sounds/enemy_grunt.mp3', 0.4),
                    enemyDeathGrunt: this.createSound('sounds/enemy_deathgrunt.mp3', 0.5),
                    enemyHeadshot: this.createSound('sounds/enemy_headshot.mp3', 0.75), // Increased by 25%
                    enemyHeadshot2: this.createSound('sounds/enemy_headshot2.mp3', 0.5625), // Reduced by 25% from 0.75
                    enemyHeadshot3: this.createSound('sounds/enemy_headshot3.mp3', 0.75),
                    enemyExplode: this.createSound('sounds/enemy_explode.mp3', 0.5),
                    enemyShoot: this.createSound('sounds/enemy_shoot.mp3', 0.15), // 50% quieter
                    bulletWhizz: this.createSound('sounds/bullet_whizz.mp3', 0.4),
                    perkBloodthirsty: this.createSound('sounds/perk_bloodthirsty.mp3', 0.7),
                    bloodthirstyShot: this.createSound('sounds/bloodthirsty_shot.mp3', 1.0), // Doubled from 0.5
                    perkHellfire: this.createSound('sounds/perk_hellfire.mp3', 0.8),
                    hellfireShot: this.createSound('sounds/hellfire_shot.mp3', 0.6),
                    hellfireBulletExplode: this.createSound('sounds/hellfirebullet_explode.mp3', 0.5),
                    hellfireRocketExplode: this.createSound('sounds/hellfirerocket_explode.mp3', 1.4), // Doubled volume
                    perkBerserk1: this.createSound('sounds/perk_berserk1.mp3', 0.8),
                    perkBerserk2: this.createSound('sounds/perk_berserk2.mp3', 1.2), // Increased by 50%
                    perkBerserk3: this.createSound('sounds/perk_berserk3.mp3', 0.8),
                    berserkShot: this.createSound('sounds/berserk_shot.mp3', 0.7),
                    perkSlowmo: this.createSound('sounds/perk_slowmo.mp3', 0.8),
                    perkAirstrike: this.createSound('sounds/perk_airstrike.mp3', 0.8),
                    walkieTalkieFire: this.createSound('sounds/walkietalkie_fire.mp3', 0.7),
                    airstrikeActivate: this.createSound('sounds/airstrike_activate.mp3', 1.0),
                    autocannon_fire: this.createSound('sounds/autocannon_fire.mp3', 1.05),
            autocannon_fire2: this.createSound('sounds/autocannon_fire2.wav', 0.79),
            autocannon_zoom: this.createSound('sounds/autocannon_zoom.wav', 0.7),
                    '30mmshell_flyby': this.createSound('sounds/30mmshell_flyby.mp3', 0.5),
                    menu_select: this.createSound('sounds/menu_select.wav', 0.7),
                    '30mmshell_explode': this.createSound('sounds/30mmshell_explode.mp3', 1.6),
                    warthog_flyby: this.createSound('sounds/warthog_flyby.wav', 0.8),  // A-10 Warthog flyby sound
                    playerHit: this.createSound('sounds/enemy_hit.mp3', 0.6), // Reuse enemy_hit for player
                    bulletHit1: this.createSound('sounds/bullet_hit1.mp3', 0.3),
                    bulletHit2: this.createSound('sounds/bullet_hit2.mp3', 0.3),
                    bulletHit3: this.createSound('sounds/bulltet_hit3.mp3', 0.3), // Note: typo in filename
                    bulletHit4: this.createSound('sounds/bullet_hit4.mp3', 0.3),
                    slide_ground: this.createSound('sounds/slide_ground.mp3', 0.5), // Slide sound effect
                    player_footstep1: this.createSound('sounds/player_footstep1.mp3', 0.2), // Dynamic footstep sounds
                    player_footstep2: this.createSound('sounds/player_footstep2.mp3', 0.2),
                    player_footstep3: this.createSound('sounds/player_footstep3.mp3', 0.2),
                    player_jump: this.createSound('sounds/player_jump.mp3', 0.3), // Jump sound
                    player_land: this.createSound('sounds/player_land.mp3', 0.3), // Landing sound
                    pickup: this.createSound(null, 0.3), // Keep procedural for pickup
                    footstep: this.createSound(null, 0.1) // Keep procedural for footsteps (fallback)
                };
                
                // Initialize Web Audio for procedural sounds
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                } catch (error) {
                    console.warn('Web Audio API not supported:', error);
                }
            }

            createSound(filepath, volume) {
                if (!filepath) return null;
                
                const audio = new Audio(filepath);
                audio.volume = volume * this.volume;
                audio.preload = 'auto';
                
                // Create multiple instances for overlapping sounds
                const instances = [audio];
                for (let i = 0; i < 3; i++) {
                    const clone = audio.cloneNode();
                    clone.volume = volume * this.volume;
                    instances.push(clone);
                }
                
                const self = this;
                return {
                    instances: instances,
                    currentIndex: 0,
                    filepath: filepath,
                    baseVolume: volume,  // Store the base volume for later use
                    play: function(startTime = 0) {
                        // Use round-robin to allow overlapping sounds
                        const instance = this.instances[this.currentIndex];
                        
                        // Skip silence at beginning of enemy_headshot3
                        if (this.filepath && this.filepath.includes('enemy_headshot3')) {
                            instance.currentTime = 1.0; // Skip first 1 second of silence
                        } else {
                            instance.currentTime = startTime;
                        }
                        
                        // Don't apply playback rate to perk_slowmo sound
                        if (this.filepath && this.filepath.includes('perk_slowmo')) {
                            instance.playbackRate = 1.0;
                        } else {
                            instance.playbackRate = self.globalPlaybackRate; // Apply global playback rate
                        }
                        instance.play().catch(e => console.log('Audio play failed:', e));
                        this.currentIndex = (this.currentIndex + 1) % this.instances.length;
                    }
                };
            }

            playPickup() {
                // Keep procedural pickup sound
                if (!this.context) return;
                
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.context.destination);
                
                oscillator.frequency.setValueAtTime(400, this.context.currentTime);
                oscillator.frequency.setValueAtTime(800, this.context.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(1200, this.context.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(this.volume * 0.3, this.context.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + 0.3);
                
                oscillator.start(this.context.currentTime);
                oscillator.stop(this.context.currentTime + 0.3);
            }

            playFootstep() {
                // Keep procedural footstep sound
                if (!this.context) return;
                
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                const filter = this.context.createBiquadFilter();
                
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.context.destination);
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(80, this.context.currentTime);
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, this.context.currentTime);
                
                gainNode.gain.setValueAtTime(this.volume * 0.1, this.context.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + 0.1);
                
                oscillator.start(this.context.currentTime);
                oscillator.stop(this.context.currentTime + 0.1);
            }

            play(soundName, position = null) {
                if (soundName === 'pickup') {
                    this.playPickup();
                } else if (soundName === 'footstep') {
                    this.playFootstep();
                } else if (soundName === 'bulletHit') {
                    // Play random bullet hit sound
                    this.playRandomBulletHit();
                } else if (this.sounds[soundName]) {
                    // If position is provided, adjust volume based on distance
                    if (position && this.playerPosition) {
                        const distance = position.distanceTo(this.playerPosition);
                        const maxDistance = 50; // Maximum hearing distance
                        const minDistance = 5;  // Full volume distance
                        
                        if (distance > maxDistance) return; // Too far to hear
                        
                        // Calculate volume falloff
                        let volumeMultiplier = 1.0;
                        if (distance > minDistance) {
                            volumeMultiplier = 1.0 - ((distance - minDistance) / (maxDistance - minDistance));
                            volumeMultiplier = Math.max(0.1, volumeMultiplier); // Minimum 10% volume
                        }
                        
                        // Play with adjusted volume
                        const sound = this.sounds[soundName];
                        if (sound) {
                            const instance = sound.instances[sound.currentIndex];
                            const baseVolume = sound.instances[0].volume / this.volume; // Get base volume
                            instance.volume = baseVolume * this.volume * volumeMultiplier;
                            instance.currentTime = 0;
                            instance.playbackRate = this.globalPlaybackRate;
                            instance.play().catch(e => console.log('Audio play failed:', e));
                            sound.currentIndex = (sound.currentIndex + 1) % sound.instances.length;
                        }
                    } else {
                        this.sounds[soundName].play();
                    }
                }
            }
            
            setPlayerPosition(position) {
                this.playerPosition = position;
            }
            
            playRandomBulletHit() {
                const hitNumber = Math.floor(Math.random() * 4) + 1; // Random 1-4
                const soundName = `bulletHit${hitNumber}`;
                if (this.sounds[soundName]) {
                    this.sounds[soundName].play();
                }
            }
            
            setGlobalPlaybackRate(rate) {
                this.globalPlaybackRate = rate;
                // Update all currently playing sounds
                for (const soundName in this.sounds) {
                    if (this.sounds[soundName] && this.sounds[soundName].instances) {
                        this.sounds[soundName].instances.forEach(instance => {
                            instance.playbackRate = rate;
                        });
                    }
                }
            }
        }

        // Soundtrack Manager for background music
        class SoundtrackManager {
            constructor() {
                this.currentTrack = null;
                this.currentState = 'menu'; // menu, easy, hard
                this.volume = 0.3; // Background music should be quieter
                this.hasStarted = false; // Track if music has ever started
                
                // Define track lists for each state
                this.tracks = {
                    menu: [
                        'soundtrack/menu/15. The Acolyte — Neurotoxin.flac'
                    ],
                    easy: [
                        'soundtrack/easy/01-bad_boy_pete-who_is_better.mp3',
                        'soundtrack/easy/01-grady_g-turn_the_bass_up_(original_mix).mp3',
                        'soundtrack/easy/01-minor_dott_and_metal_ed-enter_the_darkness__d.a.v.e._the_drummers_acid_remix.mp3',
                        'soundtrack/easy/03-bad_boy_pete-hard_roller_darkness.mp3',
                        'soundtrack/easy/Bad Boy Pete - Tougher Than Tough (Original Mix).mp3',
                        'soundtrack/easy/DOGMA ( UK ) - Geordie Stomp (Original Mix).mp3',
                        'soundtrack/easy/Mortal Sins - Banshee (Original Mix).mp3',
                        'soundtrack/easy/Mortal Sins - Gunfight (Original Mix).mp3',
                        'soundtrack/easy/Mortal Sins - I Will Find U (Original Mix).mp3',
                        'soundtrack/easy/Mortal Sins - Nightshift (Original Mix).mp3',
                        'soundtrack/easy/Mortal Sins - Pandemonium (Original Mix).mp3',
                        'soundtrack/easy/Mortal Sins - Poltergeist (Original Mix).mp3',
                        'soundtrack/easy/Various - Tense Trax #02 - 02 - Bad Boy Pete - My Pain Is Forever.mp3'
                    ],
                    hard: [
                        'soundtrack/hard/09. Some More.mp3',
                        'soundtrack/hard/Alek Szahala - Balag Lamarà.mp3',
                        'soundtrack/hard/Alek Szahala - Caballo.mp3',
                        'soundtrack/hard/Alek Szahala - Invitation.mp3',
                        'soundtrack/hard/Alek Szahala - Unicorn Grove.mp3',
                        'soundtrack/hard/Alek_Szahala_-_Freezing_Clouds.wav',
                        'soundtrack/hard/Are Am Eye Kronos Remix.mp3',
                        'soundtrack/hard/HDIZE1043_2009_06_23_Hybridize_Substanced_-_Freeform_Mercury_Mastered_320k_44k_mp3.mp3',
                        'soundtrack/hard/Hollow (Meka Remaster).wav',
                        'soundtrack/hard/Mirage(Meka Remaster).wav',
                        'soundtrack/hard/Mortality(Meka Remaster).wav'
                    ]
                };
                
                // Track history to avoid immediate repeats when possible
                this.recentlyPlayed = {
                    menu: [],
                    easy: [],
                    hard: []
                };
            }
            
            playRandomTrack(state) {
                // Stop current track if playing
                if (this.currentTrack) {
                    this.currentTrack.pause();
                    this.currentTrack.currentTime = 0;
                    this.currentTrack.removeEventListener('ended', this.onTrackEnded);
                }
                
                // Get track list for current state
                const trackList = this.tracks[state];
                if (!trackList || trackList.length === 0) {
                    console.warn(`No tracks available for state: ${state}`);
                    return;
                }
                
                // Select a random track, avoiding recent plays if possible
                let selectedTrack;
                const recentList = this.recentlyPlayed[state];
                
                if (trackList.length === 1) {
                    // Only one track, play it
                    selectedTrack = trackList[0];
                } else if (recentList.length >= trackList.length - 1) {
                    // All tracks recently played, clear history and pick random
                    this.recentlyPlayed[state] = [];
                    selectedTrack = trackList[Math.floor(Math.random() * trackList.length)];
                } else {
                    // Pick a track that hasn't been played recently
                    const availableTracks = trackList.filter(track => !recentList.includes(track));
                    selectedTrack = availableTracks[Math.floor(Math.random() * availableTracks.length)];
                }
                
                // Add to recently played
                recentList.push(selectedTrack);
                if (recentList.length > Math.floor(trackList.length / 2)) {
                    recentList.shift(); // Keep only half the tracks in history
                }
                
                // Create and play the track
                this.currentTrack = new Audio(selectedTrack);
                this.currentTrack.volume = this.volume;
                this.currentState = state;
                
                // Add ended event listener
                this.onTrackEnded = () => {
                    this.playRandomTrack(this.currentState);
                };
                this.currentTrack.addEventListener('ended', this.onTrackEnded);
                
                // Play the track
                this.currentTrack.play().catch(error => {
                    console.warn('Failed to play track:', error);
                });
                
                console.log(`Playing: ${selectedTrack.split('/').pop()} (${state} music)`);
            }
            
            switchToMenu() {
                this.hasStarted = true;
                this.playRandomTrack('menu');
            }
            
            switchToEasy() {
                this.hasStarted = true;
                this.playRandomTrack('easy');
            }
            
            switchToHard() {
                this.hasStarted = true;
                this.playRandomTrack('hard');
            }
            
            startMenuMusicIfNeeded() {
                if (!this.hasStarted) {
                    this.hasStarted = true;
                    this.playRandomTrack('menu');
                }
            }
            
            stop() {
                if (this.currentTrack) {
                    this.currentTrack.pause();
                    this.currentTrack.currentTime = 0;
                    this.currentTrack.removeEventListener('ended', this.onTrackEnded);
                    this.currentTrack = null;
                }
            }
            
            setVolume(volume) {
                this.volume = Math.max(0, Math.min(1, volume));
                if (this.currentTrack) {
                    this.currentTrack.volume = this.volume;
                }
            }
            
            pause() {
                if (this.currentTrack) {
                    this.currentTrack.pause();
                }
            }
            
            resume() {
                if (this.currentTrack) {
                    this.currentTrack.play().catch(error => {
                        console.warn('Failed to resume track:', error);
                    });
                }
            }
        }

        // Object Pool for performance optimization
        class ObjectPool {
            constructor(createFn, resetFn, initialSize = 50) {
                this.createFn = createFn;
                this.resetFn = resetFn;
                this.pool = [];
                this.active = [];
                
                // Pre-populate pool
                for (let i = 0; i < initialSize; i++) {
                    this.pool.push(this.createFn());
                }
            }

            get() {
                let obj = this.pool.pop();
                if (!obj) {
                    obj = this.createFn();
                }
                this.active.push(obj);
                return obj;
            }

            release(obj) {
                const index = this.active.indexOf(obj);
                if (index > -1) {
                    this.active.splice(index, 1);
                    this.resetFn(obj);
                    this.pool.push(obj);
                }
            }

            releaseAll() {
                while (this.active.length > 0) {
                    this.release(this.active[0]);
                }
            }
        }

        // Bullet class
        class Bullet {
            constructor(scene, particleSystem) {
                this.scene = scene;
                this.particleSystem = particleSystem; // Reference to particle system for trails
                this.mesh = null;
                this.velocity = new THREE.Vector3();
                this.damage = 25;
                this.speed = 100;
                this.lifetime = 5; // seconds
                this.age = 0;
                this.active = false;
                this.hasWhizzed = false; // Track if whizz sound has played
                this.isEnemyBullet = false; // Track if this is an enemy bullet
                this.isRocket = false; // Track if this is a rocket
                this.blastRadius = 0; // Explosion radius for rockets
                this.isHellfireBullet = false; // Track if this is a Hellfire bullet
                this.isHellfireRocket = false; // Track if this is a Hellfire rocket
                this.isAirstrikeRocket = false; // Track if this is an airstrike rocket
                this.lastSmokeTime = 0; // Track last smoke particle spawn
                this.lastSmokeParticleTime = 0; // Track smoke particles separately
                this.smokeInterval = 0.06; // Spawn rings every 60ms for better spacing
                
                // 30mm Shell properties
                this.is30mmShell = false;
                this.shellBlastRadius = 5; // 50% of rocket's radius
                this.flybySoundPlaying = false;
                
                this.createMesh();
            }

            createMesh() {
                const geometry = new THREE.SphereGeometry(0.05, 4, 4);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    transparent: false
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.visible = false;
                
                // Create separate rocket mesh
                const rocketGeometry = new THREE.CylinderGeometry(0.08, 0.06, 0.3, 6);
                const rocketMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff6600,
                    transparent: false
                });
                this.rocketMesh = new THREE.Mesh(rocketGeometry, rocketMaterial);
                this.rocketMesh.visible = false;
                this.scene.add(this.rocketMesh);
                
                // Create 30mm shell mesh (elongated bright yellow beam)
                const shellGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1.5, 6); // Original radius restored
                const shellMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 2
                });
                this.shellMesh = new THREE.Mesh(shellGeometry, shellMaterial);
                this.shellMesh.visible = false;
                this.scene.add(this.shellMesh);
                
                // Create white cone trail that follows the shell
                const coneGeometry = new THREE.ConeGeometry(0.3, 1.2, 8);
                const coneMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.15,
                    depthWrite: false
                });
                this.shellCone = new THREE.Mesh(coneGeometry, coneMaterial);
                this.shellCone.visible = false;
                // No initial rotation needed - will be oriented during flight
                this.scene.add(this.shellCone);
            }

            fire(position, direction) {
                this.age = 0;
                this.active = true;
                
                if (this.is30mmShell && this.shellMesh) {
                    // Use shell mesh for 30mm shells
                    this.shellMesh.position.copy(position);
                    this.shellMesh.visible = true;
                    if (this.shellGlow) {
                        this.shellGlow.visible = true;
                    }
                    if (this.shellCone) {
                        this.shellCone.visible = true;
                    }
                    this.mesh.visible = false;
                    if (this.rocketMesh) this.rocketMesh.visible = false;
                    
                    // Orient shell in direction of travel
                    this.shellMesh.lookAt(position.clone().add(direction));
                    this.shellMesh.rotateX(Math.PI / 2);
                    
                    // Ensure shell mesh is in scene
                    if (!this.scene.getObjectById(this.shellMesh.id)) {
                        this.scene.add(this.shellMesh);
                    }
                } else if (this.isRocket && this.rocketMesh) {
                    // Use rocket mesh for rockets
                    this.rocketMesh.position.copy(position);
                    this.rocketMesh.visible = true;
                    this.mesh.visible = false;
                    if (this.shellMesh) this.shellMesh.visible = false;
                    
                    // Orient rocket in direction of travel
                    this.rocketMesh.lookAt(position.clone().add(direction));
                    this.rocketMesh.rotateX(Math.PI / 2);
                    
                    // Ensure rocket mesh is in scene
                    if (!this.scene.getObjectById(this.rocketMesh.id)) {
                        this.scene.add(this.rocketMesh);
                    }
                } else {
                    // Use normal bullet mesh
                    this.mesh.position.copy(position);
                    this.mesh.visible = true;
                    if (this.rocketMesh) this.rocketMesh.visible = false;
                    if (this.shellMesh) this.shellMesh.visible = false;
                }
                
                this.velocity.copy(direction).multiplyScalar(this.speed);
                
                // Ensure mesh is in scene (for non-rocket bullets)
                if (!this.isRocket && !this.is30mmShell && !this.scene.getObjectById(this.mesh.id)) {
                    this.scene.add(this.mesh);
                }
            }

            update(deltaTime) {
                if (!this.active) return false;

                this.age += deltaTime;
                if (this.age >= this.lifetime) {
                    this.deactivate();
                    return false;
                }

                // Store previous position for interpolation (used for fast projectiles)
                if (this.is30mmShell && this.shellMesh) {
                    this.previousPosition = this.shellMesh.position.clone();
                } else if (this.isRocket && this.rocketMesh) {
                    this.previousPosition = this.rocketMesh.position.clone();
                } else if (this.mesh) {
                    this.previousPosition = this.mesh.position.clone();
                }

                // Update appropriate mesh position
                if (this.is30mmShell && this.shellMesh) {
                    this.shellMesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                    
                    // Update cone position to follow shell
                    if (this.shellCone) {
                        this.shellCone.position.copy(this.shellMesh.position);
                        // Position cone behind the shell (adjusted for larger cone)
                        const offset = this.velocity.clone().normalize().multiplyScalar(-0.8);
                        this.shellCone.position.add(offset);
                        // Orient cone to point in direction of travel
                        // Cone points up by default, so we look in the direction of travel
                        this.shellCone.lookAt(this.shellMesh.position.clone().add(this.velocity));
                        this.shellCone.rotateX(Math.PI / 2);
                    }
                    
                    // Matrix-style wireframe ring trail and smoke
                    const now = performance.now() / 1000;
                    
                    // Rings spawn at normal interval
                    if (this.particleSystem && this.particleSystem.createWireframeRing && now - this.lastSmokeTime > this.smokeInterval) {
                        const trailPos = this.shellMesh.position.clone();
                        
                        // Add offset behind the shell
                        const trailOffset = this.velocity.clone().normalize().multiplyScalar(-0.2);
                        trailPos.add(trailOffset);
                        
                        // Create expanding wireframe ring - start yellow
                        this.particleSystem.createWireframeRing(trailPos, this.velocity, 0xffff00, 0.005, 0.1);
                        
                        this.lastSmokeTime = now;
                    }
                    
                    // Smoke particles spawn twice as fast
                    if (this.particleSystem && this.particleSystem.createSmokeParticle && now - this.lastSmokeParticleTime > (this.smokeInterval / 2)) {
                        const trailPos = this.shellMesh.position.clone();
                        const trailOffset = this.velocity.clone().normalize().multiplyScalar(-0.3);
                        trailPos.add(trailOffset);
                        
                        // Add small smoke particle trail
                        this.particleSystem.createSmokeParticle(trailPos, 0xaaaaaa, 0.1, 2.0);
                        
                        this.lastSmokeParticleTime = now;
                    }
                } else if (this.isRocket && this.rocketMesh) {
                    this.rocketMesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                    
                    // Add smoke trail for rocket
                    const now = performance.now() / 1000;
                    if (this.particleSystem && this.particleSystem.createSmokeParticle && now - this.lastSmokeTime > this.smokeInterval) {
                        const smokePos = this.rocketMesh.position.clone();
                        
                        // Add some offset behind the rocket based on velocity
                        const trailOffset = this.velocity.clone().normalize().multiplyScalar(-0.3);
                        smokePos.add(trailOffset);
                        
                        // Create smoke particle with size based on rocket type
                        if (this.isAirstrikeRocket) {
                            // Airstrike rockets have big dramatic gray smoke (like regular but bigger)
                            this.particleSystem.createSmokeParticle(smokePos, 0xcccccc, 1.0, 1.8);
                        } else if (this.isHellfireRocket) {
                            // Hellfire rockets have small fiery orange/red smoke
                            this.particleSystem.createSmokeParticle(smokePos, 0xff6600, 0.4, 1.2);
                            // Add some small fire particles too
                            if (Math.random() < 0.5) {
                                this.particleSystem.createSmokeParticle(smokePos, 0xffaa00, 0.3, 0.8);
                            }
                        } else {
                            // Regular rocket launcher rockets have small subtle gray smoke  
                            this.particleSystem.createSmokeParticle(smokePos, 0xcccccc, 0.35, 1.0);
                        }
                        
                        this.lastSmokeTime = now;
                    }
                } else {
                    this.mesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                }
                return true;
            }

            deactivate() {
                this.active = false;
                this.mesh.visible = false;
                if (this.rocketMesh) {
                    this.rocketMesh.visible = false;
                }
                if (this.shellMesh) {
                    this.shellMesh.visible = false;
                    if (this.shellGlow) {
                        this.shellGlow.visible = false;
                    }
                    if (this.shellCone) {
                        this.shellCone.visible = false;
                    }
                }
                // Stop flyby sound if playing
                if (this.flybySoundPlaying) {
                    // Sound will be handled by AudioManager
                    this.flybySoundPlaying = false;
                }
            }

            reset() {
                this.deactivate();
                this.age = 0;
                this.hasWhizzed = false;
                this.isEnemyBullet = false;
                this.isRocket = false;
                this.blastRadius = 0;
                this.speed = 100; // Reset to default speed
                this.isHellfireBullet = false; // Reset Hellfire bullet flag
                this.isHellfireRocket = false; // Reset Hellfire rocket flag
                this.isAirstrikeRocket = false; // Reset airstrike rocket flag
                this.lastSmokeTime = 0; // Reset smoke timer
                this.lastSmokeParticleTime = 0; // Reset smoke particle timer
                this.is30mmShell = false; // Reset 30mm shell flag
                this.flybySoundPlaying = false;
                this.previousPosition = null; // Reset position tracking
            }
        }

        // Particle System
        class ParticleSystem {
            constructor(scene) {
                this.scene = scene;
                this.particles = [];
                this.smokeParticles = []; // Track smoke particles separately
            }
            
            createWireframeRing(position, direction, color = 0xffffff, initialRadius = 0.005, lifetime = 0.1) {
                // Limit particles for performance
                if (this.smokeParticles.length > 50) {
                    // Remove oldest ring particle
                    for (let i = 0; i < this.smokeParticles.length; i++) {
                        if (this.smokeParticles[i].isRing) {
                            const oldSmoke = this.smokeParticles.splice(i, 1)[0];
                            if (oldSmoke && oldSmoke.mesh) {
                                this.scene.remove(oldSmoke.mesh);
                                oldSmoke.mesh.geometry.dispose();
                                oldSmoke.mesh.material.dispose();
                            }
                            break;
                        }
                    }
                }
                
                // Use simple ring for better performance - extremely thin ring with large hole
                const geometry = new THREE.RingGeometry(initialRadius * 0.9, initialRadius * 1.0, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.5,
                    depthWrite: false,
                    side: THREE.DoubleSide
                });
                
                const ring = new THREE.Mesh(geometry, material);
                ring.position.copy(position);
                
                // Orient the ring perpendicular to the bullet's direction
                if (direction) {
                    const normalizedDir = direction.clone().normalize();
                    ring.lookAt(position.clone().add(normalizedDir));
                }
                
                this.scene.add(ring);
                
                // Store particle data for animation
                this.smokeParticles.push({
                    mesh: ring,
                    age: 0,
                    lifetime: lifetime,
                    velocity: new THREE.Vector3(0, 0, 0),
                    initialRadius: initialRadius,
                    expansionRate: 25.0, // Reduced expansion rate
                    isRing: true // Flag to identify ring particles
                });
            }
            
            createSmokeParticle(position, color = 0x888888, size = 0.5, lifetime = 1.0) {
                // Use a simple box geometry for better visibility
                const geometry = new THREE.BoxGeometry(size, size, size);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.6,
                    depthWrite: false // Prevent z-fighting
                });
                
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                
                // Add some random offset for variation
                particle.position.x += (Math.random() - 0.5) * 0.1;
                particle.position.y += (Math.random() - 0.5) * 0.1;
                particle.position.z += (Math.random() - 0.5) * 0.1;
                
                // Smoke rises and expands
                const smokeData = {
                    mesh: particle,
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        Math.random() * 1 + 0.5, // Upward velocity
                        (Math.random() - 0.5) * 0.5
                    ),
                    lifetime: lifetime,
                    age: 0,
                    initialSize: size,
                    expansionRate: 1.5 // How fast the smoke expands
                };
                
                this.scene.add(particle);
                this.smokeParticles.push(smokeData);
            }
            
            updateSmokeParticles(deltaTime) {
                // Early exit if no smoke particles
                if (this.smokeParticles.length === 0) return;
                
                for (let i = this.smokeParticles.length - 1; i >= 0; i--) {
                    const smoke = this.smokeParticles[i];
                    smoke.age += deltaTime;
                    
                    if (smoke.age >= smoke.lifetime) {
                        // Remove expired smoke
                        this.scene.remove(smoke.mesh);
                        smoke.mesh.geometry.dispose();
                        smoke.mesh.material.dispose();
                        this.smokeParticles.splice(i, 1);
                        continue;
                    }
                    
                    // Handle wireframe rings differently
                    if (smoke.isRing) {
                        // Rings don't move, just expand and fade
                        const ageRatio = smoke.age / smoke.lifetime;
                        // Use exponential growth for more dramatic expansion
                        const scale = Math.pow(1 + ageRatio * smoke.expansionRate, 1.5);
                        // Scale uniformly to maintain perfect circle
                        smoke.mesh.scale.set(scale, scale, scale);
                        
                        // Color transition from yellow to white
                        const r = 1.0;
                        const g = 1.0;
                        const b = ageRatio; // Starts at 0 (yellow) and goes to 1 (white)
                        smoke.mesh.material.color.setRGB(r, g, b);
                        
                        // Keep rings visible longer, fade only in last 20% of lifetime
                        const fadeStart = 0.8;
                        if (ageRatio < fadeStart) {
                            smoke.mesh.material.opacity = 0.5;
                        } else {
                            const fadeRatio = (ageRatio - fadeStart) / (1 - fadeStart);
                            smoke.mesh.material.opacity = 0.5 * (1 - fadeRatio);
                        }
                        
                        // No rotation - keep rings consistent and circular
                    } else {
                        // Regular smoke behavior
                        // Update position
                        smoke.mesh.position.add(smoke.velocity.clone().multiplyScalar(deltaTime));
                        
                        // Slow down over time
                        smoke.velocity.multiplyScalar(0.98);
                        
                        // Expand and fade
                        const ageRatio = smoke.age / smoke.lifetime;
                        const scale = 1 + ageRatio * smoke.expansionRate;
                        smoke.mesh.scale.set(scale, scale, scale);
                        smoke.mesh.material.opacity = 0.6 * (1 - ageRatio); // Fade out
                    }
                }
            }

            createExplosion(position, color = 0xff4444, count = 20, isHellfire = false) {
                for (let i = 0; i < count; i++) {
                    // Make hellfire particles bigger and faster
                    const sizeMultiplier = isHellfire ? 2.5 : 1;
                    const speedMultiplier = isHellfire ? 1.8 : 1;
                    const lifeMultiplier = isHellfire ? 1.5 : 1;
                    
                    // Vary particle sizes more for hellfire
                    const baseSize = isHellfire ? 
                        (0.1 + Math.random() * 0.3) : // 0.1-0.4 for hellfire
                        0.1; // consistent 0.1 for normal
                    
                    const particle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(baseSize * sizeMultiplier, 4, 4),
                            new THREE.MeshBasicMaterial({ 
                                color: color,
                                emissive: isHellfire ? color : 0x000000,
                                emissiveIntensity: isHellfire ? 0.5 : 0,
                                transparent: isHellfire,
                                opacity: isHellfire ? 0.9 : 1
                            })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 10 * speedMultiplier,
                            Math.random() * 10 * speedMultiplier,
                            (Math.random() - 0.5) * 10 * speedMultiplier
                        ),
                        life: 1.0 * lifeMultiplier,
                        maxLife: 1.0 * lifeMultiplier,
                        isHellfire: isHellfire
                    };
                    
                    particle.mesh.position.copy(position);
                    this.scene.add(particle.mesh);
                    this.particles.push(particle);
                }
            }
            
            createShockwave(position, isHellfire = false, sizeMult = 1.0) {
                // Create expanding sphere shockwave - white blast wave
                const shockwaveGeometry = new THREE.SphereGeometry(0.5, 16, 8);
                const shockwaveMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff, // White for realistic pressure wave
                    transparent: true,
                    opacity: 0.25, // Start at 25% opacity
                    side: THREE.DoubleSide,
                    wireframe: true
                });
                
                const shockwave = {
                    mesh: new THREE.Mesh(shockwaveGeometry, shockwaveMaterial),
                    expandSpeed: isHellfire ? 200 : 120 * sizeMult, // Scale speed with size
                    maxSize: isHellfire ? 60 : 15 * sizeMult, // Scale max size
                    currentSize: 0.5,
                    life: isHellfire ? 0.15 : 0.1, // Slightly longer for bigger shockwave
                    maxLife: isHellfire ? 0.15 : 0.1,
                    isShockwave: true
                };
                
                shockwave.mesh.position.copy(position);
                this.scene.add(shockwave.mesh);
                this.particles.push(shockwave);
            }
            
            createSpark(position, velocity, color = 0xffff00) {
                // Create a single spark particle that flies out with velocity
                const particle = {
                    mesh: new THREE.Mesh(
                        new THREE.BoxGeometry(0.05, 0.05, 0.05),
                        new THREE.MeshBasicMaterial({ 
                            color: color,
                            emissive: color,
                            emissiveIntensity: 2
                        })
                    ),
                    velocity: velocity,
                    life: 0.5,
                    maxLife: 0.5,
                    gravity: -20 // Sparks fall with gravity
                };
                
                particle.mesh.position.copy(position);
                this.scene.add(particle.mesh);
                this.particles.push(particle);
            }

            createMuzzleFlash(position, direction) {
                const flash = new THREE.Mesh(
                    new THREE.ConeGeometry(0.2, 1, 4),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xffaa00,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                
                flash.position.copy(position);
                flash.lookAt(position.clone().add(direction));
                this.scene.add(flash);
                
                setTimeout(() => {
                    this.scene.remove(flash);
                    flash.geometry.dispose();
                    flash.material.dispose();
                }, 100);
            }
            
            createBloodJet(position, direction) {
                // Create a directional blood spray effect
                const jetParticles = 30;
                const baseSpeed = 15;
                
                for (let i = 0; i < jetParticles; i++) {
                    const particle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(0.08 + Math.random() * 0.12, 4, 4),
                            new THREE.MeshBasicMaterial({ color: 0xcc0000 })
                        ),
                        velocity: new THREE.Vector3(
                            direction.x * baseSpeed + (Math.random() - 0.5) * 3,
                            direction.y * baseSpeed + Math.random() * 5,
                            direction.z * baseSpeed + (Math.random() - 0.5) * 3
                        ),
                        life: 0.8 + Math.random() * 0.4,
                        maxLife: 1.2,
                        gravity: -15 // Blood drops fall
                    };
                    
                    particle.mesh.position.copy(position);
                    this.scene.add(particle.mesh);
                    this.particles.push(particle);
                }
                
                // Add some mist particles for spray effect
                for (let i = 0; i < 10; i++) {
                    const mist = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(0.15, 3, 3),
                            new THREE.MeshBasicMaterial({ 
                                color: 0xff4444,
                                transparent: true,
                                opacity: 0.6
                            })
                        ),
                        velocity: new THREE.Vector3(
                            direction.x * (baseSpeed * 0.5) + (Math.random() - 0.5) * 5,
                            direction.y * (baseSpeed * 0.5) + Math.random() * 3,
                            direction.z * (baseSpeed * 0.5) + (Math.random() - 0.5) * 5
                        ),
                        life: 0.4,
                        maxLife: 0.4,
                        isMist: true
                    };
                    
                    mist.mesh.position.copy(safePosition);
                    this.scene.add(mist.mesh);
                    this.particles.push(mist);
                }
            }
            
            createMassiveBloodSpurt(position, direction) {
                // Massive blood spurt for dismemberment
                if (!position || position.x === undefined) return;
                
                const spurtParticles = 40; // Many particles for dramatic effect
                const baseSpeed = 20; // Fast initial speed
                
                for (let i = 0; i < spurtParticles; i++) {
                    // Vary particle sizes - mix of droplets and chunks
                    const particleSize = i < 10 ? 
                        0.15 + Math.random() * 0.15 : // First 10 are larger chunks
                        0.08 + Math.random() * 0.08;   // Rest are smaller droplets
                    
                    const particle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(particleSize, 4, 3),
                            new THREE.MeshBasicMaterial({ 
                                color: i < 5 ? 0xff0000 : 0xcc0000, // Some bright red for intensity
                                transparent: true,
                                opacity: 0.9,
                                emissive: 0x660000,
                                emissiveIntensity: 0.3
                            })
                        ),
                        velocity: new THREE.Vector3(
                            direction.x * baseSpeed + (Math.random() - 0.5) * 8,
                            direction.y * baseSpeed + Math.random() * 10,
                            direction.z * baseSpeed + (Math.random() - 0.5) * 8
                        ),
                        life: 1.0 + Math.random() * 1.0,
                        maxLife: 2.0,
                        gravity: -20, // Heavy gravity for arc effect
                        isBlood: true
                    };
                    
                    // Add some particles with extra velocity for spray effect
                    if (i < 5) {
                        particle.velocity.multiplyScalar(1.5);
                    }
                    
                    particle.mesh.position.copy(position);
                    // Slight position variation for volume
                    particle.mesh.position.add(new THREE.Vector3(
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3
                    ));
                    
                    this.scene.add(particle.mesh);
                    this.particles.push(particle);
                }
            }
            
            createBloodDroplet(position, initialVelocity = null) {
                // Enhanced blood droplet for dramatic trails
                if (!position || position.x === undefined) return;
                
                // Vary droplet size for more interesting trails
                const size = 0.08 + Math.random() * 0.12; // Larger droplets
                
                const droplet = {
                    mesh: new THREE.Mesh(
                        new THREE.SphereGeometry(size, 4, 3), // More segments for smoother appearance
                        new THREE.MeshBasicMaterial({
                            color: Math.random() < 0.3 ? 0xff0000 : 0xcc0000, // Some brighter red
                            transparent: true,
                            opacity: 0.95,
                            emissive: 0x440000,
                            emissiveIntensity: 0.2
                        })
                    ),
                    velocity: initialVelocity || new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 1,
                        (Math.random() - 0.5) * 2
                    ),
                    life: 1.5 + Math.random() * 0.5,  // Longer lasting (1.5-2 seconds)
                    maxLife: 2.0,
                    gravity: -12,  // Slightly less gravity for more float time
                    isBlood: true
                };
                
                droplet.mesh.position.copy(position);
                this.scene.add(droplet.mesh);
                this.particles.push(droplet);
            }
            
            createLingeringBloodMist(position) {
                // Create a large, quickly dissipating blood cloud
                if (!position || position.x === undefined) return;
                
                const mistCount = 8;  // More particles for better cloud effect
                for (let i = 0; i < mistCount; i++) {
                    // Start closer together
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5
                    );
                    
                    // Use sprite for billboard effect (always faces camera)
                    const spriteMaterial = new THREE.SpriteMaterial({
                        color: Math.random() < 0.7 ? 0x990000 : 0x660000,
                        transparent: true,
                        opacity: 0.3,  // Much more transparent - never solid
                        fog: true
                    });
                    
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.scale.set(
                        0.5 + Math.random() * 0.3,  // Start smaller
                        0.5 + Math.random() * 0.3,
                        1
                    );
                    
                    // Calculate outward spread direction from center
                    const spreadDirection = new THREE.Vector3(
                        (Math.random() - 0.5),
                        (Math.random() - 0.5) * 0.5 + 0.2,  // Slight upward bias
                        (Math.random() - 0.5)
                    ).normalize();
                    
                    const mist = {
                        mesh: sprite,
                        velocity: spreadDirection.multiplyScalar(1.5 + Math.random() * 1.5),  // Slower spread (1.5-3 units/sec)
                        life: 1.5 + Math.random() * 1.5,  // Dissipate within 1.5-3 seconds
                        maxLife: 3.0,
                        isMist: true,
                        expandRate: 2.0,  // Less expansion - particles won't get huge
                        gravity: 0  // No gravity for mist - it floats
                    };
                    
                    mist.mesh.position.copy(position);
                    mist.mesh.position.add(offset);
                    this.scene.add(mist.mesh);
                    this.particles.push(mist);
                }
            }
            
            createHeadRemoval(position, forceDirection) {
                // Head splitting into large chunks - shotgun decapitation
                if (!position || position.x === undefined) {
                    console.warn('Invalid position for head removal');
                    return;
                }
                
                const safePos = position.clone();
                
                // Create 3 large head chunks
                for (let i = 0; i < 3; i++) {
                    // Large chunks to represent head pieces (25% smaller)
                    const gibSize = 0.26 + Math.random() * 0.11; // 0.26-0.37 units (was 0.35-0.5)
                    
                    // Use irregular geometry for chunks
                    let gibGeometry;
                    if (i === 0) {
                        // Front piece - slightly flattened sphere
                        gibGeometry = new THREE.SphereGeometry(gibSize, 4, 3);
                        gibGeometry.scale(1, 0.8, 0.7);
                    } else if (i === 1) {
                        // Side piece - elongated
                        gibGeometry = new THREE.BoxGeometry(gibSize * 0.8, gibSize * 1.2, gibSize * 0.6);
                    } else {
                        // Back piece - rounded
                        gibGeometry = new THREE.SphereGeometry(gibSize * 0.9, 3, 3);
                    }
                    
                    const gib = {
                        mesh: new THREE.Mesh(
                            gibGeometry,
                            new THREE.MeshBasicMaterial({ 
                                color: i === 0 ? 0xffaa88 : // Skin/skull piece
                                       i === 1 ? 0x992222 : // Dark red/brain
                                       0xcc0000,            // Blood/tissue
                                transparent: true,
                                opacity: 0.95
                            })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 6,  // Much slower (was 15)
                            Math.random() * 4 + 2,       // Less upward (was 10+5)
                            (Math.random() - 0.5) * 6    // Slower spread
                        ),
                        life: 3.0,  // Last longer since they're bigger
                        maxLife: 3.0,
                        gravity: -30,  // Heavier chunks
                        angularVelocity: new THREE.Vector3(  // Add tumbling
                            (Math.random() - 0.5) * 5,
                            (Math.random() - 0.5) * 5,
                            (Math.random() - 0.5) * 5
                        ),
                        isGiblet: true  // Use giblet physics for rotation
                    };
                    
                    // Add force from bullet direction (less than before)
                    if (forceDirection && forceDirection.x !== undefined) {
                        gib.velocity.add(forceDirection.clone().multiplyScalar(5)); // Reduced from 10
                    }
                    
                    gib.mesh.position.copy(safePos);
                    this.scene.add(gib.mesh);
                    this.particles.push(gib);
                }
                
                // Create blood mist from neck
                for (let i = 0; i < 5; i++) {
                    const mist = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(0.2 + Math.random() * 0.2, 3, 2),
                            new THREE.MeshBasicMaterial({ 
                                color: 0x660000,
                                transparent: true,
                                opacity: 0.6
                            })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 3,
                            Math.random() * 2 + 1,
                            (Math.random() - 0.5) * 3
                        ),
                        life: 0.6,
                        maxLife: 0.6,
                        isMist: true
                    };
                    
                    mist.mesh.position.copy(safePos);
                    this.scene.add(mist.mesh);
                    this.particles.push(mist);
                }
                
                // Create upward blood fountain effect
                this.createBloodJet(safePos, new THREE.Vector3(0, 1, 0));
            }
            
            createDismemberment(position, damageType = 'explosive', forceDirection = null) {
                // DISABLED - Causing crashes, using simple effects instead
                // Safety check for valid position
                if (!position || position.x === undefined || position.y === undefined || position.z === undefined) {
                    console.warn('Invalid position for dismemberment:', position);
                    return;
                }
                
                // Use simple but satisfying blood effects instead of complex dismemberment
                const safePosition = position.clone();
                
                // Create multiple blood explosions for impact
                this.createExplosion(safePosition, 0xcc0000, 25); // Red explosion
                this.createExplosion(safePosition, 0x880000, 15); // Dark red
                
                // Add directional blood spray
                if (forceDirection && forceDirection.x !== undefined) {
                    this.createBloodJet(safePosition, forceDirection);
                    // Create side sprays for more gore
                    const perpVector = new THREE.Vector3(-forceDirection.z, 0, forceDirection.x);
                    this.createBloodJet(safePosition, perpVector.normalize());
                }
                
                // Extra effects based on damage type
                if (damageType === 'explosive') {
                    // More explosions for explosive kills
                    setTimeout(() => this.createExplosion(safePosition, 0xff0000, 20), 50);
                } else if (damageType === 'headshot') {
                    // Extra blood jet upward for headshots
                    this.createBloodJet(safePosition, new THREE.Vector3(0, 1, 0));
                }
                
                return; // Skip all the complex dismemberment code below
                
                /* ORIGINAL DISMEMBERMENT CODE - DISABLED DUE TO CRASHES
                
                // Adjust particle counts based on damage type for more satisfying effects
                let gibletCount, bloodSplatterCount, mistCount;
                
                switch(damageType) {
                    case 'explosive':
                        gibletCount = 10 + Math.floor(Math.random() * 5);  // More giblets for explosions
                        bloodSplatterCount = 20;
                        mistCount = 10;
                        break;
                    case 'headshot':
                        gibletCount = 6 + Math.floor(Math.random() * 3);   // Fewer but more directed
                        bloodSplatterCount = 25;  // More blood for headshots
                        mistCount = 8;
                        break;
                    case 'melee':
                        gibletCount = 8 + Math.floor(Math.random() * 4);   // Chunky melee cuts
                        bloodSplatterCount = 15;
                        mistCount = 6;
                        break;
                    default:
                        gibletCount = 7 + Math.floor(Math.random() * 3);
                        bloodSplatterCount = 12;
                        mistCount = 5;
                }
                
                // Create giblets (body parts) with shared geometry for performance
                const sharedGeometries = {
                    small: new THREE.BoxGeometry(0.15, 0.15, 0.15),
                    medium: new THREE.SphereGeometry(0.2, 3, 2),
                    large: new THREE.BoxGeometry(0.25, 0.25, 0.2),
                    limb: new THREE.CylinderGeometry(0.08, 0.06, 0.4, 4)
                };
                
                for (let i = 0; i < gibletCount; i++) {
                    // Use shared geometry for performance
                    let geometry;
                    const gibletType = Math.random();
                    let scaleFactor = 0.8 + Math.random() * 0.4; // Vary size
                    
                    if (gibletType < 0.3) {
                        geometry = sharedGeometries.small;
                    } else if (gibletType < 0.6) {
                        geometry = sharedGeometries.medium;
                    } else if (gibletType < 0.85) {
                        geometry = sharedGeometries.limb;
                        scaleFactor *= 1.2; // Make limbs slightly bigger
                    } else {
                        geometry = sharedGeometries.large;
                    }
                    
                    // Vary colors between red flesh and darker meat
                    const gibletColor = Math.random() < 0.7 ? 
                        new THREE.Color(0.8 + Math.random() * 0.2, 0, 0) : // Red flesh
                        new THREE.Color(0.4 + Math.random() * 0.2, 0, 0); // Dark meat
                    
                    // Create material with slight variation
                    const material = new THREE.MeshBasicMaterial({ 
                        color: gibletColor,
                        opacity: 0.95,
                        transparent: true
                    });
                    
                    const giblet = {
                        mesh: new THREE.Mesh(geometry, material),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 25,  // Increased velocity
                            Math.random() * 20 + 8,      // More upward force
                            (Math.random() - 0.5) * 25
                        ),
                        angularVelocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 15,  // More spin
                            (Math.random() - 0.5) * 15,
                            (Math.random() - 0.5) * 15
                        ),
                        life: 2.5 + Math.random() * 1.5, // Slightly shorter lifetime
                        maxLife: 4.0,
                        gravity: -30,  // Stronger gravity
                        isGiblet: true,
                        bounces: 0,
                        maxBounces: 2 + Math.floor(Math.random() * 2),
                        scaleFactor: scaleFactor
                    };
                    
                    // Apply force direction if provided (from explosions, etc)
                    if (forceDirection && forceDirection.x !== undefined) {
                        const safeForce = forceDirection.clone();
                        const forceMultiplier = damageType === 'explosive' ? 30 : 20;
                        giblet.velocity.add(safeForce.multiplyScalar(forceMultiplier + Math.random() * 10));
                    }
                    
                    // Set scale
                    giblet.mesh.scale.setScalar(scaleFactor);
                    
                    // Add some rotational force for more realistic tumbling
                    giblet.mesh.rotation.set(
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2
                    );
                    
                    giblet.mesh.position.copy(safePosition);
                    giblet.mesh.position.add(new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        Math.random() * 0.5,
                        (Math.random() - 0.5) * 0.5
                    ));
                    
                    this.scene.add(giblet.mesh);
                    this.particles.push(giblet);
                }
                
                // Create blood splatter particles
                for (let i = 0; i < bloodSplatterCount; i++) {
                    const bloodSize = 0.05 + Math.random() * 0.15;
                    const bloodParticle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(bloodSize, 3, 2),  // Reduced segments
                            new THREE.MeshBasicMaterial({ 
                                color: 0xaa0000,
                                transparent: true,
                                opacity: 0.9
                            })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 25,
                            Math.random() * 20,
                            (Math.random() - 0.5) * 25
                        ),
                        life: 1.5 + Math.random() * 1.0,
                        maxLife: 2.5,
                        gravity: -20,
                        isBlood: true
                    };
                    
                    // Apply force direction if provided
                    if (forceDirection && forceDirection.x !== undefined) {
                        const safeForce = forceDirection.clone();
                        bloodParticle.velocity.add(safeForce.multiplyScalar(15));
                    }
                    
                    bloodParticle.mesh.position.copy(safePosition);
                    this.scene.add(bloodParticle.mesh);
                    this.particles.push(bloodParticle);
                }
                
                // Create blood mist cloud
                for (let i = 0; i < mistCount; i++) {
                    const mist = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(0.3 + Math.random() * 0.3, 3, 2),  // Reduced segments
                            new THREE.MeshBasicMaterial({ 
                                color: 0x660000,
                                transparent: true,
                                opacity: 0.4
                            })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 8,
                            Math.random() * 5,
                            (Math.random() - 0.5) * 8
                        ),
                        life: 0.8,
                        maxLife: 0.8,
                        isMist: true,
                        expandRate: 2.0 // Mist expands over time
                    };
                    
                    mist.mesh.position.copy(safePosition);
                    this.scene.add(mist.mesh);
                    this.particles.push(mist);
                }
                
                // Add extra blood burst for headshots
                if (damageType === 'headshot') {
                    this.createBloodJet(safePosition, forceDirection || new THREE.Vector3(0, 1, 0));
                }
                
                // Cleanup shared geometries after use
                // (They're reused within this call but can be disposed after)
                setTimeout(() => {
                    if (sharedGeometries.small) sharedGeometries.small.dispose();
                    if (sharedGeometries.medium) sharedGeometries.medium.dispose();
                    if (sharedGeometries.large) sharedGeometries.large.dispose();
                    if (sharedGeometries.limb) sharedGeometries.limb.dispose();
                }, 100);
                */
            }

            update(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.life -= deltaTime;
                    
                    if (particle.life <= 0) {
                        this.scene.remove(particle.mesh);
                        particle.mesh.geometry.dispose();
                        particle.mesh.material.dispose();
                        this.particles.splice(i, 1);
                        continue;
                    }
                    
                    // Handle shockwave expansion
                    if (particle.isShockwave) {
                        particle.currentSize += particle.expandSpeed * deltaTime;
                        if (particle.currentSize <= particle.maxSize) {
                            particle.mesh.scale.set(particle.currentSize, particle.currentSize, particle.currentSize);
                            // Fade out rapidly as it expands
                            const progress = particle.currentSize / particle.maxSize;
                            particle.mesh.material.opacity = 0.25 * (1 - progress * progress); // Start at 25%, squared for faster fade
                        }
                        continue; // Skip normal particle physics for shockwave
                    }
                    
                    // Apply gravity (custom gravity for particles, skip if gravity is 0)
                    if (particle.gravity !== undefined) {
                        if (particle.gravity !== 0) {
                            particle.velocity.y += particle.gravity * deltaTime;
                        }
                        // If gravity is 0, don't apply any gravity (for floating mist)
                    } else {
                        particle.velocity.y -= 20 * deltaTime; // default gravity
                    }
                    
                    // Handle giblet physics
                    if (particle.isGiblet) {
                        // Apply angular velocity for tumbling
                        if (particle.angularVelocity) {
                            particle.mesh.rotation.x += particle.angularVelocity.x * deltaTime;
                            particle.mesh.rotation.y += particle.angularVelocity.y * deltaTime;
                            particle.mesh.rotation.z += particle.angularVelocity.z * deltaTime;
                            
                            // Slow down angular velocity over time
                            particle.angularVelocity.multiplyScalar(0.98);
                        }
                        
                        // Check for ground collision (simple bounce)
                        if (particle.mesh.position.y <= 0.2 && particle.velocity.y < 0) {
                            particle.mesh.position.y = 0.2;
                            particle.velocity.y *= -0.4; // Bounce with energy loss
                            particle.velocity.x *= 0.7; // Friction
                            particle.velocity.z *= 0.7;
                            
                            particle.bounces++;
                            if (particle.bounces >= particle.maxBounces) {
                                // Stop bouncing after max bounces
                                particle.velocity.set(0, 0, 0);
                                if (particle.angularVelocity) {
                                    particle.angularVelocity.multiplyScalar(0.5);
                                }
                            }
                        }
                    }
                    
                    // Calculate alpha first
                    const alpha = particle.life / particle.maxLife;
                    
                    // Handle mist expansion
                    if (particle.isMist && particle.expandRate) {
                        const expansion = 1 + (1 - alpha) * particle.expandRate;
                        particle.mesh.scale.setScalar(expansion);
                    }
                    
                    particle.mesh.position.add(particle.velocity.clone().multiplyScalar(deltaTime));
                    
                    // Set opacity
                    particle.mesh.material.opacity = alpha;
                    
                    // Only scale down non-mist and non-giblet particles
                    if (!particle.isMist && !particle.isGiblet && !particle.isBlood) {
                        particle.mesh.scale.setScalar(alpha);
                    }
                }
            }
        }

        // Enemy class
        class Enemy {
            constructor(scene, position, type = 0, currentWave = 1) {
                this.scene = scene;
                this.type = type;
                this.position = position.clone();
                this.velocity = new THREE.Vector3();
                this.mesh = null;
                this.currentWave = currentWave;
                
                // Enemy types with different stats
                const types = [
                    { hp: 50, speed: 3, color: 0xff4444, size: 1.5, damage: 10, score: 100 },
                    { hp: 75, speed: 2.5, color: 0x44ff44, size: 1.8, damage: 15, score: 150 },
                    { hp: 100, speed: 2, color: 0x4444ff, size: 2.25, damage: 20, score: 200 }
                ];
                
                const typeData = types[type];
                this.maxHp = typeData.hp;
                this.hp = this.maxHp;
                this.speed = typeData.speed;
                this.damage = typeData.damage;
                this.scoreValue = typeData.score;
                this.size = typeData.size;
                this.color = typeData.color;
                
                this.active = true;
                this.lastAttackTime = 0;
                this.attackCooldown = 1.0; // seconds for melee
                
                // All enemies are now ranged attackers
                this.isRanged = true;
                this.lastRangedAttackTime = 0;
                this.rangedDamage = 5;
                this.projectileSpeed = 30;
                this.attackRange = 30; // Maximum shooting distance
                
                // Determine weapon type based on wave
                this.weaponType = 'pistol'; // default
                this.isBurstFire = false;
                this.burstCount = 0;
                this.burstDelay = 0.15; // Default burst delay between shots
                this.lastBurstShotTime = 0;
                
                // Wave-based weapon assignment
                if (currentWave >= 20 && Math.random() < 0.1) {
                    // 10% chance for SMG burst after wave 20
                    this.weaponType = 'smg';
                    this.isBurstFire = true;
                    this.burstCount = 0;
                    this.burstDelay = 0.1; // SMG fire rate (slower)
                    this.maxBurstShots = 10; // 10-round burst
                    this.rangedAttackCooldown = 4.0; // Much longer cooldown between bursts
                } else if (currentWave >= 15 && Math.random() < 0.1) {
                    // 10% chance for rocket after wave 15
                    this.weaponType = 'rocket';
                    this.rangedAttackCooldown = 5.0; // Slower rocket fire rate
                    this.projectileSpeed = 20; // Slower rockets
                } else if (currentWave >= 10 && Math.random() < 0.15) {
                    // 15% chance for shotgun after wave 10
                    this.weaponType = 'shotgun';
                    this.rangedAttackCooldown = 2.5; // Slower shotgun fire rate
                } else if (Math.random() < 0.25) {
                    // 25% chance for regular 3-round burst
                    this.isBurstFire = true;
                    this.maxBurstShots = 3;
                    this.rangedAttackCooldown = 1.5; // Slower burst cooldown
                } else {
                    // Single shot pistol
                    this.rangedAttackCooldown = 1.5; // Slower pistol fire rate
                }
                
                this.createMesh();
                this.createHealthBar();
                
                // Store reference to enemy bullets (will be set by game)
                this.enemyBullets = null;
            }

            createMesh() {
                // Create humanoid model group
                this.mesh = new THREE.Group();
                this.mesh.position.copy(this.position);
                
                // Material for body parts
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: this.color });
                const skinMaterial = new THREE.MeshLambertMaterial({ color: 0xffaa88 });
                
                // Create body parts with physics-ready separate meshes
                this.bodyParts = {
                    torso: null,
                    head: null,
                    leftArm: null,
                    rightArm: null,
                    leftLeg: null,
                    rightLeg: null
                };
                
                // Torso (main body)
                const torsoGeometry = new THREE.BoxGeometry(0.6 * this.size, 0.8 * this.size, 0.3 * this.size);
                this.bodyParts.torso = new THREE.Mesh(torsoGeometry, bodyMaterial);
                this.bodyParts.torso.position.y = 0.8;
                this.bodyParts.torso.castShadow = true;
                this.bodyParts.torso.name = 'torso';
                this.mesh.add(this.bodyParts.torso);
                
                // Head with hitbox
                const headGeometry = new THREE.SphereGeometry(0.25 * this.size, 8, 6);
                this.bodyParts.head = new THREE.Mesh(headGeometry, skinMaterial);
                this.bodyParts.head.position.y = 1.5;
                this.bodyParts.head.castShadow = true;
                this.bodyParts.head.name = 'head';
                // Store head reference for hitbox detection
                this.headMesh = this.bodyParts.head;
                this.mesh.add(this.bodyParts.head);
                
                // Arms
                const armGeometry = new THREE.BoxGeometry(0.15 * this.size, 0.6 * this.size, 0.15 * this.size);
                this.bodyParts.leftArm = new THREE.Mesh(armGeometry, skinMaterial);
                this.bodyParts.leftArm.position.set(-0.45 * this.size, 0.8, 0);
                this.bodyParts.leftArm.castShadow = true;
                this.bodyParts.leftArm.name = 'leftArm';
                this.mesh.add(this.bodyParts.leftArm);
                
                this.bodyParts.rightArm = new THREE.Mesh(armGeometry.clone(), skinMaterial);
                this.bodyParts.rightArm.position.set(0.45 * this.size, 0.8, 0);
                this.bodyParts.rightArm.castShadow = true;
                this.bodyParts.rightArm.name = 'rightArm';
                this.mesh.add(this.bodyParts.rightArm);
                
                // Legs
                const legGeometry = new THREE.BoxGeometry(0.2 * this.size, 0.8 * this.size, 0.2 * this.size);
                this.bodyParts.leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                this.bodyParts.leftLeg.position.set(-0.2 * this.size, 0.4, 0);
                this.bodyParts.leftLeg.castShadow = true;
                this.bodyParts.leftLeg.name = 'leftLeg';
                this.mesh.add(this.bodyParts.leftLeg);
                
                this.bodyParts.rightLeg = new THREE.Mesh(legGeometry.clone(), bodyMaterial);
                this.bodyParts.rightLeg.position.set(0.2 * this.size, 0.4, 0);
                this.bodyParts.rightLeg.castShadow = true;
                this.bodyParts.rightLeg.name = 'rightLeg';
                this.mesh.add(this.bodyParts.rightLeg);
                
                // Add glowing eyes
                const eyeGeometry = new THREE.SphereGeometry(0.05, 4, 4);
                const eyeMaterial = new THREE.MeshBasicMaterial({ 
                    color: this.isRanged ? 0xffff00 : 0xff0000,
                    emissive: this.isRanged ? 0xffff00 : 0xff0000,
                    emissiveIntensity: 0.5
                });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                
                leftEye.position.set(-0.08, 0.05, 0.2);
                rightEye.position.set(0.08, 0.05, 0.2);
                
                this.bodyParts.head.add(leftEye);
                this.bodyParts.head.add(rightEye);
                
                // Add gun to right arm for ranged enemies
                if (this.isRanged) {
                    let gunGeometry, gunColor;
                    
                    // Different gun models based on weapon type
                    switch(this.weaponType) {
                        case 'rocket':
                            gunGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 6); // Larger for rocket launcher
                            gunColor = 0x444400; // Dark yellow
                            break;
                        case 'shotgun':
                            gunGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.35, 8); // Wider, shorter
                            gunColor = 0x663300; // Brown
                            break;
                        case 'smg':
                            gunGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.45, 6); // Longer for SMG
                            gunColor = 0x333366; // Dark blue
                            break;
                        default: // pistol
                            gunGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 6);
                            gunColor = this.isBurstFire ? 0x888888 : 0x222222; // Silver for burst, black for single
                    }
                    
                    const gunMaterial = new THREE.MeshBasicMaterial({ color: gunColor });
                    this.gun = new THREE.Mesh(gunGeometry, gunMaterial);
                    this.gun.position.set(0, -0.2, 0.15);
                    this.gun.rotation.x = Math.PI / 2;
                    this.bodyParts.rightArm.add(this.gun);
                }
                
                // Animation properties
                this.walkCycle = 0;
                this.animationSpeed = 5;
                this.isDead = false;
                this.ragdollParts = [];
                
                this.scene.add(this.mesh);
            }

            createHealthBar() {
                // Create a simple health bar above the enemy
                this.healthBarContainer = new THREE.Group();
                
                const barWidth = 1;
                const barHeight = 0.1;
                
                // Background
                const bgGeometry = new THREE.PlaneGeometry(barWidth, barHeight);
                const bgMaterial = new THREE.MeshBasicMaterial({ color: 0x440000 });
                this.healthBarBg = new THREE.Mesh(bgGeometry, bgMaterial);
                
                // Health bar
                const hpGeometry = new THREE.PlaneGeometry(barWidth, barHeight);
                const hpMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                this.healthBar = new THREE.Mesh(hpGeometry, hpMaterial);
                
                this.healthBarContainer.add(this.healthBarBg);
                this.healthBarContainer.add(this.healthBar);
                this.healthBarContainer.position.set(0, this.size + 0.5, 0);
                
                this.mesh.add(this.healthBarContainer);
            }

            update(deltaTime, playerPosition, enemyBulletPool, particleSystem, audioManager) {
                if (!this.active || this.isDead) return;

                const distanceToPlayer = this.position.distanceTo(playerPosition);
                let isMoving = false;
                
                // All enemies are ranged now
                if (distanceToPlayer <= this.attackRange) {
                    // Ranged enemy: Stop at a distance and shoot
                    const stopDistance = 15; // Keep distance from player
                    
                    if (distanceToPlayer > stopDistance) {
                        // Move closer if too far
                        const direction = playerPosition.clone().sub(this.position).normalize();
                        this.velocity = direction.multiplyScalar(this.speed * 0.7); // Move slower
                        this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                        isMoving = true;
                    } else if (distanceToPlayer < stopDistance - 2) {
                        // Back away if too close
                        const direction = this.position.clone().sub(playerPosition).normalize();
                        this.velocity = direction.multiplyScalar(this.speed * 0.5);
                        this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                        isMoving = true;
                    }
                    
                    // Try to shoot at player
                    this.attemptRangedAttack(playerPosition, enemyBulletPool, particleSystem, audioManager);
                } else {
                    // Out of range: Move toward player
                    const direction = playerPosition.clone().sub(this.position).normalize();
                    this.velocity = direction.multiplyScalar(this.speed);
                    this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                    isMoving = true;
                }
                
                // Walking animation
                if (isMoving && this.bodyParts) {
                    this.walkCycle += deltaTime * this.animationSpeed;
                    const walkAmount = Math.sin(this.walkCycle) * 0.15;
                    const walkSway = Math.sin(this.walkCycle * 2) * 0.05;
                    
                    // Animate legs
                    if (this.bodyParts.leftLeg) {
                        this.bodyParts.leftLeg.rotation.x = walkAmount;
                        this.bodyParts.leftLeg.position.z = Math.sin(this.walkCycle) * 0.1;
                    }
                    if (this.bodyParts.rightLeg) {
                        this.bodyParts.rightLeg.rotation.x = -walkAmount;
                        this.bodyParts.rightLeg.position.z = -Math.sin(this.walkCycle) * 0.1;
                    }
                    
                    // Animate arms
                    if (this.bodyParts.leftArm) {
                        this.bodyParts.leftArm.rotation.x = -walkAmount * 0.5;
                    }
                    if (this.bodyParts.rightArm && !this.isRanged) {
                        // Only swing right arm if not holding gun
                        this.bodyParts.rightArm.rotation.x = walkAmount * 0.5;
                    }
                    
                    // Slight body sway
                    if (this.bodyParts.torso) {
                        this.bodyParts.torso.rotation.y = walkSway;
                    }
                }
                
                // Update mesh position
                this.mesh.position.copy(this.position);
                
                // Look at player
                this.mesh.lookAt(playerPosition);
                
                // Keep health bar facing camera (billboard effect)
                if (this.healthBarContainer) {
                    this.healthBarContainer.lookAt(playerPosition);
                    this.updateHealthBar();
                }
            }

            attemptRangedAttack(playerPosition, enemyBulletPool, particleSystem, audioManager) {
                if (!this.isRanged || !enemyBulletPool) return;
                
                const now = performance.now() / 1000;
                
                // Handle burst fire mode
                if (this.isBurstFire) {
                    // Check if we can start a new burst
                    if (this.burstCount === 0 && now - this.lastRangedAttackTime < this.rangedAttackCooldown) {
                        return;
                    }
                    
                    // Check if we're in the middle of a burst
                    if (this.burstCount > 0 && now - this.lastBurstShotTime < this.burstDelay) {
                        return;
                    }
                    
                    // Fire a shot
                    this.fireProjectile(playerPosition, enemyBulletPool, particleSystem, audioManager);
                    this.lastBurstShotTime = now;
                    this.burstCount++;
                    
                    // Reset burst after reaching max shots
                    if (this.burstCount >= this.maxBurstShots) {
                        this.burstCount = 0;
                        this.lastRangedAttackTime = now;
                    }
                } else {
                    // Single shot mode
                    if (now - this.lastRangedAttackTime < this.rangedAttackCooldown) return;
                    
                    this.fireProjectile(playerPosition, enemyBulletPool, particleSystem, audioManager);
                    this.lastRangedAttackTime = now;
                }
            }
            
            fireProjectile(playerPosition, enemyBulletPool, particleSystem, audioManager) {
                // Safety checks
                if (!enemyBulletPool || !playerPosition) return;
                
                const baseDirection = playerPosition.clone().sub(this.position).normalize();
                const startPos = this.position.clone();
                startPos.y += this.size * 0.3; // Shoot from mid-height
                startPos.add(baseDirection.clone().multiplyScalar(this.size));
                
                // Handle different weapon types
                if (this.weaponType === 'shotgun') {
                    // Fire 6 pellets with spread
                    for (let i = 0; i < 6; i++) {
                        const bullet = enemyBulletPool.get();
                        if (!bullet) continue;
                        
                        // Add spread to each pellet
                        const direction = baseDirection.clone();
                        direction.x += (Math.random() - 0.5) * 0.15;
                        direction.y += (Math.random() - 0.5) * 0.15;
                        direction.z += (Math.random() - 0.5) * 0.15;
                        direction.normalize();
                        
                        bullet.damage = 3; // Less damage per pellet
                        bullet.speed = 35; // Slightly faster
                        bullet.mesh.material.color.setHex(0xffaa00); // Orange pellets
                        bullet.isEnemyBullet = true;
                        bullet.isRocket = false;
                        bullet.isHellfireRocket = false;
                        bullet.isHellfireBullet = false;
                        bullet.fire(startPos.clone(), direction);
                    }
                } else if (this.weaponType === 'rocket') {
                    // Fire a single rocket
                    const bullet = enemyBulletPool.get();
                    if (!bullet) return;
                    
                    bullet.damage = 30; // High damage
                    bullet.speed = this.projectileSpeed; // Slower
                    bullet.isRocket = true; // Mark as rocket
                    bullet.blastRadius = 5; // Explosion radius
                    bullet.isEnemyBullet = true;
                    bullet.isHellfireRocket = false;
                    bullet.isHellfireBullet = false;
                    bullet.fire(startPos, baseDirection);
                } else {
                    // Regular bullet (pistol or SMG)
                    const bullet = enemyBulletPool.get();
                    if (!bullet) return;
                    
                    bullet.damage = this.weaponType === 'smg' ? 4 : this.rangedDamage;
                    bullet.speed = this.weaponType === 'smg' ? 40 : this.projectileSpeed;
                    bullet.mesh.material.color.setHex(this.weaponType === 'smg' ? 0x00ffff : 0xff0000);
                    bullet.isEnemyBullet = true;
                    bullet.isRocket = false;
                    bullet.isHellfireRocket = false;
                    bullet.isHellfireBullet = false;
                    bullet.fire(startPos, baseDirection);
                }
                
                // Shooting animation - recoil effect
                if (this.bodyParts && this.bodyParts.rightArm && !this.isDead) {
                    // Store original rotation for animation
                    const originalRotation = this.bodyParts.rightArm.rotation.x;
                    
                    // Kick arm back
                    this.bodyParts.rightArm.rotation.x -= 0.3;
                    
                    // Animate gun recoil if present
                    if (this.gun) {
                        const originalGunPos = this.gun.position.z;
                        this.gun.position.z -= 0.05;
                        
                        // Return gun to original position
                        setTimeout(() => {
                            if (this.gun && !this.isDead) {
                                this.gun.position.z = originalGunPos;
                            }
                        }, 100);
                    }
                    
                    // Return arm to original position after short delay
                    setTimeout(() => {
                        if (this.bodyParts && this.bodyParts.rightArm && !this.isDead) {
                            this.bodyParts.rightArm.rotation.x = originalRotation;
                        }
                    }, 100);
                }
                
                // Play enemy shoot sound
                if (audioManager) {
                    audioManager.play('enemyShoot');
                }
                
                // Create muzzle flash (only if particleSystem exists)
                // Disabled - no muzzle flash effect
                // if (particleSystem && particleSystem.createMuzzleFlash) {
                //     particleSystem.createMuzzleFlash(startPos, baseDirection);
                // }
            }

            updateHealthBar() {
                const healthPercent = this.hp / this.maxHp;
                this.healthBar.scale.x = healthPercent;
                this.healthBar.position.x = (1 - healthPercent) * -0.5;
                
                // Color transition: green -> yellow -> red
                if (healthPercent > 0.6) {
                    this.healthBar.material.color.setHex(0x00ff00);
                } else if (healthPercent > 0.3) {
                    this.healthBar.material.color.setHex(0xffff00);
                } else {
                    this.healthBar.material.color.setHex(0xff0000);
                }
            }

            takeDamage(damage) {
                this.hp -= damage;
                this.updateHealthBar();
                
                if (this.hp <= 0) {
                    this.destroy();
                    return true; // Enemy killed
                }
                return false;
            }

            canAttack(currentTime) {
                return currentTime - this.lastAttackTime >= this.attackCooldown;
            }

            attack(currentTime) {
                this.lastAttackTime = currentTime;
                return this.damage;
            }

            destroy(explosionForce = null, explosionPosition = null) {
                this.active = false;
                this.isDead = true;
                
                // Remove health bar immediately
                if (this.healthBarContainer) {
                    this.mesh.remove(this.healthBarContainer);
                    this.healthBar.geometry.dispose();
                    this.healthBar.material.dispose();
                    this.healthBarBg.geometry.dispose();
                    this.healthBarBg.material.dispose();
                }
                
                // Create ragdoll physics for body parts
                if (this.bodyParts && !explosionForce) {
                    // Regular death - create ragdoll
                    this.createRagdoll();
                } else if (this.bodyParts && explosionForce) {
                    // Explosion death - dismember and apply force
                    this.dismember(explosionForce, explosionPosition);
                } else {
                    // Fallback for old enemy models
                    if (this.mesh) {
                        this.scene.remove(this.mesh);
                        this.mesh.geometry.dispose();
                        this.mesh.material.dispose();
                    }
                }
            }
            
            createRagdoll() {
                // Store reference to scene for cleanup
                const scene = this.scene;
                
                // For non-explosion death, create joint-based ragdoll
                if (this.mesh && this.bodyParts) {
                    // Create main body physics with initial velocity
                    // Less upward force, more horizontal for realistic falling
                    const initialVelocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 3,
                        Math.random() * 1.5 + 0.5, // Reduced upward force
                        (Math.random() - 0.5) * 3
                    );
                    
                    // Main ragdoll object with joint physics
                    const ragdollBody = {
                        mesh: this.mesh,
                        velocity: initialVelocity.clone(),
                        angularVelocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 8, // Increased rotation for more dynamic falling
                            (Math.random() - 0.5) * 8,
                            (Math.random() - 0.5) * 8
                        ),
                        lifetime: 5, // Extended from 3 to 5 seconds for more realistic settling
                        isWholeBody: true,
                        joints: {} // Store joint angular velocities
                    };
                    
                    // Initialize joint physics for each limb
                    if (this.bodyParts.leftArm) {
                        ragdollBody.joints.leftArm = {
                            angularVel: new THREE.Vector3(
                                (Math.random() - 0.5) * 8,
                                0,
                                (Math.random() - 0.5) * 8
                            ),
                            maxAngle: { x: Math.PI/2, y: 0, z: Math.PI/3 }
                        };
                    }
                    if (this.bodyParts.rightArm) {
                        ragdollBody.joints.rightArm = {
                            angularVel: new THREE.Vector3(
                                (Math.random() - 0.5) * 8,
                                0,
                                (Math.random() - 0.5) * 8
                            ),
                            maxAngle: { x: Math.PI/2, y: 0, z: Math.PI/3 }
                        };
                    }
                    if (this.bodyParts.leftLeg) {
                        ragdollBody.joints.leftLeg = {
                            angularVel: new THREE.Vector3(
                                (Math.random() - 0.5) * 6,
                                0,
                                (Math.random() - 0.5) * 4
                            ),
                            maxAngle: { x: Math.PI/3, y: 0, z: Math.PI/6 }
                        };
                    }
                    if (this.bodyParts.rightLeg) {
                        ragdollBody.joints.rightLeg = {
                            angularVel: new THREE.Vector3(
                                (Math.random() - 0.5) * 6,
                                0,
                                (Math.random() - 0.5) * 4
                            ),
                            maxAngle: { x: Math.PI/3, y: 0, z: Math.PI/6 }
                        };
                    }
                    if (this.bodyParts.head) {
                        ragdollBody.joints.head = {
                            angularVel: new THREE.Vector3(
                                (Math.random() - 0.5) * 4,
                                (Math.random() - 0.5) * 4,
                                (Math.random() - 0.5) * 4
                            ),
                            maxAngle: { x: Math.PI/4, y: Math.PI/4, z: Math.PI/4 }
                        };
                    }
                    
                    this.ragdollParts.push(ragdollBody);
                }
                
                // Start ragdoll physics simulation
                this.simulateRagdollWithJoints(scene);
            }
            
            simulateRagdollWithJoints(scene) {
                const gravity = -9.8;
                const damping = 0.99; // Increased from 0.98 for slower energy loss
                const jointDamping = 0.96; // Increased from 0.92 for more active joints
                const groundLevel = 0;
                
                const animate = () => {
                    if (this.ragdollParts.length === 0) return;
                    
                    const deltaTime = 1/60;
                    
                    for (let i = this.ragdollParts.length - 1; i >= 0; i--) {
                        const part = this.ragdollParts[i];
                        
                        // Apply gravity to main body
                        part.velocity.y += gravity * deltaTime;
                        
                        // Update main body position
                        part.mesh.position.add(part.velocity.clone().multiplyScalar(deltaTime));
                        
                        // Update main body rotation
                        part.mesh.rotation.x += part.angularVelocity.x * deltaTime;
                        part.mesh.rotation.y += part.angularVelocity.y * deltaTime;
                        part.mesh.rotation.z += part.angularVelocity.z * deltaTime;
                        
                        // Update joint rotations if this is a whole body
                        if (part.isWholeBody && part.joints && this.bodyParts) {
                            // Animate each joint
                            for (let jointName in part.joints) {
                                const joint = part.joints[jointName];
                                const bodyPart = this.bodyParts[jointName];
                                
                                if (bodyPart && joint) {
                                    // Apply joint angular velocity
                                    bodyPart.rotation.x += joint.angularVel.x * deltaTime;
                                    bodyPart.rotation.y += joint.angularVel.y * deltaTime;
                                    bodyPart.rotation.z += joint.angularVel.z * deltaTime;
                                    
                                    // Clamp to max angles (joint limits)
                                    bodyPart.rotation.x = Math.max(-joint.maxAngle.x, Math.min(joint.maxAngle.x, bodyPart.rotation.x));
                                    bodyPart.rotation.y = Math.max(-joint.maxAngle.y, Math.min(joint.maxAngle.y, bodyPart.rotation.y));
                                    bodyPart.rotation.z = Math.max(-joint.maxAngle.z, Math.min(joint.maxAngle.z, bodyPart.rotation.z));
                                    
                                    // Apply joint damping
                                    joint.angularVel.multiplyScalar(jointDamping);
                                    
                                    // Add some gravity effect on limbs
                                    if (jointName.includes('Arm')) {
                                        joint.angularVel.z += gravity * 0.05 * deltaTime;
                                    }
                                }
                            }
                        }
                        
                        // Ground collision
                        if (part.mesh.position.y <= groundLevel) {
                            part.mesh.position.y = groundLevel;
                            part.velocity.y *= -0.2; // Very little bounce
                            part.velocity.x *= 0.6; // High friction
                            part.velocity.z *= 0.6;
                            part.angularVelocity.multiplyScalar(0.7);
                            
                            // Reduce joint velocities on ground impact
                            if (part.joints) {
                                for (let jointName in part.joints) {
                                    part.joints[jointName].angularVel.multiplyScalar(0.5);
                                }
                            }
                        }
                        
                        // Apply damping
                        part.velocity.multiplyScalar(damping);
                        part.angularVelocity.multiplyScalar(damping * 0.95);
                        
                        // Update lifetime
                        part.lifetime -= deltaTime;
                        
                        // Fade out only in last 0.5 seconds
                        if (part.lifetime < 0.5) {
                            const opacity = part.lifetime * 2; // Scale to 0-1 range
                            // Apply opacity to all materials in the mesh
                            part.mesh.traverse((child) => {
                                if (child.material) {
                                    child.material.opacity = opacity;
                                    child.material.transparent = true;
                                }
                            });
                        }
                        
                        // Remove when expired
                        if (part.lifetime <= 0) {
                            scene.remove(part.mesh);
                            part.mesh.traverse((child) => {
                                if (child.geometry) child.geometry.dispose();
                                if (child.material) {
                                    if (Array.isArray(child.material)) {
                                        child.material.forEach(m => m.dispose());
                                    } else {
                                        child.material.dispose();
                                    }
                                }
                            });
                            this.ragdollParts.splice(i, 1);
                        }
                    }
                    
                    if (this.ragdollParts.length > 0) {
                        requestAnimationFrame(animate);
                    }
                };
                
                requestAnimationFrame(animate);
            }
            
            dismember(explosionForce, explosionPosition) {
                const scene = this.scene;
                const bodyParts = this.bodyParts;
                
                // Remove the group mesh from scene
                if (this.mesh) {
                    scene.remove(this.mesh);
                }
                
                // Create massive blood spurt at dismemberment point
                const game = window.currentGame;
                if (game && game.particleSystem && this.position) {
                    const bodyCenter = this.position.clone();
                    bodyCenter.y += 1; // Center of torso
                    
                    // Calculate direction away from explosion
                    const spurDirection = bodyCenter.clone().sub(explosionPosition).normalize();
                    
                    // Create multiple blood jets for massive gore effect
                    for (let i = 0; i < 3; i++) {
                        // Vary the direction slightly for each jet
                        const jetDir = spurDirection.clone();
                        jetDir.x += (Math.random() - 0.5) * 0.3;
                        jetDir.y += Math.random() * 0.3; // Upward bias
                        jetDir.z += (Math.random() - 0.5) * 0.3;
                        jetDir.normalize();
                        
                        // Create intense blood jet
                        game.particleSystem.createMassiveBloodSpurt(bodyCenter, jetDir);
                    }
                }
                
                // 50% chance to play explosion sound
                if (Math.random() < 0.5) {
                    // Note: This will be called from game update
                    this.shouldPlayExplodeSound = true;
                }
                
                // Separate and launch each body part
                for (let partName in bodyParts) {
                    const part = bodyParts[partName];
                    if (!part) continue;
                    
                    // Get world position
                    const worldPos = new THREE.Vector3();
                    part.getWorldPosition(worldPos);
                    
                    // Calculate explosion direction and force
                    const direction = worldPos.clone().sub(explosionPosition).normalize();
                    const distance = worldPos.distanceTo(explosionPosition);
                    const force = explosionForce * Math.max(0, 1 - distance / 10);
                    
                    // Remove from parent and add to scene
                    this.mesh.remove(part);
                    part.position.copy(worldPos);
                    scene.add(part);
                    
                    // Create physics with explosion force
                    const ragdollPart = {
                        mesh: part,
                        velocity: direction.multiplyScalar(force).add(
                            new THREE.Vector3(0, force * 0.5, 0) // Add upward force
                        ),
                        angularVelocity: new THREE.Vector3(
                            (Math.random() - 0.5) * force * 2,
                            (Math.random() - 0.5) * force * 2,
                            (Math.random() - 0.5) * force * 2
                        ),
                        lifetime: 5 // longer lifetime for explosion parts
                    };
                    
                    // Add blood trail effect for dismembered parts
                    ragdollPart.hasBloodTrail = true;
                    
                    this.ragdollParts.push(ragdollPart);
                }
                
                // Start ragdoll physics simulation for dismembered parts
                this.simulateRagdollParts(scene);
            }
            
            simulateRagdollParts(scene, particleSystem = null) {
                const gravity = -9.8;
                const damping = 0.98;
                const groundLevel = 0;
                
                // Pass particleSystem from game for blood trails
                const game = window.currentGame;
                if (!particleSystem && game && game.particleSystem) {
                    particleSystem = game.particleSystem;
                }
                
                const animate = () => {
                    if (this.ragdollParts.length === 0) return;
                    
                    const deltaTime = 1/60; // Fixed timestep for consistency
                    
                    for (let i = this.ragdollParts.length - 1; i >= 0; i--) {
                        const part = this.ragdollParts[i];
                        
                        // Enhanced blood trail system - more dramatic
                        if (part.hasBloodTrail && particleSystem) {
                            // Emit based on velocity - faster parts bleed more
                            const speed = part.velocity.length();
                            if (speed > 1) { // Lower threshold for more trails
                                if (!part.lastBloodTime) part.lastBloodTime = 0;
                                part.lastBloodTime += deltaTime;
                                
                                // Emit more frequently when moving fast
                                const emitRate = Math.max(0.03, 0.1 - speed * 0.01); // Faster = more frequent
                                
                                if (part.lastBloodTime > emitRate) {
                                    // Only emit if not too many particles already
                                    if (particleSystem.particles.length < 400) {
                                        // Emit 2-3 droplets for more dramatic effect
                                        const dropletCount = speed > 5 ? 3 : 2;
                                        for (let d = 0; d < dropletCount; d++) {
                                            const randomOffset = new THREE.Vector3(
                                                (Math.random() - 0.5) * 0.2,
                                                (Math.random() - 0.5) * 0.2,
                                                (Math.random() - 0.5) * 0.2
                                            );
                                            const dropletPos = part.mesh.position.clone().add(randomOffset);
                                            const dropletVel = part.velocity.clone().multiplyScalar(-0.2 + Math.random() * 0.1);
                                            particleSystem.createBloodDroplet(dropletPos, dropletVel);
                                        }
                                    }
                                    part.lastBloodTime = 0;
                                }
                            }
                        }
                        
                        // Apply gravity
                        part.velocity.y += gravity * deltaTime;
                        
                        // Apply velocity
                        part.mesh.position.add(part.velocity.clone().multiplyScalar(deltaTime));
                        
                        // Apply rotation
                        part.mesh.rotation.x += part.angularVelocity.x * deltaTime;
                        part.mesh.rotation.y += part.angularVelocity.y * deltaTime;
                        part.mesh.rotation.z += part.angularVelocity.z * deltaTime;
                        
                        // Ground collision
                        if (part.mesh.position.y <= groundLevel) {
                            part.mesh.position.y = groundLevel;
                            part.velocity.y *= -0.3; // Bounce with energy loss
                            part.velocity.x *= 0.7; // Friction
                            part.velocity.z *= 0.7;
                            part.angularVelocity.multiplyScalar(0.8);
                        }
                        
                        // Apply damping
                        part.velocity.multiplyScalar(damping);
                        part.angularVelocity.multiplyScalar(damping * 0.95);
                        
                        // Update lifetime
                        part.lifetime -= deltaTime;
                        
                        // Fade out near end of lifetime
                        if (part.lifetime < 1) {
                            part.mesh.material.opacity = part.lifetime;
                            part.mesh.material.transparent = true;
                        }
                        
                        // Remove when lifetime expires
                        if (part.lifetime <= 0) {
                            scene.remove(part.mesh);
                            
                            // For whole body ragdoll, dispose all child meshes
                            if (part.isWholeBody) {
                                part.mesh.traverse((child) => {
                                    if (child.geometry) child.geometry.dispose();
                                    if (child.material) {
                                        if (Array.isArray(child.material)) {
                                            child.material.forEach(m => m.dispose());
                                        } else {
                                            child.material.dispose();
                                        }
                                    }
                                });
                            } else {
                                // Individual part cleanup
                                if (part.mesh.geometry) part.mesh.geometry.dispose();
                                if (part.mesh.material) part.mesh.material.dispose();
                            }
                            
                            this.ragdollParts.splice(i, 1);
                        }
                    }
                    
                    // Continue animation if parts remain
                    if (this.ragdollParts.length > 0) {
                        requestAnimationFrame(animate);
                    }
                };
                
                // Start animation
                requestAnimationFrame(animate);
            }

            getDistanceToPlayer(playerPosition) {
                return this.position.distanceTo(playerPosition);
            }
        }

        // Pickup class
        class Pickup {
            constructor(scene, position, type) {
                this.scene = scene;
                this.position = position.clone();
                this.type = type; // 'health' or 'ammo'
                this.active = true;
                this.rotationSpeed = 2;
                this.bobSpeed = 3;
                this.bobAmount = 0.3;
                this.time = Math.random() * Math.PI * 2;
                this.collected = false;
                
                this.createMesh();
            }

            createMesh() {
                let geometry, material;
                
                if (this.type === 'health') {
                    geometry = new THREE.BoxGeometry(0.8, 0.8, 0.2);
                    material = new THREE.MeshBasicMaterial({ 
                        color: 0x00ff00
                    });
                } else { // ammo
                    geometry = new THREE.BoxGeometry(0.6, 1.2, 0.6);
                    material = new THREE.MeshBasicMaterial({ 
                        color: 0xffff00
                    });
                }
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }

            update(deltaTime) {
                if (!this.active || this.collected) return;

                this.time += deltaTime;
                
                // Rotate
                this.mesh.rotation.y += this.rotationSpeed * deltaTime;
                
                // Bob up and down
                this.mesh.position.y = this.position.y + Math.sin(this.time * this.bobSpeed) * this.bobAmount;
            }

            collect() {
                if (this.collected) return null;
                
                this.collected = true;
                this.active = false;
                
                this.scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
                
                return this.type;
            }

            getPosition() {
                return this.position;
            }
        }

        // Weapon System
        class WeaponSystem {
            constructor(scene, camera, audioManager) {
                this.scene = scene;
                this.camera = camera;
                this.audioManager = audioManager;
                
                // Current weapon
                this.currentWeapon = 'smg'; // 'smg', 'shotgun', 'rocket', or 'sword'
                
                // Weapon definitions
                this.weapons = {
                    smg: {
                        maxAmmo: 30,
                        currentAmmo: 30,  // Store ammo per weapon
                        fireRate: 0.05,  // Doubled fire rate (was 0.1)
                        reloadTime: 1.0,  // Halved reload time (was 2.0)
                        damage: 25,
                        isAutomatic: true,
                        recoilAmount: 0.02,
                        soundName: 'shoot',
                        projectileCount: 1,
                        spread: 0,
                        screenShake: 0.004  // Slight screen shake (increased for visibility)
                    },
                    shotgun: {
                        maxAmmo: 6,
                        currentAmmo: 6,   // Store ammo per weapon
                        fireRate: 0.3,  // Halved time between shots (was 0.6)
                        reloadTime: 1.25,  // Halved reload time (was 2.5)
                        damage: 20,
                        isAutomatic: false,
                        recoilAmount: 0.08,
                        soundName: 'shotgun',
                        projectileCount: 6,
                        spread: 0.1,
                        screenShake: 0.02,   // Significant screen shake (increased for impact)
                        isShotgun: true      // Flag for Blood Thirst double pellets
                    },
                    rocket: {
                        maxAmmo: 1,
                        currentAmmo: 1,    // Single shot magazine
                        fireRate: 0.5,     // Even faster fire rate for rapid rockets
                        reloadTime: 1.5,   // Halved reload time (was 3.0)
                        damage: 100,       // High direct damage
                        isAutomatic: false,
                        recoilAmount: 0.12, // Heavy recoil
                        soundName: 'rocket',
                        projectileCount: 1,
                        spread: 0,
                        screenShake: 0.04,  // Maximum screen shake
                        isRocket: true,     // Special flag for rocket
                        blastRadius: 8,     // Explosion radius
                        projectileSpeed: 40 // Slower than bullets
                    },
                    walkieTalkie: {
                        maxAmmo: 1,        // Single use
                        currentAmmo: 0,    // Starts with none
                        fireRate: 1,       // Not relevant for single use
                        reloadTime: 0,     // Cannot reload
                        damage: 100,       // Each rocket does 100 damage
                        isAutomatic: false,
                        spread: 0,
                        screenShake: 0,
                        isAirstrike: true  // Special flag for airstrike
                    },
                    autoCannon: {
                        maxAmmo: 5,
                        currentAmmo: 5,
                        fireRate: 0.15,    // 400 RPM max (faster, more responsive)
                        reloadTime: 1.0,   // Same reload speed as SMG
                        damage: 99999,     // Instakill on direct hit
                        isAutomatic: false,
                        isSemiAuto: true,  // Semi-auto but can be clicked rapidly
                        recoilAmount: 0.15,
                        soundName: 'autocannon_fire',
                        projectileCount: 1,
                        spread: 0,
                        screenShake: 0.03,
                        bulletSpeed: 200,  // 2x normal bullet speed
                        bulletType: '30mmShell',
                        lastFireTime: 0    // Track for fire rate limiting
                    },
                    sword: {
                        maxAmmo: 0,        // No ammo for melee
                        currentAmmo: 0,    // No ammo for melee
                        fireRate: 0.25,    // Faster swing speed (was 0.5)
                        reloadTime: 0,     // No reload
                        damage: 75,        // High damage (1-2 hit kill)
                        isAutomatic: false,
                        recoilAmount: 0,   // No recoil for melee
                        soundName: 'swordSwing',
                        projectileCount: 0,// No projectiles
                        spread: 0,
                        screenShake: 0.01,
                        isMelee: true,     // Flag for melee weapon
                        meleeRange: 5,     // Increased melee attack range (was 3)
                        swingAngle: 120    // Wider swing arc (was 90)
                    },
                    warthogStrike: {
                        maxAmmo: 1,        // Single use
                        currentAmmo: 0,    // Starts with none
                        fireRate: 1,       // Not relevant for single use
                        reloadTime: 0,     // Cannot reload
                        damage: 150,       // Each 30mm shell does 150 damage
                        isAutomatic: false,
                        spread: 0,
                        screenShake: 0,
                        isWarthogStrike: true  // Special flag for warthog strike
                    }
                };
                
                // Shared ammo pool
                this.reserveAmmo = 90;
                this.maxReserve = 120;
                this.lastShotTime = 0;
                this.isReloading = false;
                this.reloadStartTime = 0;
                this.triggerReleased = true;
                
                // Sword swing state
                this.isSwinging = false;
                this.swingProgress = 0;
                this.swingStartTime = 0;
                this.swingDuration = 0.2; // 200ms swing animation
                this.swingOffset = { rotation: { x: 0, y: 0, z: 0 }, position: { x: 0, y: 0, z: 0 } };
                
                // Secondary attack state (wind-up and area swing)
                this.isWindingUp = false;
                this.windUpStartTime = 0;
                this.windUpDuration = 0.3; // 300ms wind-up
                this.isAreaSwinging = false;
                this.areaSwingStartTime = 0;
                this.areaSwingDuration = 0.4; // 400ms for big swing
                
                // Zoom/Scope state for autocannon
                this.isZoomed = false;
                this.defaultFOV = 75;
                this.zoomFOV = 30; // 2.5x zoom
                this.currentFOV = this.defaultFOV;
                this.scopeOverlay = null;
                this.zoomTogglePressed = false;
                
                // Sword Combo System (SWORD ONLY)
                this.swordCombo = {
                    count: 0,                    // Current combo position (0-2 for 3-hit combo)
                    lastAttackTime: 0,           // Time of last attack
                    comboWindow: 0.7,            // Time allowed between attacks (700ms)
                    currentAttack: null,         // Current attack type
                    queuedAttack: null,          // Buffered next attack
                    canCombo: false,             // Can accept next input
                    inputBufferTime: 0.3,        // When to allow buffering (last 30% of animation)
                    directionalInput: null,      // Mouse direction during attack
                    heavyFinisherReady: false    // Can perform heavy finisher
                };
                
                // Sword attack animations
                this.swordAnimations = {
                    combo1: { duration: 0.25, type: 'downChop' },
                    combo2: { duration: 0.3, type: 'diagonalSlash' },
                    combo3: { duration: 0.35, type: 'spinSlash' },
                    upSlash: { duration: 0.25, type: 'upSlash' },
                    leftSlash: { duration: 0.25, type: 'leftSlash' },
                    rightSlash: { duration: 0.25, type: 'rightSlash' },
                    heavyFinisher: { duration: 0.35, type: 'heavyFinisher' }  // Faster slam
                };
                
                // Blood Thirst state
                this.bloodThirstActive = false;
                
                // Hellfire state
                this.hellfireActive = false;
                
                // BERSERK state
                this.berserkActive = false;
                
                // Weapon sway and recoil
                this.weaponSway = { x: 0, y: 0 };
                this.recoil = { x: 0, y: 0 };
                this.swayAmount = 0.002;
                
                // Screen shake system
                this.screenShake = { x: 0, y: 0, intensity: 0, duration: 0 };
                
                // Create weapon models
                this.weaponModels = {};
                this.createSMGModel();
                this.createShotgunModel();
                this.createRocketLauncherModel();
                this.createWalkieTalkieModel();
                this.createWarthogStrikeModel();
                this.createAutoCannonModel();
                this.createSwordModel();
                
                // Show initial weapon
                this.switchWeapon('smg');
                this.updateAmmoDisplay();
            }

            createSMGModel() {
                // Create SMG model
                const smgGroup = new THREE.Group();
                
                // SMG body
                const bodyGeometry = new THREE.BoxGeometry(0.12, 0.2, 0.5);
                const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x666666 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.set(0, 0, 0);
                
                // SMG barrel
                const barrelGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 8);
                const barrelMaterial = new THREE.MeshBasicMaterial({ color: 0x444444 });
                const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                barrel.position.set(0, 0.03, -0.35);
                barrel.rotation.x = Math.PI / 2;
                
                // SMG grip
                const gripGeometry = new THREE.BoxGeometry(0.06, 0.12, 0.1);
                const gripMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
                const grip = new THREE.Mesh(gripGeometry, gripMaterial);
                grip.position.set(0, -0.12, 0.15);
                grip.rotation.z = -0.1;
                
                // SMG Magazine
                const magazine = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, 0.1, 0.08),
                    new THREE.MeshBasicMaterial({ color: 0x777777 })
                );
                magazine.position.set(0, -0.1, 0.05);
                
                // Muzzle flash
                const flashGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const muzzleFlash = new THREE.Mesh(
                    flashGeometry,
                    new THREE.MeshBasicMaterial({ 
                        color: 0xffff00, 
                        transparent: true, 
                        opacity: 0 
                    })
                );
                muzzleFlash.position.set(0, 0.03, -0.55);
                
                // Add all parts to SMG group
                smgGroup.add(body);
                smgGroup.add(barrel);
                smgGroup.add(grip);
                smgGroup.add(magazine);
                smgGroup.add(muzzleFlash);
                
                // Set render order
                smgGroup.traverse((child) => {
                    if (child.isMesh) child.renderOrder = 999;
                });
                muzzleFlash.renderOrder = 1000;
                
                // Store references
                smgGroup.userData.magazine = magazine;
                smgGroup.userData.muzzleFlash = muzzleFlash;
                
                this.weaponModels.smg = smgGroup;
                this.scene.add(smgGroup);
                smgGroup.visible = false;
                
                // Create left-hand SMG for akimbo effect during berserk
                this.createLeftHandSMG();
            }
            
            createLeftHandSMG() {
                // Clone the right-hand SMG for the left hand
                const leftSMGGroup = new THREE.Group();
                
                // SMG body
                const bodyGeometry = new THREE.BoxGeometry(0.12, 0.2, 0.5);
                const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x666666 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.set(0, 0, 0);
                
                // SMG barrel
                const barrelGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 8);
                const barrelMaterial = new THREE.MeshBasicMaterial({ color: 0x444444 });
                const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                barrel.position.set(0, 0.03, -0.35);
                barrel.rotation.x = Math.PI / 2;
                
                // SMG grip
                const gripGeometry = new THREE.BoxGeometry(0.06, 0.12, 0.1);
                const gripMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
                const grip = new THREE.Mesh(gripGeometry, gripMaterial);
                grip.position.set(0, -0.12, 0.15);
                grip.rotation.z = 0.1; // Mirror the rotation
                
                // SMG Magazine
                const magazine = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, 0.1, 0.08),
                    new THREE.MeshBasicMaterial({ color: 0x777777 })
                );
                magazine.position.set(0, -0.1, 0.05);
                
                // Muzzle flash
                const flashGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const muzzleFlash = new THREE.Mesh(
                    flashGeometry,
                    new THREE.MeshBasicMaterial({ 
                        color: 0xffff00, 
                        transparent: true, 
                        opacity: 0 
                    })
                );
                muzzleFlash.position.set(0, 0.03, -0.55);
                
                // Add all parts to left SMG group
                leftSMGGroup.add(body);
                leftSMGGroup.add(barrel);
                leftSMGGroup.add(grip);
                leftSMGGroup.add(magazine);
                leftSMGGroup.add(muzzleFlash);
                
                // Set render order
                leftSMGGroup.renderOrder = 1000;
                leftSMGGroup.traverse((child) => {
                    if (child.isMesh) {
                        child.renderOrder = 1000;
                    }
                });
                
                // Store references
                leftSMGGroup.userData.magazine = magazine;
                leftSMGGroup.userData.muzzleFlash = muzzleFlash;
                
                this.weaponModels.smgLeft = leftSMGGroup;
                this.scene.add(leftSMGGroup);
                leftSMGGroup.visible = false;
            }

            createRocketLauncherModel() {
                // Create Rocket Launcher model
                const rocketGroup = new THREE.Group();
                
                // Launcher tube (large)
                const tubeGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.8, 8);
                const tubeMaterial = new THREE.MeshBasicMaterial({ color: 0x2a4d2a });
                const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                tube.position.set(0, 0, -0.2);
                tube.rotation.x = Math.PI / 2;
                
                // Front cone
                const coneGeometry = new THREE.ConeGeometry(0.1, 0.15, 8);
                const coneMaterial = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
                const frontCone = new THREE.Mesh(coneGeometry, coneMaterial);
                frontCone.position.set(0, 0, -0.65);
                frontCone.rotation.x = Math.PI / 2;
                
                // Rear exhaust
                const exhaustGeometry = new THREE.CylinderGeometry(0.09, 0.07, 0.2, 8);
                const exhaustMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
                const exhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
                exhaust.position.set(0, 0, 0.25);
                exhaust.rotation.x = Math.PI / 2;
                
                // Grip
                const gripGeometry = new THREE.BoxGeometry(0.06, 0.12, 0.1);
                const gripMaterial = new THREE.MeshBasicMaterial({ color: 0x444444 });
                const grip = new THREE.Mesh(gripGeometry, gripMaterial);
                grip.position.set(0, -0.14, 0);
                
                // Shoulder rest
                const shoulderGeometry = new THREE.BoxGeometry(0.15, 0.08, 0.2);
                const shoulderMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
                const shoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
                shoulder.position.set(0, -0.06, 0.35);
                
                // Sight
                const sightGeometry = new THREE.BoxGeometry(0.03, 0.06, 0.1);
                const sightMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const sight = new THREE.Mesh(sightGeometry, sightMaterial);
                sight.position.set(0, 0.11, -0.1);
                
                // Muzzle flash (larger for rocket)
                const flashGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const muzzleFlash = new THREE.Mesh(
                    flashGeometry,
                    new THREE.MeshBasicMaterial({ 
                        color: 0xff6600, 
                        transparent: true, 
                        opacity: 0 
                    })
                );
                muzzleFlash.position.set(0, 0, -0.75);
                
                // Add all parts
                rocketGroup.add(tube);
                rocketGroup.add(frontCone);
                rocketGroup.add(exhaust);
                rocketGroup.add(grip);
                rocketGroup.add(shoulder);
                rocketGroup.add(sight);
                rocketGroup.add(muzzleFlash);
                
                // Set render order
                rocketGroup.traverse((child) => {
                    if (child.isMesh) child.renderOrder = 999;
                });
                muzzleFlash.renderOrder = 1000;
                
                // Store references (no magazine for rocket launcher)
                rocketGroup.userData.magazine = shoulder; // Use shoulder rest for reload animation
                rocketGroup.userData.muzzleFlash = muzzleFlash;
                
                this.weaponModels.rocket = rocketGroup;
                this.scene.add(rocketGroup);
                rocketGroup.visible = false;
            }

            createShotgunModel() {
                // Create Shotgun model
                const shotgunGroup = new THREE.Group();
                
                // Shotgun body (wider and shorter)
                const bodyGeometry = new THREE.BoxGeometry(0.15, 0.22, 0.6);
                const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x4a4a4a });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.set(0, 0, 0);
                
                // Double barrel
                const barrel1Geometry = new THREE.CylinderGeometry(0.035, 0.035, 0.5, 8);
                const barrel1Material = new THREE.MeshBasicMaterial({ color: 0x333333 });
                const barrel1 = new THREE.Mesh(barrel1Geometry, barrel1Material);
                barrel1.position.set(-0.04, 0.05, -0.4);
                barrel1.rotation.x = Math.PI / 2;
                
                const barrel2 = barrel1.clone();
                barrel2.position.set(0.04, 0.05, -0.4);
                
                // Shotgun stock
                const stockGeometry = new THREE.BoxGeometry(0.1, 0.15, 0.3);
                const stockMaterial = new THREE.MeshBasicMaterial({ color: 0x654321 });
                const stock = new THREE.Mesh(stockGeometry, stockMaterial);
                stock.position.set(0, -0.05, 0.35);
                
                // Shotgun grip
                const gripGeometry = new THREE.BoxGeometry(0.07, 0.14, 0.12);
                const gripMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
                const grip = new THREE.Mesh(gripGeometry, gripMaterial);
                grip.position.set(0, -0.14, 0.1);
                grip.rotation.z = -0.15;
                
                // Pump handle (used as magazine for reload animation)
                const pump = new THREE.Mesh(
                    new THREE.BoxGeometry(0.12, 0.08, 0.12),
                    new THREE.MeshBasicMaterial({ color: 0x777777 })
                );
                pump.position.set(0, -0.05, -0.2);
                
                // Muzzle flash (wider for shotgun)
                const flashGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const muzzleFlash = new THREE.Mesh(
                    flashGeometry,
                    new THREE.MeshBasicMaterial({ 
                        color: 0xffaa00, 
                        transparent: true, 
                        opacity: 0 
                    })
                );
                muzzleFlash.position.set(0, 0.05, -0.65);
                
                // Add all parts to shotgun group
                shotgunGroup.add(body);
                shotgunGroup.add(barrel1);
                shotgunGroup.add(barrel2);
                shotgunGroup.add(stock);
                shotgunGroup.add(grip);
                shotgunGroup.add(pump);
                shotgunGroup.add(muzzleFlash);
                
                // Set render order
                shotgunGroup.traverse((child) => {
                    if (child.isMesh) child.renderOrder = 999;
                });
                muzzleFlash.renderOrder = 1000;
                
                // Store references
                shotgunGroup.userData.magazine = pump; // Use pump as 'magazine' for animations
                shotgunGroup.userData.muzzleFlash = muzzleFlash;
                
                this.weaponModels.shotgun = shotgunGroup;
                this.scene.add(shotgunGroup);
                shotgunGroup.visible = false;
            }
            
            createWalkieTalkieModel() {
                // Create Walkie Talkie model
                const walkieGroup = new THREE.Group();
                
                // Main body
                const bodyGeometry = new THREE.BoxGeometry(0.08, 0.15, 0.04);
                const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.set(0, 0, 0);
                
                // Antenna
                const antennaGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.12, 4);
                const antennaMaterial = new THREE.MeshBasicMaterial({ color: 0x666666 });
                const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                antenna.position.set(0.02, 0.1, 0);
                
                // Screen/speaker area
                const screenGeometry = new THREE.BoxGeometry(0.06, 0.08, 0.001);
                const screenMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 });
                const screen = new THREE.Mesh(screenGeometry, screenMaterial);
                screen.position.set(0, 0, 0.021);
                
                // Red button
                const buttonGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.005, 6);
                const buttonMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const button = new THREE.Mesh(buttonGeometry, buttonMaterial);
                button.position.set(0, -0.04, 0.025);
                button.rotation.x = Math.PI / 2;
                
                walkieGroup.add(body, antenna, screen, button);
                
                // Position in hand
                walkieGroup.position.set(0.3, -0.3, -0.5);
                walkieGroup.rotation.set(0, -0.3, 0);
                walkieGroup.visible = false;
                
                // Store references (no magazine or muzzle flash for walkie)
                walkieGroup.userData.magazine = null;
                walkieGroup.userData.muzzleFlash = null;
                
                this.weaponModels.walkieTalkie = walkieGroup;
                this.scene.add(walkieGroup);
            }
            
            createAutoCannonModel() {
                // Create Auto Cannon model - heavy anti-materiel rifle
                const cannonGroup = new THREE.Group();
                
                // Long barrel
                const barrelGeometry = new THREE.CylinderGeometry(0.15, 0.15, 2.5, 8);
                const barrelMaterial = new THREE.MeshBasicMaterial({ color: 0x2a2a2a });
                const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                barrel.rotation.x = Math.PI / 2;
                barrel.position.set(0, 0, -1.25);
                
                // Muzzle brake (flat rectangle at end)
                const brakeGeometry = new THREE.BoxGeometry(0.5, 0.3, 0.1);
                const brakeMaterial = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
                const brake = new THREE.Mesh(brakeGeometry, brakeMaterial);
                brake.position.set(0, 0, -2.5);
                
                // Receiver body (width reduced to 0.28 - very slim profile)
                const receiverGeometry = new THREE.BoxGeometry(0.28, 0.5, 0.3);
                const receiverMaterial = new THREE.MeshBasicMaterial({ color: 0x3a3a3a });
                const receiver = new THREE.Mesh(receiverGeometry, receiverMaterial);
                receiver.position.set(0, -0.1, 0);
                
                // Scope on top
                const scopeGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 6);
                const scopeMaterial = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
                const scope = new THREE.Mesh(scopeGeometry, scopeMaterial);
                scope.rotation.x = Math.PI / 2;
                scope.position.set(0, 0.3, -0.3);
                
                // Scope mount (connects scope to receiver)
                const mountGeometry = new THREE.BoxGeometry(0.12, 0.05, 0.4);
                const mountMaterial = new THREE.MeshBasicMaterial({ color: 0x2a2a2a });
                const scopeMount = new THREE.Mesh(mountGeometry, mountMaterial);
                scopeMount.position.set(0, 0.17, -0.3);
                
                // Bipod legs
                const bipodGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 4);
                const bipodMaterial = new THREE.MeshBasicMaterial({ color: 0x2a2a2a });
                const bipod1 = new THREE.Mesh(bipodGeometry, bipodMaterial);
                bipod1.position.set(-0.15, -0.4, -1.0);
                bipod1.rotation.z = 0.3;
                const bipod2 = new THREE.Mesh(bipodGeometry, bipodMaterial);
                bipod2.position.set(0.15, -0.4, -1.0);
                bipod2.rotation.z = -0.3;
                
                // Magazine (smaller for 5 rounds)
                const magazineGeometry = new THREE.BoxGeometry(0.1, 0.3, 0.2);
                const magazineMaterial = new THREE.MeshBasicMaterial({ color: 0x2a2a2a });
                const magazine = new THREE.Mesh(magazineGeometry, magazineMaterial);
                magazine.position.set(0, -0.35, 0.3);
                
                // Muzzle flash (large blast for autocannon)
                const flashGeometry = new THREE.CylinderGeometry(0.5, 0.125, 1.0, 8);
                const flashMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0,
                    emissive: 0xffaa00,
                    emissiveIntensity: 2
                });
                const muzzleFlash = new THREE.Mesh(flashGeometry, flashMaterial);
                muzzleFlash.rotation.x = Math.PI / 2;
                muzzleFlash.position.set(0, 0, -3.3); // Position forward to emanate from muzzle brake
                muzzleFlash.visible = true;
                
                // Add all parts
                cannonGroup.add(barrel, brake, receiver, scope, scopeMount, bipod1, bipod2, magazine, muzzleFlash);
                
                // Position lower and further back for heavy weapon feel
                cannonGroup.position.set(0.7, -0.5, -1.2);
                cannonGroup.rotation.y = -0.1;
                cannonGroup.visible = false;
                
                // Store references
                cannonGroup.userData.magazine = magazine;
                cannonGroup.userData.muzzleFlash = muzzleFlash;
                
                this.weaponModels.autoCannon = cannonGroup;
                this.scene.add(cannonGroup);
            }
            
            createSwordModel() {
                // Create Sword model
                const swordGroup = new THREE.Group();
                
                // Sword blade - vertical with edge facing forward
                const bladeGeometry = new THREE.BoxGeometry(0.02, 1.0, 0.08);  // Swapped width and depth
                const bladeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xc0c0c0,
                    side: THREE.DoubleSide
                });
                const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                blade.position.set(0, 0.5, 0);  // Blade extends upward
                
                // Sword edge (sharper look) - also vertical, facing forward
                const edgeGeometry = new THREE.BoxGeometry(0.01, 1.0, 0.04);  // Swapped width and depth
                const edgeMaterial = new THREE.MeshBasicMaterial({ color: 0xe0e0e0 });
                const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
                edge.position.set(0, 0.5, 0);  // Edge extends upward
                
                // Sword hilt - vertical cylinder for handle
                const hiltGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.2, 8);
                const hiltMaterial = new THREE.MeshBasicMaterial({ color: 0x8b4513 });
                const hilt = new THREE.Mesh(hiltGeometry, hiltMaterial);
                hilt.position.set(0, -0.05, 0);
                // No rotation needed - cylinder is vertical by default
                
                // Sword guard - horizontal crossguard (perpendicular to blade edge)
                const guardGeometry = new THREE.BoxGeometry(0.03, 0.03, 0.25);  // Rotated to match blade orientation
                const guardMaterial = new THREE.MeshBasicMaterial({ color: 0x696969 });
                const guard = new THREE.Mesh(guardGeometry, guardMaterial);
                guard.position.set(0, 0.05, 0);  // At the base of the blade
                
                // Sword pommel - at bottom of hilt
                const pommelGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                const pommelMaterial = new THREE.MeshBasicMaterial({ color: 0x8b4513 });
                const pommel = new THREE.Mesh(pommelGeometry, pommelMaterial);
                pommel.position.set(0, -0.15, 0);  // At bottom of handle
                
                // Add all parts to sword group
                swordGroup.add(blade);
                swordGroup.add(edge);
                swordGroup.add(hilt);
                swordGroup.add(guard);
                swordGroup.add(pommel);
                
                // Position sword for first-person view - already vertical
                swordGroup.position.set(0.3, -0.4, -0.6);
                swordGroup.rotation.x = 0;  // No rotation needed, already vertical
                swordGroup.rotation.y = 0.1;  // Slight angle for better view
                swordGroup.rotation.z = 0.1;  // Slight tilt
                
                // Set render order
                swordGroup.traverse((child) => {
                    if (child.isMesh) child.renderOrder = 999;
                });
                
                // Store references (no magazine or muzzle flash for sword)
                swordGroup.userData.magazine = null;
                swordGroup.userData.muzzleFlash = null;
                
                this.weaponModels.sword = swordGroup;
                this.scene.add(swordGroup);
                swordGroup.visible = false;
            }

            createWarthogStrikeModel() {
                // Create Warthog Strike Walkie Talkie model (similar to airstrike but green button)
                const warthogGroup = new THREE.Group();
                
                // Main body
                const bodyGeometry = new THREE.BoxGeometry(0.08, 0.15, 0.04);
                const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.set(0, 0, 0);
                
                // Antenna
                const antennaGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.12, 4);
                const antennaMaterial = new THREE.MeshBasicMaterial({ color: 0x666666 });
                const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                antenna.position.set(0.02, 0.1, 0);
                
                // Screen/speaker area
                const screenGeometry = new THREE.BoxGeometry(0.06, 0.08, 0.001);
                const screenMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 });
                const screen = new THREE.Mesh(screenGeometry, screenMaterial);
                screen.position.set(0, 0, 0.021);
                
                // GREEN button (key difference from regular airstrike)
                const buttonGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.005, 6);
                const buttonMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const button = new THREE.Mesh(buttonGeometry, buttonMaterial);
                button.position.set(0, -0.04, 0.025);
                button.rotation.x = Math.PI / 2;
                
                warthogGroup.add(body, antenna, screen, button);
                
                // Position in hand
                warthogGroup.position.set(0.3, -0.3, -0.5);
                warthogGroup.rotation.set(0, -0.3, 0);
                warthogGroup.visible = false;
                
                // Store references (no magazine or muzzle flash for walkie)
                warthogGroup.userData.magazine = null;
                warthogGroup.userData.muzzleFlash = null;
                
                this.weaponModels.warthogStrike = warthogGroup;
                this.scene.add(warthogGroup);
            }

            switchWeapon(weaponType) {
                // Hide all weapons
                Object.values(this.weaponModels).forEach(model => {
                    model.visible = false;
                });
                
                // Show selected weapon
                this.currentWeapon = weaponType;
                this.weaponGroup = this.weaponModels[weaponType];
                this.weaponGroup.visible = true;
                
                // Update references for animation
                this.magazine = this.weaponGroup.userData.magazine;
                this.muzzleFlash = this.weaponGroup.userData.muzzleFlash;
                
                // Cancel reload if switching
                this.isReloading = false;
                this.hideReloadIndicator();
                
                // Clear zoom if switching away from autocannon
                if (this.isZoomed) {
                    this.clearZoom();
                }
                
                // Cancel any sword animations if switching away from sword
                if (this.isSwinging || this.isAreaSwinging || this.isWindingUp) {
                    this.isSwinging = false;
                    this.isAreaSwinging = false;
                    this.isWindingUp = false;
                    
                    // Reset sword combo state
                    this.swordCombo.count = 0;
                    this.swordCombo.canCombo = false;
                    this.swordCombo.queuedAttack = null;
                    this.swordCombo.currentAttack = null;
                }
                
                // Reset weapon position and rotation offsets
                this.weaponOffset = new THREE.Vector3(0.35, -0.25, -0.6);
                this.weaponRotationOffset = new THREE.Euler(0, -0.15, 0);
                
                // Reset swing offset to default position
                this.swingOffset = {
                    rotation: { x: 0, y: 0, z: 0 },
                    position: { x: 0, y: 0, z: 0 }
                };
                
                this.updateAmmoDisplay();
                console.log('Switched to', weaponType, 'with', this.weapons[weaponType].currentAmmo, 'rounds');
            }

            update(deltaTime, inputManager) {
                // Update weapon position to follow camera
                const camera = this.camera;
                
                // Update sword animations based on current state
                if (this.currentWeapon === 'sword') {
                    const now = performance.now() / 1000;
                    
                    // Handle wind-up animation
                    if (this.isWindingUp) {
                        const windUpProgress = Math.min((now - this.windUpStartTime) / this.windUpDuration, 1.0);
                        // Pull sword back and up for powerful horizontal swing
                        this.swingOffset.rotation.x = windUpProgress * 0.3;  // Tilt back slightly
                        this.swingOffset.rotation.y = -windUpProgress * 0.8;  // Turn sword to the right
                        this.swingOffset.rotation.z = windUpProgress * 0.6;  // Tilt right for wind-up
                        this.swingOffset.position.x = windUpProgress * 0.4;  // Move to right side
                        this.swingOffset.position.y = windUpProgress * 0.2;  // Raise slightly
                        this.swingOffset.position.z = windUpProgress * 0.1;  // Pull back a bit
                    }
                    // Handle area swing animation
                    else if (this.isAreaSwinging) {
                        const swingProgress = Math.min((now - this.areaSwingStartTime) / this.areaSwingDuration, 1.0);
                        
                        if (swingProgress >= 1.0) {
                            this.isAreaSwinging = false;
                            this.swingOffset = { rotation: { x: 0, y: 0, z: 0 }, position: { x: 0, y: 0, z: 0 } };
                        } else {
                            // Smooth transition from wind-up position to swing
                            const power = Math.sin(swingProgress * Math.PI);  // Power curve
                            
                            // Wind-up end values (where we start from)
                            const windUpRotX = 0.3;
                            const windUpRotY = -0.8;
                            const windUpRotZ = 0.6;
                            const windUpPosX = 0.4;
                            const windUpPosY = 0.2;
                            const windUpPosZ = 0.1;
                            
                            // Transition from wind-up to horizontal swing
                            if (swingProgress < 0.2) {
                                // First 20%: Transition to horizontal position
                                const transitionProg = swingProgress / 0.2;
                                this.swingOffset.rotation.x = windUpRotX * (1 - transitionProg);
                                this.swingOffset.rotation.y = windUpRotY * (1 - transitionProg * 0.5);  // Start turning
                                this.swingOffset.rotation.z = windUpRotZ + ((-Math.PI/2 - windUpRotZ) * transitionProg);  // Rotate to horizontal
                                
                                this.swingOffset.position.x = windUpPosX * (1 - transitionProg * 0.5);
                                this.swingOffset.position.y = windUpPosY * (1 - transitionProg) - 0.05;  // Lower by 25%
                                this.swingOffset.position.z = windUpPosZ - (transitionProg * 0.3);
                            } else {
                                // Remaining 80%: Full horizontal sweep
                                const sweepProg = (swingProgress - 0.2) / 0.8;
                                const sweepAngle = windUpRotY + (sweepProg * Math.PI * 2);  // Continue from wind-up angle
                                
                                this.swingOffset.rotation.x = 0;
                                this.swingOffset.rotation.y = sweepAngle;
                                this.swingOffset.rotation.z = -Math.PI / 2;  // Stay horizontal
                                
                                this.swingOffset.position.x = 0.2 - (sweepProg * 1.7);  // Sweep left
                                this.swingOffset.position.y = -0.1;  // Lowered by 25%
                                this.swingOffset.position.z = -0.4 - (power * 0.2);  // Extended forward
                            }
                        }
                    }
                    // Handle normal swing animation with combo system
                    else if (this.isSwinging) {
                        this.swingProgress = Math.min((now - this.swingStartTime) / this.swingDuration, 1.0);
                        
                        // Enable combo buffering in last 30% of animation
                        if (this.swingProgress >= 0.7) {
                            this.swordCombo.canCombo = true;
                        }
                        
                        if (this.swingProgress >= 1.0) {
                            this.isSwinging = false;
                            this.swingProgress = 0;
                            
                            // Advance combo counter
                            this.swordCombo.count = (this.swordCombo.count + 1) % 3;
                            
                            // Check for queued attack
                            if (this.swordCombo.queuedAttack) {
                                const queued = this.swordCombo.queuedAttack;
                                this.swordCombo.queuedAttack = null;
                                
                                if (queued.type === 'light') {
                                    // Chain into next attack immediately with proper parameters
                                    this.performMeleeAttack(queued.enemies, queued.player, queued.particleSystem, queued.gameManager, queued.uiManager);
                                } else if (queued.type === 'heavy') {
                                    // Perform heavy finisher directly
                                    this.swordCombo.currentAttack = 'heavyFinisher';
                                    this.swordCombo.count = 0;  // Reset combo after finisher
                                    this.isSwinging = true;
                                    this.swingStartTime = performance.now() / 1000;
                                    this.swingProgress = 0;
                                    this.swingDuration = this.swordAnimations.heavyFinisher.duration;
                                    this.audioManager.play('swordSwing');
                                    this.audioManager.play('swordSlam');  // Heavy slam sound
                                    
                                    // Perform the heavy finisher damage after a delay (at slam point)
                                    setTimeout(() => {
                                        if (this.isSwinging && this.swordCombo.currentAttack === 'heavyFinisher') {
                                            this.performHeavyFinisherDamage(queued.enemies, queued.player, queued.particleSystem, queued.gameManager, queued.uiManager);  // gameManager here is actually the FPSGame instance
                                        }
                                    }, 200);  // Faster delay for quicker animation
                                }
                            } else {
                                // Reset to idle if no queued attack
                                this.swingOffset = { rotation: { x: 0, y: 0, z: 0 }, position: { x: 0, y: 0, z: 0 } };
                                this.swordCombo.canCombo = false;
                            }
                        } else {
                            // Perform attack animation based on current combo attack
                            const swing = Math.sin(this.swingProgress * Math.PI);
                            const attackType = this.swordCombo.currentAttack || 'combo1';
                            
                            switch(attackType) {
                                case 'combo1': // Downward chop (existing animation)
                                    this.swingOffset.rotation.x = -swing * 1.4;
                                    this.swingOffset.rotation.y = 0;
                                    this.swingOffset.rotation.z = swing * 0.15;
                                    this.swingOffset.position.y = -swing * 0.6;
                                    this.swingOffset.position.z = -swing * 0.9;
                                    this.swingOffset.position.x = -swing * 0.5;
                                    break;
                                    
                                case 'combo2': // Diagonal upward slash
                                    this.swingOffset.rotation.x = swing * 1.2 - 0.6;  // Start low, swing up
                                    this.swingOffset.rotation.y = swing * 0.8;  // Diagonal angle
                                    this.swingOffset.rotation.z = -swing * 0.3;
                                    this.swingOffset.position.y = swing * 0.5 - 0.3;  // Upward motion
                                    this.swingOffset.position.z = -swing * 0.7;
                                    this.swingOffset.position.x = swing * 0.6 - 0.5;  // Right to left
                                    break;
                                    
                                case 'combo3': // Wide horizontal power sweep
                                    // Similar to area attack but faster and from neutral position
                                    this.swingOffset.rotation.x = -swing * 0.8;  // Tilt forward during swing
                                    this.swingOffset.rotation.y = (swing - 0.5) * 2.0;  // Wide sweep left to right
                                    this.swingOffset.rotation.z = swing * 0.3;  // Dynamic tilt
                                    this.swingOffset.position.y = -swing * 0.2;
                                    this.swingOffset.position.z = -swing * 1.0;  // Strong forward extension
                                    this.swingOffset.position.x = -swing * 0.7;  // Sweep across screen
                                    break;
                                    
                                case 'upSlash': // Upward vertical slash
                                    this.swingOffset.rotation.x = swing * 1.5 - 0.7;
                                    this.swingOffset.rotation.y = 0;
                                    this.swingOffset.rotation.z = 0;
                                    this.swingOffset.position.y = swing * 0.7 - 0.4;
                                    this.swingOffset.position.z = -swing * 0.6;
                                    this.swingOffset.position.x = -swing * 0.2;
                                    break;
                                    
                                case 'leftSlash': // Left horizontal slash
                                    this.swingOffset.rotation.x = -0.5;
                                    this.swingOffset.rotation.y = -swing * 1.2;
                                    this.swingOffset.rotation.z = -swing * 0.4;
                                    this.swingOffset.position.y = -0.1;
                                    this.swingOffset.position.z = -swing * 0.7;
                                    this.swingOffset.position.x = -swing * 0.8;
                                    break;
                                    
                                case 'rightSlash': // Right horizontal slash
                                    this.swingOffset.rotation.x = -0.5;
                                    this.swingOffset.rotation.y = swing * 1.2;
                                    this.swingOffset.rotation.z = swing * 0.4;
                                    this.swingOffset.position.y = -0.1;
                                    this.swingOffset.position.z = -swing * 0.7;
                                    this.swingOffset.position.x = swing * 0.8 - 0.3;
                                    break;
                                    
                                case 'heavyFinisher': // Heavy combo finisher
                                    // Faster, more aggressive slam
                                    const charge = Math.min(this.swingProgress * 3, 1);  // Very quick charge
                                    const slam = Math.max(0, (this.swingProgress - 0.2) * 1.25);  // Faster slam
                                    
                                    if (this.swingProgress < 0.2) {
                                        // Quick raise
                                        this.swingOffset.rotation.x = charge * 0.8;
                                        this.swingOffset.rotation.y = 0;
                                        this.swingOffset.rotation.z = charge * 0.2;
                                        this.swingOffset.position.y = charge * 0.5;
                                        this.swingOffset.position.z = charge * 0.2;
                                        this.swingOffset.position.x = -charge * 0.2;
                                    } else {
                                        // Fast slam down
                                        this.swingOffset.rotation.x = 0.8 - slam * 2.5;
                                        this.swingOffset.rotation.y = 0;
                                        this.swingOffset.rotation.z = 0.2 - slam * 0.3;
                                        this.swingOffset.position.y = 0.5 - slam * 1.2;
                                        this.swingOffset.position.z = 0.2 - slam * 1.4;
                                        this.swingOffset.position.x = -0.2 - slam * 0.5;
                                    }
                                    break;
                            }
                        }
                    }
                }
                
                // Calculate weapon world position based on camera
                const offset = this.weaponOffset.clone();
                offset.x += this.swingOffset.position.x;
                offset.y += this.swingOffset.position.y;
                offset.z += this.swingOffset.position.z;
                offset.applyQuaternion(camera.quaternion);
                this.weaponGroup.position.copy(camera.position).add(offset);
                
                // Update weapon rotation to match camera with offset
                this.weaponGroup.rotation.copy(camera.rotation);
                this.weaponGroup.rotation.x += this.swingOffset.rotation.x;
                this.weaponGroup.rotation.y += this.weaponRotationOffset.y + this.swingOffset.rotation.y;
                this.weaponGroup.rotation.z += this.swingOffset.rotation.z;
                
                // Handle left-hand SMG for akimbo effect during berserk
                if (this.currentWeapon === 'smg' && this.berserkActive && this.weaponModels.smgLeft) {
                    // Show left SMG
                    this.weaponModels.smgLeft.visible = true;
                    
                    // Calculate left-hand offset (mirror of right hand)
                    const leftOffset = new THREE.Vector3(-0.35, -0.25, -0.6); // Mirrored X position
                    leftOffset.x += this.swingOffset.position.x;
                    leftOffset.y += this.swingOffset.position.y;
                    leftOffset.z += this.swingOffset.position.z;
                    leftOffset.applyQuaternion(camera.quaternion);
                    
                    // Position left SMG
                    this.weaponModels.smgLeft.position.copy(camera.position).add(leftOffset);
                    
                    // Rotate left SMG to match camera with mirrored rotation
                    this.weaponModels.smgLeft.rotation.copy(camera.rotation);
                    this.weaponModels.smgLeft.rotation.x += this.swingOffset.rotation.x;
                    this.weaponModels.smgLeft.rotation.y += -this.weaponRotationOffset.y + this.swingOffset.rotation.y; // Mirror Y rotation
                    this.weaponModels.smgLeft.rotation.z += -this.swingOffset.rotation.z; // Mirror Z rotation
                } else if (this.weaponModels.smgLeft) {
                    // Hide left SMG when not in berserk mode or not using SMG
                    this.weaponModels.smgLeft.visible = false;
                }
                
                // Update weapon sway based on mouse movement
                if (inputManager.isPointerLocked) {
                    const mouseDelta = inputManager.getMouseDelta();
                    this.weaponSway.x += mouseDelta.x * this.swayAmount;
                    this.weaponSway.y += mouseDelta.y * this.swayAmount;
                }
                
                // Smooth weapon sway
                this.weaponSway.x *= 0.95;
                this.weaponSway.y *= 0.95;
                
                // Smooth recoil
                this.recoil.x *= 0.92;
                this.recoil.y *= 0.92;
                
                // Update screen shake
                if (this.screenShake && this.screenShake.duration > 0) {
                    this.screenShake.duration -= deltaTime * 1000; // Convert to ms
                    
                    if (this.screenShake.duration > 0) {
                        // Apply shake offset
                        const shakeX = (Math.random() - 0.5) * this.screenShake.intensity;
                        const shakeY = (Math.random() - 0.5) * this.screenShake.intensity;
                        
                        // Temporarily offset camera rotation
                        this.camera.rotation.x += shakeY;
                        this.camera.rotation.z += shakeX;
                        
                        // Immediately reset on next frame (creates snap effect)
                        setTimeout(() => {
                            this.camera.rotation.x -= shakeY;
                            this.camera.rotation.z -= shakeX;
                        }, 16); // ~1 frame at 60fps
                    } else {
                        // Ensure camera is reset when shake ends
                        this.screenShake.intensity = 0;
                    }
                }
                
                // Apply sway and recoil to weapon
                this.weaponGroup.rotation.x += this.weaponSway.y + this.recoil.y;
                this.weaponGroup.rotation.y += this.weaponSway.x + this.recoil.x;
                
                // Update trigger state for semi-auto weapons
                if (!inputManager.isMousePressed()) {
                    this.triggerReleased = true;
                }
                
                // Handle reloading with animation
                if (this.isReloading) {
                    const weaponData = this.weapons[this.currentWeapon];
                    const reloadProgress = (performance.now() / 1000 - this.reloadStartTime) / weaponData.reloadTime;
                    
                    // Reload animation
                    if (reloadProgress < 0.3) {
                        // Drop magazine
                        const dropPhase = reloadProgress / 0.3;
                        this.magazine.position.y = -0.1 - dropPhase * 0.25;
                        this.weaponGroup.rotation.x += dropPhase * 0.2;
                        
                        // Also animate left SMG magazine if in berserk mode
                        if (this.currentWeapon === 'smg' && this.berserkActive && this.weaponModels.smgLeft) {
                            const leftMag = this.weaponModels.smgLeft.userData.magazine;
                            if (leftMag) {
                                leftMag.position.y = -0.1 - dropPhase * 0.25;
                            }
                        }
                    } else if (reloadProgress < 0.7) {
                        // Insert new magazine
                        const insertPhase = (reloadProgress - 0.3) / 0.4;
                        this.magazine.position.y = -0.35 + insertPhase * 0.25;
                        this.weaponGroup.rotation.x += 0.2 * (1 - insertPhase);
                        
                        // Also animate left SMG magazine if in berserk mode
                        if (this.currentWeapon === 'smg' && this.berserkActive && this.weaponModels.smgLeft) {
                            const leftMag = this.weaponModels.smgLeft.userData.magazine;
                            if (leftMag) {
                                leftMag.position.y = -0.35 + insertPhase * 0.25;
                            }
                        }
                    } else {
                        // Rack slide
                        const rackPhase = (reloadProgress - 0.7) / 0.3;
                        this.magazine.position.y = -0.1;
                        // Move weapon forward and back
                        const rackOffset = Math.sin(rackPhase * Math.PI) * 0.1;
                        this.weaponOffset.z = -0.6 + rackOffset;
                        
                        // Also reset left SMG magazine if in berserk mode
                        if (this.currentWeapon === 'smg' && this.berserkActive && this.weaponModels.smgLeft) {
                            const leftMag = this.weaponModels.smgLeft.userData.magazine;
                            if (leftMag) {
                                leftMag.position.y = -0.1;
                            }
                        }
                    }
                    
                    if (reloadProgress >= 1.0) {
                        this.finishReload();
                        // Reset magazine position
                        this.magazine.position.y = -0.1;
                        this.weaponOffset.z = -0.6;
                        
                        // Also reset left SMG magazine if in berserk mode
                        if (this.currentWeapon === 'smg' && this.berserkActive && this.weaponModels.smgLeft) {
                            const leftMag = this.weaponModels.smgLeft.userData.magazine;
                            if (leftMag) {
                                leftMag.position.y = -0.1;
                            }
                        }
                    }
                }
            }

            canShoot(isMousePressed) {
                const now = performance.now() / 1000;
                const weaponData = this.weapons[this.currentWeapon];
                
                // Calculate effective fire rate with BERSERK bonus
                let effectiveFireRate = weaponData.fireRate;
                if (this.berserkActive) {
                    if (this.currentWeapon === 'smg') {
                        effectiveFireRate *= 0.75; // 25% faster fire rate
                    } else if (this.currentWeapon === 'rocket') {
                        effectiveFireRate *= 0.5; // Double fire rate
                    }
                }
                
                // Special fire rate limiting for semi-auto weapons like autocannon
                if (weaponData.isSemiAuto) {
                    const timeSinceLastFire = Date.now() - weaponData.lastFireTime;
                    const minTimeBetweenShots = weaponData.fireRate * 1000; // Convert seconds to milliseconds
                    if (timeSinceLastFire < minTimeBetweenShots) {
                        return false;
                    }
                }
                
                // Sword doesn't need ammo checks
                if (weaponData.isMelee) {
                    if (this.isSwinging) return false;
                    if (this.isWindingUp) return false;  // Prevent left-click during wind-up
                    if (this.isAreaSwinging) return false;  // Also prevent during area swing
                    if ((now - this.lastShotTime) < effectiveFireRate) return false;
                } else {
                    // Check basic conditions (Blood Thirst bypasses ammo check)
                    if (this.isReloading) return false;
                    if (!this.bloodThirstActive && weaponData.currentAmmo <= 0) return false;
                    if ((now - this.lastShotTime) < effectiveFireRate) return false;
                }
                
                // For non-automatic weapons, require trigger release between shots
                if (!weaponData.isAutomatic) {
                    if (!this.triggerReleased) return false;
                    if (isMousePressed) {
                        this.triggerReleased = false;
                    }
                }
                
                return true;
            }

            shoot(bulletPool, particleSystem, isMousePressed, enemies, player, gameManager, uiManager) {
                if (!this.canShoot(isMousePressed)) return [];

                const weaponData = this.weapons[this.currentWeapon];
                
                // Handle airstrike targeting
                if (this.currentWeapon === 'walkieTalkie') {
                    if (this.player && this.player.startAirstrikeTargeting) {
                        this.player.startAirstrikeTargeting();
                    }
                    return [];
                }
                
                // Handle warthog strike targeting
                if (this.currentWeapon === 'warthogStrike') {
                    if (this.player && this.player.startWarthogStrikeTargeting) {
                        this.player.startWarthogStrikeTargeting();
                    }
                    return [];
                }
                
                // Handle sword swing (melee attack)
                if (weaponData.isMelee) {
                    return this.performMeleeAttack(enemies, player, particleSystem, gameManager, uiManager);
                }
                // Don't decrement ammo during Blood Thirst (bottomless magazine)
                if (!this.bloodThirstActive) {
                    weaponData.currentAmmo--;  // Decrement the weapon's own ammo
                }
                this.lastShotTime = performance.now() / 1000;
                
                // Add recoil (all weapons tip upward)
                this.recoil.x += (Math.random() - 0.5) * weaponData.recoilAmount;
                this.recoil.y += weaponData.recoilAmount; // All weapons tip upward with recoil
                
                // Add screen shake
                if (weaponData.screenShake) {
                    this.addScreenShake(weaponData.screenShake);
                }
                
                // Muzzle flash effect (longer for autocannon with shrinking effect)
                if (this.muzzleFlash) {
                    if (this.currentWeapon === 'autoCannon') {
                        // Full size and opacity for first 50ms
                        this.muzzleFlash.material.opacity = 1;
                        this.muzzleFlash.material.emissiveIntensity = 3;
                        this.muzzleFlash.scale.set(1.25, 1.25, 1.25);
                        
                        // After 50ms, shrink to half size and change to yellow
                        setTimeout(() => {
                            if (this.muzzleFlash) {
                                this.muzzleFlash.scale.set(0.625, 0.625, 0.625);
                                this.muzzleFlash.material.opacity = 0.7;
                                this.muzzleFlash.material.color.setHex(0xffff00); // Yellow
                                this.muzzleFlash.material.emissive.setHex(0xffff00); // Yellow emissive
                                this.muzzleFlash.material.emissiveIntensity = 2;
                            }
                        }, 50);
                        
                        // After 100ms total, hide completely and reset
                        setTimeout(() => {
                            if (this.muzzleFlash) {
                                this.muzzleFlash.material.opacity = 0;
                                this.muzzleFlash.scale.set(1, 1, 1); // Reset scale for next shot
                                this.muzzleFlash.material.color.setHex(0xffaa00); // Reset to orange
                                this.muzzleFlash.material.emissive.setHex(0xffaa00); // Reset emissive to orange
                            }
                        }, 100);
                    } else {
                        this.muzzleFlash.material.opacity = 1;
                        setTimeout(() => {
                            if (this.muzzleFlash) this.muzzleFlash.material.opacity = 0;
                        }, 50);
                    }
                }
                
                // Also trigger left SMG muzzle flash if in berserk mode
                if (this.currentWeapon === 'smg' && this.berserkActive && this.weaponModels.smgLeft) {
                    const leftFlash = this.weaponModels.smgLeft.userData.muzzleFlash;
                    if (leftFlash) {
                        leftFlash.material.opacity = 1;
                        setTimeout(() => {
                            if (leftFlash) leftFlash.material.opacity = 0;
                        }, 50);
                    }
                }
                
                // Get base shoot direction from camera
                const baseDirection = new THREE.Vector3(0, 0, -1);
                baseDirection.applyQuaternion(this.camera.quaternion);
                
                const bullets = [];
                const startPos = this.camera.position.clone();
                startPos.add(baseDirection.clone().multiplyScalar(0.5));
                
                // Modify shotgun pellets based on perks
                let projectileCount = weaponData.projectileCount;
                if (weaponData.isShotgun) {
                    if (this.berserkActive && this.bloodThirstActive) {
                        projectileCount = 36; // BERSERK + Blood Thirst: 6 * 2 * 3 = 36
                    } else if (this.berserkActive) {
                        projectileCount = 18; // BERSERK only: 6 * 3 = 18
                    } else if (this.bloodThirstActive) {
                        projectileCount = 12; // Blood Thirst only: 6 * 2 = 12
                    }
                }
                
                // Fire multiple projectiles for shotgun or single for others
                for (let i = 0; i < projectileCount; i++) {
                    const bullet = bulletPool.get();
                    
                    // Apply spread
                    const direction = baseDirection.clone();
                    if (weaponData.spread > 0) {
                        direction.x += (Math.random() - 0.5) * weaponData.spread;
                        direction.y += (Math.random() - 0.5) * weaponData.spread;
                        direction.normalize();
                    }
                    
                    // Configure bullet properties (apply Blood Thirst multiplier)
                    const damageMultiplier = this.player && this.player.getDamageMultiplier ? 
                        this.player.getDamageMultiplier() : 1.0;
                    bullet.damage = weaponData.damage * damageMultiplier;
                    
                    // Special properties for 30mm shells
                    if (weaponData.bulletType === '30mmShell') {
                        bullet.is30mmShell = true;
                        bullet.weapon = 'autoCannon'; // Track weapon for headshot effects
                        bullet.isRocket = false; // Not a rocket, but can explode
                        bullet.speed = weaponData.bulletSpeed || 200; // 2x normal speed
                        bullet.shellBlastRadius = 5; // 50% of rocket radius
                        // Update fire time for rate limiting
                        weaponData.lastFireTime = Date.now();
                    }
                    // Special properties for rockets
                    else if (weaponData.isRocket) {
                        bullet.isRocket = true;
                        // Increase blast radius by 2.5x during Hellfire (doubles base + 25%)
                        bullet.blastRadius = this.hellfireActive ? weaponData.blastRadius * 2.5 : weaponData.blastRadius;
                        bullet.speed = weaponData.projectileSpeed;
                        bullet.isHellfireRocket = this.hellfireActive; // Mark Hellfire rockets
                    } else {
                        // Hellfire makes all bullets explosive
                        if (this.hellfireActive) {
                            bullet.isRocket = true; // Make bullet explosive
                            bullet.blastRadius = 2; // 25% of rocket's normal 8 radius
                            bullet.isHellfireBullet = true; // Mark for smaller particle effect
                            bullet.speed = 100; // Keep normal bullet speed
                            // Increase damage by 25% for Hellfire bullets
                            bullet.damage = bullet.damage * 1.25;
                        } else {
                            // Reset to normal bullet properties
                            bullet.isRocket = false;
                            bullet.isHellfireBullet = false;
                            bullet.isHellfireRocket = false;
                            bullet.speed = 100; // Default bullet speed
                            bullet.is30mmShell = false;
                        }
                    }
                    
                    // Set weapon type on bullet for dismemberment checks
                    bullet.weapon = this.currentWeapon;
                    
                    bullet.fire(startPos, direction);
                    bullets.push(bullet);
                }
                
                // Create muzzle flash - Disabled
                // const muzzlePos = startPos.clone().add(baseDirection.clone().multiplyScalar(0.3));
                // particleSystem.createMuzzleFlash(muzzlePos, baseDirection);
                
                // Play appropriate sound
                if (this.currentWeapon === 'autoCannon') {
                    // For autocannon, play only first 500ms
                    const sound = this.audioManager.sounds['autocannon_fire'];
                    if (sound) {
                        const instance = sound.instances[sound.currentIndex];
                        instance.currentTime = 0;
                        instance.playbackRate = this.audioManager.globalPlaybackRate;
                        instance.play().catch(e => console.log('Audio play failed:', e));
                        
                        // Stop after 500ms
                        setTimeout(() => {
                            instance.pause();
                            instance.currentTime = 0;
                        }, 500);
                        
                        sound.currentIndex = (sound.currentIndex + 1) % sound.instances.length;
                    }
                    
                    // Layer autocannon_fire2 on top (play in full, no cutoff)
                    const sound2 = this.audioManager.sounds['autocannon_fire2'];
                    if (sound2) {
                        const instance2 = sound2.instances[sound2.currentIndex];
                        instance2.currentTime = 0;
                        instance2.playbackRate = this.audioManager.globalPlaybackRate;
                        instance2.play().catch(e => console.log('Audio play failed:', e));
                        
                        // Let it play in full - no cutoff
                        
                        sound2.currentIndex = (sound2.currentIndex + 1) % sound2.instances.length;
                    }
                } else {
                    this.audioManager.play(weaponData.soundName);
                }
                
                // Layer Blood Thirst shot sound when perk is active
                if (this.bloodThirstActive) {
                    this.audioManager.play('bloodthirstyShot');
                }
                
                // Layer BERSERK shot sound when perk is active
                if (this.berserkActive) {
                    this.audioManager.play('berserkShot');
                }
                
                // Layer Hellfire shot sound when perk is active
                if (this.hellfireActive) {
                    this.audioManager.play('hellfireShot');
                }
                
                this.updateAmmoDisplay();
                return bullets;
            }

            startReload() {
                const weaponData = this.weapons[this.currentWeapon];
                if (this.isReloading || weaponData.currentAmmo >= weaponData.maxAmmo || this.reserveAmmo <= 0) {
                    return false;
                }
                
                this.isReloading = true;
                this.reloadStartTime = performance.now() / 1000;
                this.audioManager.play('reload');
                this.showReloadIndicator();
                return true;
            }

            finishReload() {
                const weaponData = this.weapons[this.currentWeapon];
                const needed = weaponData.maxAmmo - weaponData.currentAmmo;
                const toReload = Math.min(needed, this.reserveAmmo);
                
                weaponData.currentAmmo += toReload;
                this.reserveAmmo -= toReload;
                this.isReloading = false;
                
                this.updateAmmoDisplay();
                this.hideReloadIndicator();
            }

            addAmmo(amount) {
                this.reserveAmmo = Math.min(this.reserveAmmo + amount, this.maxReserve);
                this.updateAmmoDisplay();
            }
            
            addScreenShake(intensity) {
                if (!this.screenShake) {
                    this.screenShake = { x: 0, y: 0, intensity: 0, duration: 0 };
                }
                // Set shake intensity and duration (quick snap)
                this.screenShake.intensity = intensity;
                this.screenShake.duration = 50; // 50ms duration for quick snap effect
            }

            activateBloodThirst() {
                this.bloodThirstActive = true;
                
                // Instantly fill all weapon magazines
                for (let weaponName in this.weapons) {
                    this.weapons[weaponName].currentAmmo = this.weapons[weaponName].maxAmmo;
                }
                
                // Update display
                this.updateAmmoDisplay();
            }
            
            deactivateBloodThirst() {
                this.bloodThirstActive = false;
                this.updateAmmoDisplay();
            }
            
            activateHellfire() {
                this.hellfireActive = true;
            }
            
            deactivateHellfire() {
                this.hellfireActive = false;
            }
            
            activateBerserk() {
                this.berserkActive = true;
            }
            
            deactivateBerserk() {
                this.berserkActive = false;
            }
            
            startWindUp() {
                if (this.currentWeapon !== 'sword') return;
                
                this.isWindingUp = true;
                this.windUpStartTime = performance.now() / 1000;
                // Reset any existing animations
                this.isSwinging = false;
                this.isAreaSwinging = false;
            }
            
            performHeavyFinisherDamage(enemies, player, particleSystem, gameInstance, uiManager) {
                if (!gameInstance) return [];
                
                // Calculate explosion position (on ground in front of player)
                const playerPos = this.camera.position.clone();
                const lookDirection = new THREE.Vector3(0, 0, -1);
                lookDirection.applyQuaternion(this.camera.quaternion);
                
                // Place explosion 3 units in front of player, on the ground
                const explosionPos = playerPos.clone();
                explosionPos.add(lookDirection.multiplyScalar(3));
                explosionPos.y = 0;  // Ground level
                
                // IMPORTANT: gameInstance is the FPSGame instance, not GameManager
                // Use gameInstance's current enemies array
                
                // Use the game's existing explosion system but with white effects
                this.handleHeavyFinisherExplosion(explosionPos, gameInstance);
                
                return [];
            }
            
            handleHeavyFinisherExplosion(position, gameInstance) {
                // Play explosion sound
                this.audioManager.play('rocketExplosion');
                
                // Create WHITE explosion effect (instead of yellow/orange)
                if (gameInstance.particleSystem) {
                    gameInstance.particleSystem.createExplosion(position, 0xffffff, 60);  // White core
                    gameInstance.particleSystem.createExplosion(position, 0xcccccc, 40);  // Light gray mid
                    gameInstance.particleSystem.createExplosion(position, 0x888888, 30);  // Gray outer
                    
                    // Create white sparks radiating outward
                    for (let i = 0; i < 30; i++) {
                        const sparkVelocity = new THREE.Vector3(
                            (Math.random() - 0.5) * 30,
                            Math.random() * 20,
                            (Math.random() - 0.5) * 30
                        );
                        gameInstance.particleSystem.createSpark(position.clone(), sparkVelocity, 0xffffff);  // White sparks
                    }
                    
                    // Add shockwave
                    gameInstance.particleSystem.createShockwave(position, false);
                }
                
                // Add screen shake
                this.addScreenShake(0.15);
                
                // Heavy finisher explosion parameters
                const blastRadius = 8;  // Slightly larger than rocket
                const damage = 250;  // Very high damage to ensure kills
                
                // Store enemies to process to avoid array modification issues
                const enemiesInBlast = [];
                
                // First pass: collect all enemies in blast radius
                for (let i = 0; i < gameInstance.enemies.length; i++) {
                    const enemy = gameInstance.enemies[i];
                    if (!enemy.active) continue;
                    
                    const distance = enemy.position.distanceTo(position);
                    
                    if (distance <= blastRadius) {
                        // Calculate damage falloff
                        const falloff = 1 - (distance / blastRadius) * 0.5;
                        const explosionDamage = damage * falloff;
                        
                        // Store enemy with calculated damage for processing
                        enemiesInBlast.push({
                            enemy: enemy,
                            damage: explosionDamage,
                            distance: distance
                        });
                    }
                }
                
                // Second pass: process all enemies in blast (avoids array modification issues)
                const killedEnemies = [];
                
                for (const target of enemiesInBlast) {
                    const enemy = target.enemy;
                    
                    // Skip if enemy was already destroyed by another effect
                    if (!enemy.active || enemy.isDead) continue;
                    
                    // Play hit sound for each enemy in blast (like rockets do)
                    this.audioManager.play('enemyHit');
                    gameInstance.particleSystem.createExplosion(enemy.position, 0xff4444, 10);
                    
                    // Apply knockback force
                    const force = enemy.position.clone().sub(position).normalize();
                    force.multiplyScalar(15);
                    force.y = Math.abs(force.y) + 10;
                    
                    // Check if enemy will be killed
                    const willKill = (target.damage >= enemy.hp);
                    
                    if (willKill) {
                        // Play death sound (like rockets do)
                        this.audioManager.play('enemyDie');
                        
                        // Track enemy position before destroying
                        const enemyPos = enemy.position ? enemy.position.clone() : position.clone();
                        
                        // Set HP to 0 but don't call takeDamage to avoid double destroy
                        enemy.hp = 0;
                        enemy.updateHealthBar();
                        
                        // Call destroy with explosion force for dismemberment
                        enemy.destroy(10, position);
                        
                        // Play explosion sound if needed
                        if (enemy.shouldPlayExplodeSound) {
                            this.audioManager.play('enemyExplode');
                        }
                        
                        // Update game state - gameInstance is FPSGame, so use gameInstance.gameManager for GameManager methods
                        gameInstance.gameManager.addScore((enemy.scoreValue || 100) * 2);  // Double score
                        gameInstance.gameManager.addKill();
                        if (gameInstance.player) {
                            gameInstance.player.registerKill();  // For Blood Thirst and Hellfire
                            if (gameInstance.player.registerSwordKill) {
                                gameInstance.player.registerSwordKill();  // For Adrenaline - this is a sword kill!
                            }
                        }
                        if (gameInstance.uiManager) {
                            gameInstance.uiManager.addKillMessage(`HEAVY FINISHER! +${(enemy.scoreValue || 100) * 2}`);
                        }
                        
                        // Chance for pickups
                        if (Math.random() < 0.3) {
                            const pickupType = Math.random() < 0.5 ? 'health' : 'ammo';
                            gameInstance.spawnPickup(pickupType, enemyPos);
                        }
                        
                        // Store killed enemy for later removal
                        killedEnemies.push(enemy);
                    } else {
                        // Enemy damaged but not killed
                        enemy.takeDamage(target.damage);
                    }
                }
                
                // Remove all killed enemies from the array after processing
                for (const killedEnemy of killedEnemies) {
                    const index = gameInstance.enemies.indexOf(killedEnemy);
                    if (index > -1) {
                        gameInstance.enemies.splice(index, 1);
                    }
                }
                
                if (killedEnemies.length > 0 && gameInstance.uiManager) {
                    gameInstance.uiManager.updateEnemyCount(gameInstance.enemies.length);
                }
                
                // Note: No player damage check for heavy finisher
            }
            
            performAreaAttack(enemies, player, particleSystem, gameManagerOrInstance, uiManager) {
                if (this.currentWeapon !== 'sword' || !this.isWindingUp) return [];
                
                // Handle both cases: sometimes we get GameManager, sometimes FPSGame instance
                let gameManager, gameInstance;
                if (gameManagerOrInstance && gameManagerOrInstance.addScore) {
                    // It's the GameManager
                    gameManager = gameManagerOrInstance;
                    gameInstance = null;
                } else if (gameManagerOrInstance && gameManagerOrInstance.gameManager) {
                    // It's the FPSGame instance
                    gameInstance = gameManagerOrInstance;
                    gameManager = gameInstance.gameManager;
                } else {
                    gameManager = null;
                    gameInstance = null;
                }
                
                // Stop wind-up and start area swing
                this.isWindingUp = false;
                this.isAreaSwinging = true;
                this.areaSwingStartTime = performance.now() / 1000;
                
                // Play swing sound
                this.audioManager.play('swordSwing');
                
                // Perform area attack
                const hitEnemies = [];
                const playerPos = this.camera.position;
                const lookDirection = new THREE.Vector3(0, 0, -1);
                lookDirection.applyQuaternion(this.camera.quaternion);
                
                // Wider range and angle for area attack
                const areaRange = 8; // Wider range than normal attack
                const areaAngle = 160; // Much wider angle
                const areaDamage = 100; // Higher damage for charged attack
                
                // Check each enemy for area hit
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (!enemy || !enemy.active) continue;
                    
                    const distance = playerPos.distanceTo(enemy.position);
                    
                    // Check if enemy is in range
                    if (distance <= areaRange) {
                        // Check if enemy is in front of player (within swing arc)
                        const toEnemy = enemy.position.clone().sub(playerPos).normalize();
                        const angle = Math.acos(lookDirection.dot(toEnemy)) * (180 / Math.PI);
                        
                        if (angle <= areaAngle / 2) {
                            // Hit detected!
                            hitEnemies.push(enemy);
                            
                            // Get hit position for effects
                            const hitPosition = enemy.position.clone();
                            hitPosition.y += enemy.size * 0.5;
                            
                            // Play hit sounds
                            this.audioManager.play('swordHit1');
                            this.audioManager.play('swordHit2');
                            this.audioManager.play('enemyHit');
                            
                            // Create bigger blood effect for area attack
                            if (particleSystem) {
                                particleSystem.createExplosion(hitPosition, 0xff4444, 25);
                            }
                            
                            // Apply damage with knockback
                            const knockback = toEnemy.multiplyScalar(10);
                            enemy.position.add(knockback);
                            
                            // Apply damage with Blood Thirst multiplier
                            const bloodThirstMultiplier = player && player.getDamageMultiplier ? 
                                player.getDamageMultiplier() : 1.0;
                            const totalDamage = areaDamage * bloodThirstMultiplier;
                            
                            const killed = enemy.takeDamage(totalDamage);
                            
                            if (killed) {
                                // Enemy killed
                                if (gameManager) {
                                    gameManager.addScore(enemy.scoreValue || 100);
                                    gameManager.addKill();
                                }
                                
                                // Register kill for perks
                                if (player) {
                                    if (player.registerKill) {
                                        player.registerKill(); // For Blood Thirst and Hellfire
                                    }
                                    if (player.registerSwordKill) {
                                        player.registerSwordKill(); // For Adrenaline
                                    }
                                }
                                
                                if (uiManager) {
                                    uiManager.addKillMessage(`Area Attack Kill! +${enemy.scoreValue || 100}`);
                                }
                                
                                // Create death explosion
                                if (particleSystem) {
                                    particleSystem.createExplosion(enemy.position, 0xff0000, 30);
                                }
                                
                                this.audioManager.play('enemyDie');
                                
                                // Random pickup chance
                                if (Math.random() < 0.3) {
                                    const pickupType = Math.random() < 0.5 ? 'health' : 'ammo';
                                    // Use gameInstance if available (has spawnPickup method)
                                    if (gameInstance && gameInstance.spawnPickup) {
                                        gameInstance.spawnPickup(pickupType, enemy.position.clone());
                                    }
                                }
                                
                                // Don't remove from array here - let main game loop handle it
                            }
                        }
                    }
                }
                
                // Screen shake for dramatic effect
                this.addScreenShake(0.15);
                
                return hitEnemies;
            }
            
            performMeleeAttack(enemies, player, particleSystem, gameManagerOrInstance, uiManager) {
                // Safety check: Don't perform melee attack if winding up or area swinging
                if (this.isWindingUp || this.isAreaSwinging) {
                    return [];
                }
                
                const weaponData = this.weapons[this.currentWeapon];
                const now = performance.now() / 1000;
                this.lastShotTime = now;
                
                // Handle both cases: sometimes we get GameManager, sometimes FPSGame instance
                let gameManager, gameInstance;
                if (gameManagerOrInstance && gameManagerOrInstance.addScore) {
                    // It's the GameManager
                    gameManager = gameManagerOrInstance;
                    gameInstance = null;
                } else if (gameManagerOrInstance && gameManagerOrInstance.gameManager) {
                    // It's the FPSGame instance
                    gameInstance = gameManagerOrInstance;
                    gameManager = gameInstance.gameManager;
                } else {
                    gameManager = null;
                    gameInstance = null;
                }
                
                // Update combo state
                if (now - this.swordCombo.lastAttackTime > this.swordCombo.comboWindow) {
                    // Reset combo if too much time passed
                    this.swordCombo.count = 0;
                }
                
                // Determine attack type based on combo count
                let attackType = 'combo1';
                if (this.swordCombo.count === 1) attackType = 'combo2';
                else if (this.swordCombo.count === 2) attackType = 'combo3';
                
                // Check for directional input (if mouse moved significantly during attack)
                if (this.swordCombo.directionalInput) {
                    const dir = this.swordCombo.directionalInput;
                    if (Math.abs(dir.x) > Math.abs(dir.y)) {
                        attackType = dir.x > 0 ? 'rightSlash' : 'leftSlash';
                    } else if (dir.y < -0.3) {
                        attackType = 'upSlash';
                    }
                }
                
                // Set current attack
                this.swordCombo.currentAttack = attackType;
                this.swordCombo.lastAttackTime = now;
                
                // Start swing animation
                this.isSwinging = true;
                this.swingStartTime = now;
                this.swingProgress = 0;
                this.swingDuration = this.swordAnimations[attackType].duration;
                
                // Play appropriate swing sound based on attack type
                if (attackType === 'combo3' || attackType === 'heavyFinisher') {
                    this.audioManager.play('swordSwing');
                    this.audioManager.play('swordHit2');  // Extra woosh for heavy attacks
                } else {
                    this.audioManager.play('swordSwing');
                }
                
                // Check for hits
                const hitEnemies = [];
                let enemiesKilledCount = 0; // Just count how many we killed
                const playerPos = this.camera.position;
                const lookDirection = new THREE.Vector3(0, 0, -1);
                lookDirection.applyQuaternion(this.camera.quaternion);
                
                // Check each enemy for melee hit
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (!enemy || !enemy.active) continue;
                    
                    const distance = playerPos.distanceTo(enemy.position);
                    
                    // Check if enemy is in range
                    if (distance <= weaponData.meleeRange) {
                        // Check if enemy is in front of player (within swing arc)
                        const toEnemy = enemy.position.clone().sub(playerPos).normalize();
                        const angle = Math.acos(lookDirection.dot(toEnemy)) * (180 / Math.PI);
                        
                        if (angle <= weaponData.swingAngle / 2) {
                            // Hit detected!
                            hitEnemies.push(enemy);
                            
                            // Get hit position for effects
                            const hitPosition = enemy.position.clone();
                            hitPosition.y += enemy.size * 0.5; // Hit at mid-height
                            
                            // Play all hit sounds
                            this.audioManager.play('swordHit1');
                            this.audioManager.play('swordHit2');
                            this.audioManager.play('enemyHit');
                            
                            // Create blood particle effect
                            if (particleSystem) {
                                particleSystem.createExplosion(hitPosition, 0xff4444, 15);
                            }
                            
                            // Calculate combo damage multiplier
                            let comboDamageMultiplier = 1.0;
                            if (this.swordCombo.currentAttack === 'combo2') comboDamageMultiplier = 1.25;
                            else if (this.swordCombo.currentAttack === 'combo3') comboDamageMultiplier = 1.5;
                            else if (this.swordCombo.currentAttack === 'heavyFinisher') comboDamageMultiplier = 2.0;
                            
                            // 10% chance to play grunt sound
                            if (Math.random() < 0.1) {
                                this.audioManager.play('enemyGrunt');
                            }
                            
                            // Apply damage with combo AND Blood Thirst multipliers
                            const bloodThirstMultiplier = player && player.getDamageMultiplier ? 
                                player.getDamageMultiplier() : 1.0;
                            const damage = weaponData.damage * comboDamageMultiplier * bloodThirstMultiplier;
                            
                            const killed = enemy.takeDamage(damage);
                            
                            if (killed) {
                                // Enemy killed - play death sound
                                this.audioManager.play('enemyDie');
                                
                                // 1/6 chance to play death grunt
                                if (Math.random() < 1/6) {
                                    this.audioManager.play('enemyDeathGrunt');
                                }
                                
                                // Check for dismemberment (high damage melee kills)
                                if (damage >= 100 && particleSystem) {
                                    // Dismember on high damage sword kills
                                    try {
                                        const enemyPos = enemy.position ? enemy.position.clone() : new THREE.Vector3();
                                        const playerPos = player.position ? player.position.clone() : new THREE.Vector3();
                                        const forceDirection = enemyPos.sub(playerPos).normalize();
                                        particleSystem.createDismemberment(enemy.position, 'melee', forceDirection);
                                    } catch (error) {
                                        console.warn('Dismemberment error in melee kill:', error);
                                    }
                                }
                                
                                // Add score and kills
                                if (gameManager) {
                                    gameManager.addScore(enemy.scoreValue);
                                    gameManager.addKill();
                                }
                                
                                // Register kill for perks
                                if (player) {
                                    if (player.registerKill) {
                                        player.registerKill(); // For Blood Thirst and Hellfire
                                    }
                                    if (player.registerSwordKill) {
                                        player.registerSwordKill(); // For Adrenaline
                                    }
                                }
                                
                                // Update UI
                                if (uiManager) {
                                    uiManager.addKillMessage(`Enemy eliminated +${enemy.scoreValue}`);
                                }
                                
                                // Random pickup chance
                                if (Math.random() < 0.3) {
                                    const pickupType = Math.random() < 0.5 ? 'health' : 'ammo';
                                    // Use gameInstance if available (has spawnPickup method)
                                    if (gameInstance && gameInstance.spawnPickup) {
                                        gameInstance.spawnPickup(pickupType, enemy.position.clone());
                                    }
                                }
                                
                                // Increment killed count
                                enemiesKilledCount++;
                                
                                // The main game loop will remove dead enemies
                            }
                        }
                    }
                }
                
                // The main game loop will handle updating enemy count when it removes dead enemies
                
                // Add screen shake if we hit something
                if (hitEnemies.length > 0 && weaponData.screenShake) {
                    this.addScreenShake(weaponData.screenShake);
                }
                
                return []; // No bullets for melee
            }
            
            updateAmmoDisplay() {
                const weaponData = this.weapons[this.currentWeapon];
                
                // Handle sword (no ammo display)
                if (weaponData.isMelee) {
                    document.getElementById('currentAmmo').textContent = '-';
                    document.getElementById('reserveAmmo').textContent = '-';
                } else if (this.currentWeapon === 'walkieTalkie') {
                    // Walkie talkie shows ready status
                    document.getElementById('currentAmmo').textContent = 'READY';
                    document.getElementById('reserveAmmo').textContent = '-';
                } else if (this.currentWeapon === 'warthogStrike') {
                    // Warthog strike shows ready status
                    document.getElementById('currentAmmo').textContent = 'READY';
                    document.getElementById('reserveAmmo').textContent = '-';
                } else if (this.bloodThirstActive) {
                    // Show infinity symbol during Blood Thirst
                    document.getElementById('currentAmmo').textContent = '∞';
                    document.getElementById('reserveAmmo').textContent = '∞';
                } else {
                    document.getElementById('currentAmmo').textContent = weaponData.currentAmmo;
                    document.getElementById('reserveAmmo').textContent = this.reserveAmmo;
                }
                
                // Update weapon name
                const weaponNames = {
                    'smg': 'SMG',
                    'shotgun': 'SHOTGUN',
                    'rocket': 'ROCKET',
                    'sword': 'SWORD',
                    'walkieTalkie': 'AIRSTRIKE',
                    'warthogStrike': 'A10 WARTHOG',
                    'autoCannon': 'AUTO CANNON'
                };
                document.getElementById('weaponName').textContent = weaponNames[this.currentWeapon] || 'WEAPON';
                
                // Color code based on ammo level
                const ammoElement = document.getElementById('currentAmmo');
                const ammoPercent = weaponData.currentAmmo / weaponData.maxAmmo;
                
                if (ammoPercent === 0) {
                    ammoElement.style.color = '#ff0000';
                } else if (ammoPercent <= 0.33) {
                    ammoElement.style.color = '#ffaa00';
                } else {
                    ammoElement.style.color = '#00ff00';
                }
            }

            showReloadIndicator() {
                document.getElementById('reloadIndicator').style.display = 'block';
            }

            hideReloadIndicator() {
                document.getElementById('reloadIndicator').style.display = 'none';
            }
            
            toggleZoom() {
                if (this.currentWeapon !== 'autoCannon') return;
                
                this.isZoomed = !this.isZoomed;
                
                // Play zoom sound
                this.audioManager.play('autocannon_zoom');
                
                if (this.isZoomed) {
                    // Apply zoom
                    this.camera.fov = this.zoomFOV;
                    this.camera.updateProjectionMatrix();
                    
                    // Create scope overlay if it doesn't exist
                    if (!this.scopeOverlay) {
                        this.createScopeOverlay();
                    }
                    this.scopeOverlay.style.display = 'block';
                } else {
                    // Reset FOV
                    this.camera.fov = this.defaultFOV;
                    this.camera.updateProjectionMatrix();
                    
                    // Hide scope overlay
                    if (this.scopeOverlay) {
                        this.scopeOverlay.style.display = 'none';
                    }
                }
            }
            
            createScopeOverlay() {
                // Create scope overlay div
                this.scopeOverlay = document.createElement('div');
                this.scopeOverlay.style.position = 'fixed';
                this.scopeOverlay.style.top = '0';
                this.scopeOverlay.style.left = '0';
                this.scopeOverlay.style.width = '100%';
                this.scopeOverlay.style.height = '100%';
                this.scopeOverlay.style.pointerEvents = 'none';
                this.scopeOverlay.style.zIndex = '999';
                this.scopeOverlay.style.display = 'none';
                
                // Create crosshair
                const crosshair = document.createElement('div');
                crosshair.style.position = 'absolute';
                crosshair.style.top = '50%';
                crosshair.style.left = '50%';
                crosshair.style.transform = 'translate(-50%, -50%)';
                crosshair.style.width = '200px';
                crosshair.style.height = '200px';
                
                // Horizontal line
                const hLine = document.createElement('div');
                hLine.style.position = 'absolute';
                hLine.style.top = '50%';
                hLine.style.left = '0';
                hLine.style.width = '100%';
                hLine.style.height = '2px';
                hLine.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
                hLine.style.transform = 'translateY(-50%)';
                
                // Vertical line
                const vLine = document.createElement('div');
                vLine.style.position = 'absolute';
                vLine.style.left = '50%';
                vLine.style.top = '0';
                vLine.style.height = '100%';
                vLine.style.width = '2px';
                vLine.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
                vLine.style.transform = 'translateX(-50%)';
                
                // Center dot
                const dot = document.createElement('div');
                dot.style.position = 'absolute';
                dot.style.top = '50%';
                dot.style.left = '50%';
                dot.style.width = '4px';
                dot.style.height = '4px';
                dot.style.backgroundColor = 'rgba(255, 0, 0, 0.9)';
                dot.style.transform = 'translate(-50%, -50%)';
                dot.style.borderRadius = '50%';
                
                crosshair.appendChild(hLine);
                crosshair.appendChild(vLine);
                crosshair.appendChild(dot);
                this.scopeOverlay.appendChild(crosshair);
                
                // Add vignette effect for scope
                const vignette = document.createElement('div');
                vignette.style.position = 'absolute';
                vignette.style.top = '0';
                vignette.style.left = '0';
                vignette.style.width = '100%';
                vignette.style.height = '100%';
                vignette.style.background = 'radial-gradient(circle, transparent 30%, rgba(0,0,0,0.4) 70%, rgba(0,0,0,0.8) 100%)';
                this.scopeOverlay.appendChild(vignette);
                
                document.body.appendChild(this.scopeOverlay);
            }
            
            clearZoom() {
                if (this.isZoomed) {
                    this.isZoomed = false;
                    this.camera.fov = this.defaultFOV;
                    this.camera.updateProjectionMatrix();
                    
                    if (this.scopeOverlay) {
                        this.scopeOverlay.style.display = 'none';
                    }
                }
            }
        }

        // Input handling system
        class InputManager {
            constructor() {
                this.keys = {};
                this.mouse = { x: 0, y: 0, deltaX: 0, deltaY: 0, leftButton: false };
                this.isPointerLocked = false;
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // Keyboard events
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // Mouse events
                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        this.mouse.deltaX = e.movementX || 0;
                        this.mouse.deltaY = e.movementY || 0;
                    }
                });

                document.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        this.mouse.leftButton = true;
                    } else if (e.button === 2) {  // Right click
                        this.mouse.rightButton = true;
                        e.preventDefault();
                    }
                });

                document.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        this.mouse.leftButton = false;
                    } else if (e.button === 2) {  // Right click
                        this.mouse.rightButton = false;
                        e.preventDefault();
                    }
                });
                
                // Pointer lock events
                // Removed automatic pointer lock on click - now only triggered by Start Game button
                
                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === document.body;
                });

                // Prevent context menu
                document.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            }
            
            requestPointerLock() {
                document.body.requestPointerLock();
            }
            
            releasePointerLock() {
                document.exitPointerLock();
            }
            
            isKeyPressed(keyCode) {
                return !!this.keys[keyCode];
            }

            isMousePressed() {
                return this.mouse.leftButton;
            }
            
            isRightButtonDown() {
                return this.mouse.rightButton;
            }
            
            getMouseDelta() {
                const delta = { x: this.mouse.deltaX, y: this.mouse.deltaY };
                return delta;
            }
            
            resetMouseDelta() {
                this.mouse.deltaX = 0;
                this.mouse.deltaY = 0;
            }
        }

        // Player class with FPS movement and combat
        class Player {
            constructor(camera, scene, audioManager) {
                this.camera = camera;
                this.scene = scene;
                this.audioManager = audioManager;
                
                // Movement properties
                this.velocity = new THREE.Vector3();
                this.position = new THREE.Vector3(0, 2, 0);
                this.rotation = { x: 0, y: 0 };
                
                // Physics constants
                this.speed = 8;
                this.sprintMultiplier = 1.8;
                this.jumpForce = 8;
                this.gravity = -25;
                this.friction = 0.85;
                this.airFriction = 0.95;
                this.mouseSensitivity = 0.002;
                
                // Combat properties
                this.maxHealth = 100;
                this.health = this.maxHealth;
                this.healthRegenRate = 5; // HP per second
                this.healthRegenDelay = 3; // seconds after taking damage
                this.lastDamageTime = 0;
                
                // Blood Thirst perk system
                this.killTimes = []; // Track kill timestamps
                this.bloodThirstActive = false;
                this.bloodThirstEndTime = 0;
                this.bloodThirstDuration = 10; // seconds
                this.bloodThirstKillsRequired = 4; // kills needed in rapid succession
                this.bloodThirstTimeWindow = 5; // seconds to get 4 kills
                
                // Hellfire perk system
                this.hellfireActive = false;
                this.hellfireEndTime = 0;
                this.hellfireDuration = 5; // seconds
                this.hellfireKillsRequired = 10; // kills needed in rapid succession
                this.hellfireTimeWindow = 10; // seconds to get 10 kills
                
                // Adrenaline perk system
                this.adrenalineActive = false;
                this.adrenalineStacks = 0;
                this.adrenalineEndTime = 0;
                this.adrenalineDuration = 5; // seconds per stack
                this.adrenalineKillsRequired = 3; // sword kills needed in rapid succession
                this.adrenalineTimeWindow = 3; // seconds to get 3 sword kills
                this.swordKillTimes = []; // Track sword kill timestamps
                this.baseSpeed = 7.5; // Store base speed
                this.maxAdrenalineStacks = 3;
                
                // BERSERK perk system
                this.berserkActive = false;
                this.berserkEndTime = 0;
                this.berserkDuration = 10; // seconds
                this.berserkKillsRequired = 15; // kills needed in a combo
                this.comboKillCount = 0; // Current combo count
                this.lastKillTime = 0;
                this.comboTimeWindow = 5; // seconds between kills to maintain combo
                
                // SLOWMO perk system
                this.slowmoActive = false;
                this.slowmoEndTime = 0;
                this.slowmoDuration = 5; // seconds
                this.slowmoHeadshotsRequired = 3; // headshots needed in rapid succession
                this.headshotTimes = []; // Track headshot timestamps
                this.headshotTimeWindow = 3; // seconds to get 3 headshots
                this.timeScale = 1.0; // Normal time scale
                
                // AIRSTRIKE perk system
                this.airstrikeAvailable = false;
                this.airstrikeKillsRequired = 8; // kills needed in a combo
                this.airstrikeCooldownTime = 30; // 30 second cooldown
                this.airstrikeCooldownEndTime = 0;
                this.isTargetingAirstrike = false;
                
                // WARTHOG STRIKE perk system
                this.warthogStrikeAvailable = false;
                this.warthogStrikeKillsRequired = 12; // More kills needed than regular airstrike
                this.warthogStrikeCooldownTime = 45; // Longer cooldown
                this.warthogStrikeCooldownEndTime = 0;
                this.isTargetingWarthogStrike = false;
                
                // State
                this.isGrounded = false;
                this.canJump = true;
                this.height = 1.8;
                this.standingHeight = 1.8;
                this.crouchHeight = 0.9;
                this.isMoving = false;
                this.lastFootstepTime = 0;
                this.footstepInterval = 0.5; // seconds
                
                // Crouch and slide mechanics
                this.isCrouching = false;
                this.isSliding = false;
                this.slideVelocity = new THREE.Vector3();
                this.slideSpeed = 15; // Base slide speed
                this.slideFriction = 0.98; // Initial friction (very low)
                this.slideTimer = 0; // Track slide duration
                this.slideMinSpeed = 2; // Minimum speed to maintain slide
                this.wasInAir = false; // Track if player was in air last frame
                this.isSprinting = false; // Track sprint state
                
                // Momentum system
                this.momentumMultiplier = 1.0; // Current momentum multiplier
                this.slideChainCount = 0; // Number of successful slide chains
                this.lastSlideEndTime = 0; // Time when last slide ended
                this.slideHopWindow = 0.3; // Window for perfect slide-hop (seconds)
                this.inFlowState = false; // Flow state from chaining
                this.currentSpeed = 0; // Track current movement speed
                this.maxSpeed = 30; // Maximum possible speed
                
                // FOV for speed effects
                this.baseFOV = 75;
                this.currentFOV = 75;
                this.targetFOV = 75;
                
                this.setupCamera();
                this.updateHealthDisplay();
            }
            
            setupCamera() {
                this.camera.position.copy(this.position);
                this.camera.rotation.order = 'YXZ';
            }
            
            update(deltaTime, inputManager, collisionObjects) {
                // Track air state before collision updates
                this.wasInAir = !this.isGrounded;
                
                this.handleMouseLook(inputManager);
                this.handleMovement(deltaTime, inputManager);
                this.handlePhysics(deltaTime);
                this.handleCollisions(collisionObjects);
                this.handleHealthRegen(deltaTime);
                this.updateCamera();
                this.handleFootsteps(deltaTime);
            }
            
            handleMouseLook(inputManager) {
                if (!inputManager.isPointerLocked) return;
                
                const mouseDelta = inputManager.getMouseDelta();
                
                this.rotation.y -= mouseDelta.x * this.mouseSensitivity;
                this.rotation.x -= mouseDelta.y * this.mouseSensitivity;
                
                // Reset mouse delta after camera update
                inputManager.resetMouseDelta();
                
                // Clamp vertical rotation
                this.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.rotation.x));
            }
            
            handleMovement(deltaTime, inputManager) {
                if (!inputManager.isPointerLocked) return;
                
                // Track previous states
                const wasCrouching = this.isCrouching;
                const wasGrounded = this.isGrounded;
                const wasSprinting = this.isSprinting;
                
                // Update current states
                this.isCrouching = inputManager.isKeyPressed('KeyC');
                this.isSprinting = inputManager.isKeyPressed('ShiftLeft') && !this.isCrouching;
                
                // Update camera height for crouch
                if (this.isCrouching && !wasCrouching) {
                    // Start crouching - lower camera smoothly
                    this.height = this.crouchHeight;
                } else if (!this.isCrouching && wasCrouching && !this.isSliding) {
                    // Stop crouching - raise camera (unless sliding)
                    this.height = this.standingHeight;
                }
                
                // Calculate current speed for momentum tracking
                this.currentSpeed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.z * this.velocity.z);
                
                // Check for slide initiation
                const justLanded = this.wasInAir && this.isGrounded;
                const landingWithCrouch = justLanded && this.isCrouching;
                const sprintToCrouch = wasSprinting && !wasCrouching && this.isCrouching && this.isGrounded;
                const walkToCrouch = !wasSprinting && !wasCrouching && this.isCrouching && this.isGrounded && this.isMoving;
                
                if ((landingWithCrouch || sprintToCrouch || walkToCrouch) && !this.isSliding) {
                    // Initiate slide with momentum-based speed
                    this.isSliding = true;
                    this.slideTimer = 0;
                    
                    // Calculate speed multiplier based on entry type
                    let speedMultiplier = 1.0;
                    if (landingWithCrouch) {
                        speedMultiplier = 1.8; // Air → Slide bonus
                    } else if (sprintToCrouch) {
                        speedMultiplier = 1.5; // Sprint → Slide bonus
                    } else if (walkToCrouch) {
                        speedMultiplier = 1.3; // Walk → Slide bonus
                    }
                    
                    // Apply chain bonus if within hop window
                    const timeSinceLastSlide = performance.now() / 1000 - this.lastSlideEndTime;
                    if (timeSinceLastSlide < this.slideHopWindow) {
                        this.slideChainCount++;
                        if (this.slideChainCount >= 3) {
                            this.inFlowState = true;
                            speedMultiplier *= 1.2; // Flow state bonus
                        } else {
                            speedMultiplier *= 1.1; // Chain bonus
                        }
                    } else {
                        this.slideChainCount = 0;
                        this.inFlowState = false;
                    }
                    
                    // Set slide velocity with momentum
                    const velocityMagnitude = this.currentSpeed;
                    if (velocityMagnitude > 1) {
                        // Use current velocity direction
                        this.slideVelocity.set(this.velocity.x, 0, this.velocity.z);
                        this.slideVelocity.normalize().multiplyScalar(Math.max(this.slideSpeed, velocityMagnitude) * speedMultiplier);
                    } else {
                        // Use camera forward if not moving
                        const forward = new THREE.Vector3();
                        forward.x = Math.sin(this.rotation.y);
                        forward.z = Math.cos(this.rotation.y);
                        forward.normalize();
                        this.slideVelocity.copy(forward).multiplyScalar(this.slideSpeed * speedMultiplier);
                    }
                    
                    // Cap at max speed
                    if (this.slideVelocity.length() > this.maxSpeed) {
                        this.slideVelocity.normalize().multiplyScalar(this.maxSpeed);
                    }
                    
                    // Play slide sound
                    this.audioManager.play('slide_ground');
                    
                    // Update FOV for speed effect
                    const speedRatio = this.slideVelocity.length() / this.maxSpeed;
                    this.targetFOV = this.baseFOV + (15 * speedRatio); // Up to +15 FOV at max speed
                }
                
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                
                // Calculate movement directions based on Y rotation only
                forward.x = Math.sin(this.rotation.y);
                forward.z = Math.cos(this.rotation.y);
                forward.normalize();
                
                right.x = Math.cos(this.rotation.y);
                right.z = -Math.sin(this.rotation.y);
                right.normalize();
                
                // Handle slide physics
                if (this.isSliding) {
                    this.slideTimer += deltaTime;
                    
                    // Dynamic friction based on slide duration
                    let currentFriction;
                    if (this.slideTimer < 0.5) {
                        currentFriction = 0.98; // Almost no friction initially
                    } else if (this.slideTimer < 1.0) {
                        currentFriction = 0.95; // Gentle slowdown
                    } else {
                        currentFriction = 0.90; // Noticeable but not harsh
                    }
                    
                    // Apply friction
                    this.slideVelocity.multiplyScalar(currentFriction);
                    
                    // Check for slide end conditions
                    const shouldEndSlide = (this.slideVelocity.length() < this.slideMinSpeed && this.slideTimer > 0.5) || 
                                          !this.isCrouching || 
                                          (!this.isGrounded && !inputManager.isKeyPressed('Space'));
                    
                    if (shouldEndSlide) {
                        // End slide
                        this.isSliding = false;
                        this.lastSlideEndTime = performance.now() / 1000;
                        
                        // Preserve momentum on crouch release
                        if (!this.isCrouching) {
                            this.height = this.standingHeight;
                            // Transfer some slide velocity to normal movement
                            this.velocity.x = this.slideVelocity.x * 0.5;
                            this.velocity.z = this.slideVelocity.z * 0.5;
                        }
                        
                        this.slideVelocity.set(0, 0, 0);
                        this.targetFOV = this.baseFOV;
                    } else {
                        // Apply slide velocity
                        this.velocity.x = this.slideVelocity.x;
                        this.velocity.z = this.slideVelocity.z;
                        
                        // Allow slight directional control based on speed
                        const slideControlFactor = 0.1 + (0.1 * (this.slideVelocity.length() / this.maxSpeed)); // More control at higher speeds
                        const moveVector = new THREE.Vector3();
                        
                        if (inputManager.isKeyPressed('KeyW')) moveVector.sub(forward);
                        if (inputManager.isKeyPressed('KeyS')) moveVector.add(forward);
                        if (inputManager.isKeyPressed('KeyA')) moveVector.sub(right);
                        if (inputManager.isKeyPressed('KeyD')) moveVector.add(right);
                        
                        if (moveVector.length() > 0) {
                            moveVector.normalize();
                            this.slideVelocity.add(moveVector.multiplyScalar(slideControlFactor));
                        }
                    }
                    
                    this.isMoving = this.slideVelocity.length() > 0;
                } else {
                    // Normal movement when not sliding
                    const moveVector = new THREE.Vector3();
                    this.isMoving = false;
                    
                    // Movement input
                    if (inputManager.isKeyPressed('KeyW')) {
                        moveVector.sub(forward);
                        this.isMoving = true;
                    }
                    if (inputManager.isKeyPressed('KeyS')) {
                        moveVector.add(forward);
                        this.isMoving = true;
                    }
                    if (inputManager.isKeyPressed('KeyA')) {
                        moveVector.sub(right);
                        this.isMoving = true;
                    }
                    if (inputManager.isKeyPressed('KeyD')) {
                        moveVector.add(right);
                        this.isMoving = true;
                    }
                    
                    // Normalize diagonal movement
                    if (moveVector.length() > 0) {
                        moveVector.normalize();
                        
                        // Apply sprint multiplier and perk boosts
                        let currentSpeed = this.speed;
                        
                        // Apply Adrenaline speed boost (10% per stack)
                        if (this.adrenalineActive) {
                            currentSpeed = this.baseSpeed * (1 + 0.1 * this.adrenalineStacks);
                        }
                        
                        // Apply BERSERK speed boost (15% increase)
                        if (this.berserkActive) {
                            currentSpeed *= 1.15;
                        }
                        
                        if (this.isSprinting) {
                            currentSpeed *= this.sprintMultiplier;
                        } else if (this.isCrouching) {
                            currentSpeed *= 0.4; // Slower movement when crouched
                        }
                        
                        // Apply movement to velocity
                        const acceleration = moveVector.multiplyScalar(currentSpeed * deltaTime * 10);
                        this.velocity.x += acceleration.x;
                        this.velocity.z += acceleration.z;
                    }
                }
                
                // Jumping - special handling for slide-hop
                if (inputManager.isKeyPressed('Space') && this.isGrounded && this.canJump) {
                    // Play jump sound
                    this.audioManager.play('player_jump');
                    
                    if (this.isSliding) {
                        // Slide-hop mechanics
                        const slideProgress = this.slideTimer / 1.5; // Assume 1.5s is full slide
                        let momentumPreservation = 0.5; // Default preservation
                        
                        if (slideProgress >= 0.8) {
                            momentumPreservation = 0.9; // Perfect timing
                        } else if (slideProgress >= 0.6) {
                            momentumPreservation = 0.7; // Good timing
                        }
                        
                        // End slide but preserve momentum
                        this.velocity.x = this.slideVelocity.x * momentumPreservation;
                        this.velocity.z = this.slideVelocity.z * momentumPreservation;
                        this.velocity.y = this.jumpForce;
                        
                        this.isSliding = false;
                        this.slideVelocity.set(0, 0, 0);
                        this.lastSlideEndTime = performance.now() / 1000;
                        this.isGrounded = false;
                        this.canJump = false;
                        
                        // Stand up from slide
                        this.isCrouching = false;
                        this.height = this.standingHeight;
                        
                        // Maintain higher FOV briefly
                        this.targetFOV = this.baseFOV + 5;
                    } else {
                        // Normal jump
                        this.velocity.y = this.jumpForce;
                        this.isGrounded = false;
                        this.canJump = false;
                        
                        // If jumping while crouched, stand up
                        if (this.isCrouching) {
                            this.isCrouching = false;
                            this.height = this.standingHeight;
                        }
                    }
                }
                
                if (!inputManager.isKeyPressed('Space')) {
                    this.canJump = true;
                }
            }

            handleFootsteps(deltaTime) {
                // No footsteps while sliding or in air
                if (!this.isMoving || !this.isGrounded || this.isSliding) {
                    return;
                }
                
                // Adjust footstep interval based on movement state
                let currentInterval = 0.5; // Base interval (half second)
                
                if (this.isSprinting) {
                    currentInterval = 0.35; // Faster footsteps while sprinting
                } else if (this.isCrouching) {
                    currentInterval = 0.7; // Slower footsteps while crouched
                }
                
                const now = performance.now() / 1000;
                if (now - this.lastFootstepTime >= currentInterval) {
                    // Randomly select one of the three footstep sounds
                    const footstepNumber = Math.floor(Math.random() * 3) + 1;
                    const footstepSound = `player_footstep${footstepNumber}`;
                    
                    // Play the selected footstep sound
                    this.audioManager.play(footstepSound);
                    this.lastFootstepTime = now;
                }
            }
            
            handlePhysics(deltaTime) {
                // Apply gravity
                this.velocity.y += this.gravity * deltaTime;
                
                // Apply friction (unless sliding)
                if (!this.isSliding) {
                    if (this.isGrounded) {
                        this.velocity.x *= Math.pow(this.friction, deltaTime * 60);
                        this.velocity.z *= Math.pow(this.friction, deltaTime * 60);
                    } else {
                        this.velocity.x *= Math.pow(this.airFriction, deltaTime * 60);
                        this.velocity.z *= Math.pow(this.airFriction, deltaTime * 60);
                    }
                }
                
                // Update position
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
            }
            
            handleCollisions(collisionObjects) {
                // Track if we just landed
                const wasAirborne = this.wasInAir;
                
                // Ground collision
                if (this.position.y <= this.height) {
                    this.position.y = this.height;
                    if (this.velocity.y < 0) {
                        this.velocity.y = 0;
                        
                        // Check if we just landed
                        if (!this.isGrounded && wasAirborne) {
                            // Play landing sound
                            this.audioManager.play('player_land');
                        }
                        
                        this.isGrounded = true;
                    }
                } else {
                    this.isGrounded = false;
                }
                
                // Wall collisions (simple AABB)
                const playerRadius = 0.5;
                
                for (let obj of collisionObjects) {
                    const box = new THREE.Box3().setFromObject(obj);
                    
                    // Expand box by player radius
                    box.expandByScalar(playerRadius);
                    
                    if (box.containsPoint(this.position)) {
                        // Find closest point on the box to push player out
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        
                        const dx = this.position.x - center.x;
                        const dz = this.position.z - center.z;
                        
                        // Push out in the direction of least penetration
                        if (Math.abs(dx / size.x) > Math.abs(dz / size.z)) {
                            // Push out in X direction
                            this.position.x = center.x + Math.sign(dx) * (size.x / 2);
                            this.velocity.x = 0;
                        } else {
                            // Push out in Z direction
                            this.position.z = center.z + Math.sign(dz) * (size.z / 2);
                            this.velocity.z = 0;
                        }
                    }
                }
            }

            handleHealthRegen(deltaTime) {
                const now = performance.now() / 1000;
                if (this.health < this.maxHealth && 
                    (now - this.lastDamageTime) >= this.healthRegenDelay) {
                    this.health = Math.min(this.health + this.healthRegenRate * deltaTime, this.maxHealth);
                    this.updateHealthDisplay();
                }
            }

            takeDamage(damage) {
                // Invulnerable during BERSERK
                if (this.berserkActive) {
                    return false; // No damage taken
                }
                
                this.health = Math.max(0, this.health - damage);
                this.lastDamageTime = performance.now() / 1000;
                this.updateHealthDisplay();
                this.showDamageFlash();
                this.audioManager.play('playerHit');
                return this.health <= 0;
            }

            heal(amount) {
                this.health = Math.min(this.health + amount, this.maxHealth);
                this.updateHealthDisplay();
            }

            updateHealthDisplay() {
                const healthPercent = (this.health / this.maxHealth) * 100;
                document.getElementById('healthBar').style.width = healthPercent + '%';
                document.getElementById('healthText').textContent = Math.ceil(this.health);
            }

            showDamageFlash() {
                const flash = document.getElementById('damageFlash');
                flash.style.opacity = '1';
                setTimeout(() => {
                    flash.style.opacity = '0';
                }, 200);
            }
            
            updateCamera() {
                this.camera.position.copy(this.position);
                this.camera.rotation.x = this.rotation.x;
                this.camera.rotation.y = this.rotation.y;
                
                // Smooth FOV transitions for speed effects
                if (Math.abs(this.currentFOV - this.targetFOV) > 0.1) {
                    this.currentFOV += (this.targetFOV - this.currentFOV) * 0.1;
                    this.camera.fov = this.currentFOV;
                    this.camera.updateProjectionMatrix();
                }
                
                // Add slight camera tilt during slide
                if (this.isSliding) {
                    const tiltAmount = (this.slideVelocity.length() / this.maxSpeed) * 0.1; // Up to 0.1 radians tilt
                    this.camera.rotation.z = Math.sin(performance.now() * 0.003) * tiltAmount;
                } else {
                    // Smooth return to normal
                    this.camera.rotation.z *= 0.9;
                }
            }

            getPosition() {
                return this.position.clone();
            }

            isDead() {
                return this.health <= 0;
            }
            
            registerKill() {
                const now = performance.now() / 1000;
                
                // Add kill to tracking
                this.killTimes.push(now);
                
                // Update combo kill count for BERSERK and AIRSTRIKE
                if (now - this.lastKillTime <= this.comboTimeWindow) {
                    this.comboKillCount++;
                } else {
                    this.comboKillCount = 1; // Reset combo if too much time passed
                }
                this.lastKillTime = now;
                
                // Debug logging for airstrike
                console.log(`Kill registered! Combo: ${this.comboKillCount}/${this.airstrikeKillsRequired} (${this.comboTimeWindow}s window)`);
                console.log(`Airstrike available: ${this.airstrikeAvailable}, Cooldown ends: ${this.airstrikeCooldownEndTime}, Now: ${now}`);
                
                // Check for AIRSTRIKE (8 kill combo) - only if not on cooldown and not already available
                if (this.comboKillCount >= this.airstrikeKillsRequired && 
                    !this.airstrikeAvailable && 
                    now >= this.airstrikeCooldownEndTime) {
                    console.log('AIRSTRIKE UNLOCKED!');
                    this.activateAirstrike();
                }
                
                // Check for WARTHOG STRIKE (12 kill combo) - only if not on cooldown and not already available
                if (this.comboKillCount >= this.warthogStrikeKillsRequired && 
                    !this.warthogStrikeAvailable && 
                    now >= this.warthogStrikeCooldownEndTime) {
                    console.log('WARTHOG STRIKE UNLOCKED!');
                    this.activateWarthogStrike();
                }
                
                // Check for BERSERK (15 kill combo)
                if (this.comboKillCount >= this.berserkKillsRequired && !this.berserkActive) {
                    this.activateBerserk();
                    this.comboKillCount = 0; // Reset combo after activation
                }
                
                // Check for Blood Thirst (4 kills in 5 seconds)
                const recentKillsForBloodThirst = this.killTimes.filter(time => now - time <= this.bloodThirstTimeWindow);
                if (recentKillsForBloodThirst.length >= this.bloodThirstKillsRequired && !this.bloodThirstActive) {
                    this.activateBloodThirst();
                }
                
                // Check for Hellfire (10 kills in 10 seconds)
                const recentKillsForHellfire = this.killTimes.filter(time => now - time <= this.hellfireTimeWindow);
                if (recentKillsForHellfire.length >= this.hellfireKillsRequired && !this.hellfireActive) {
                    this.activateHellfire();
                }
                
                // Clean up old kills beyond either time window
                const maxWindow = Math.max(this.bloodThirstTimeWindow, this.hellfireTimeWindow);
                this.killTimes = this.killTimes.filter(time => now - time <= maxWindow);
            }
            
            activateBloodThirst() {
                this.bloodThirstActive = true;
                this.bloodThirstEndTime = performance.now() / 1000 + this.bloodThirstDuration;
                
                // Play activation sound
                if (this.audioManager) {
                    this.audioManager.play('perkBloodthirsty');
                }
                
                // Show on-screen notification
                this.showBloodThirstNotification();
                
                // Instant reload all weapons (will be handled in weapon system)
                if (this.weaponSystem) {
                    this.weaponSystem.activateBloodThirst();
                }
            }
            
            updateBloodThirst(deltaTime) {
                if (this.bloodThirstActive) {
                    const now = performance.now() / 1000;
                    if (now >= this.bloodThirstEndTime) {
                        this.deactivateBloodThirst();
                    } else {
                        // Update UI with remaining time
                        const remaining = this.bloodThirstEndTime - now;
                        this.updateBloodThirstDisplay(remaining);
                    }
                }
            }
            
            deactivateBloodThirst() {
                this.bloodThirstActive = false;
                
                // Notify weapon system
                if (this.weaponSystem) {
                    this.weaponSystem.deactivateBloodThirst();
                }
                
                // Hide UI
                this.hideBloodThirstDisplay();
            }
            
            showBloodThirstNotification() {
                // Create or show Blood Thirst UI element
                let bloodThirstUI = document.getElementById('bloodThirstUI');
                if (!bloodThirstUI) {
                    bloodThirstUI = document.createElement('div');
                    bloodThirstUI.id = 'bloodThirstUI';
                    bloodThirstUI.style.cssText = `
                        position: fixed;
                        top: 80px;
                        left: 50%;
                        transform: translateX(-50%);
                        color: #ff0000;
                        font-size: 24px;
                        font-weight: bold;
                        text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 20px rgba(255,0,0,0.5);
                        z-index: 1000;
                        pointer-events: none;
                        animation: pulse 0.5s ease-in-out infinite alternate;
                    `;
                    document.body.appendChild(bloodThirstUI);
                    
                    // Add animation if not already added
                    if (!document.getElementById('bloodThirstStyle')) {
                        const style = document.createElement('style');
                        style.id = 'bloodThirstStyle';
                        style.textContent = `
                            @keyframes pulse {
                                from { transform: translateX(-50%) scale(1); }
                                to { transform: translateX(-50%) scale(1.1); }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                }
                bloodThirstUI.textContent = 'BLOOD THIRST';
                bloodThirstUI.style.display = 'block';
            }
            
            updateBloodThirstDisplay(timeRemaining) {
                const bloodThirstUI = document.getElementById('bloodThirstUI');
                if (bloodThirstUI) {
                    bloodThirstUI.textContent = `BLOOD THIRST [${timeRemaining.toFixed(1)}s]`;
                }
            }
            
            hideBloodThirstDisplay() {
                const bloodThirstUI = document.getElementById('bloodThirstUI');
                if (bloodThirstUI) {
                    bloodThirstUI.style.display = 'none';
                }
            }
            
            getDamageMultiplier() {
                return this.bloodThirstActive ? 2.0 : 1.0;
            }
            
            registerSwordKill() {
                const now = performance.now() / 1000;
                
                // Add sword kill to tracking
                this.swordKillTimes.push(now);
                
                // Check for Adrenaline (3 sword kills in 3 seconds)
                const recentSwordKills = this.swordKillTimes.filter(time => now - time <= this.adrenalineTimeWindow);
                if (recentSwordKills.length >= this.adrenalineKillsRequired) {
                    this.activateOrStackAdrenaline();
                    // Reset sword kill tracking after activation
                    this.swordKillTimes = [];
                }
                
                // Clean up old sword kills
                this.swordKillTimes = this.swordKillTimes.filter(time => now - time <= this.adrenalineTimeWindow);
            }
            
            activateOrStackAdrenaline() {
                const now = performance.now() / 1000;
                
                if (!this.adrenalineActive) {
                    // First activation
                    this.adrenalineActive = true;
                    this.adrenalineStacks = 1;
                    this.adrenalineEndTime = now + this.adrenalineDuration;
                    
                    // Play activation sound
                    if (this.audioManager) {
                        this.audioManager.play('perkAdrenaline');
                    }
                    
                    this.showAdrenalineNotification();
                } else if (this.adrenalineStacks < this.maxAdrenalineStacks) {
                    // Stack the perk
                    this.adrenalineStacks++;
                    this.adrenalineEndTime = now + this.adrenalineDuration; // Reset timer
                    
                    // Play activation sound again
                    if (this.audioManager) {
                        this.audioManager.play('perkAdrenaline');
                    }
                    
                    this.updateAdrenalineDisplay();
                } else {
                    // Max stacks - just reset timer
                    this.adrenalineEndTime = now + this.adrenalineDuration;
                    this.updateAdrenalineDisplay();
                }
            }
            
            updateAdrenaline(deltaTime) {
                if (this.adrenalineActive) {
                    const now = performance.now() / 1000;
                    if (now >= this.adrenalineEndTime) {
                        this.deactivateAdrenaline();
                    } else {
                        // Update UI with remaining time
                        const remaining = this.adrenalineEndTime - now;
                        this.updateAdrenalineDisplayTime(remaining);
                    }
                }
            }
            
            deactivateAdrenaline() {
                this.adrenalineActive = false;
                this.adrenalineStacks = 0;
                this.hideAdrenalineDisplay();
            }
            
            showAdrenalineNotification() {
                // Create or show Adrenaline UI element
                let adrenalineUI = document.getElementById('adrenalineUI');
                if (!adrenalineUI) {
                    adrenalineUI = document.createElement('div');
                    adrenalineUI.id = 'adrenalineUI';
                    adrenalineUI.style.cssText = `
                        position: fixed;
                        top: 140px;
                        left: 50%;
                        transform: translateX(-50%);
                        color: #00ff00;
                        font-size: 24px;
                        font-weight: bold;
                        text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 20px rgba(0,255,0,0.5);
                        z-index: 1000;
                        pointer-events: none;
                        animation: speedPulse 0.3s ease-in-out infinite alternate;
                    `;
                    document.body.appendChild(adrenalineUI);
                    
                    // Add animation if not already added
                    if (!document.getElementById('adrenalineStyle')) {
                        const style = document.createElement('style');
                        style.id = 'adrenalineStyle';
                        style.textContent = `
                            @keyframes speedPulse {
                                from { transform: translateX(-50%) scale(1) rotate(-2deg); }
                                to { transform: translateX(-50%) scale(1.05) rotate(2deg); }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                }
                this.updateAdrenalineDisplay();
                adrenalineUI.style.display = 'block';
            }
            
            updateAdrenalineDisplay() {
                const adrenalineUI = document.getElementById('adrenalineUI');
                if (adrenalineUI) {
                    const stackText = this.adrenalineStacks > 1 ? ` x${this.adrenalineStacks}` : '';
                    adrenalineUI.textContent = `ADRENALINE${stackText}`;
                }
            }
            
            updateAdrenalineDisplayTime(timeRemaining) {
                const adrenalineUI = document.getElementById('adrenalineUI');
                if (adrenalineUI) {
                    const stackText = this.adrenalineStacks > 1 ? ` x${this.adrenalineStacks}` : '';
                    adrenalineUI.textContent = `ADRENALINE${stackText} [${timeRemaining.toFixed(1)}s]`;
                }
            }
            
            hideAdrenalineDisplay() {
                const adrenalineUI = document.getElementById('adrenalineUI');
                if (adrenalineUI) {
                    adrenalineUI.style.display = 'none';
                }
            }
            
            activateHellfire() {
                this.hellfireActive = true;
                this.hellfireEndTime = performance.now() / 1000 + this.hellfireDuration;
                
                // Play activation sound
                if (this.audioManager) {
                    this.audioManager.play('perkHellfire');
                }
                
                // Show on-screen notification
                this.showHellfireNotification();
                
                // Notify weapon system
                if (this.weaponSystem) {
                    this.weaponSystem.activateHellfire();
                }
            }
            
            updateHellfire(deltaTime) {
                if (this.hellfireActive) {
                    const now = performance.now() / 1000;
                    if (now >= this.hellfireEndTime) {
                        this.deactivateHellfire();
                    } else {
                        // Update UI with remaining time
                        const remaining = this.hellfireEndTime - now;
                        this.updateHellfireDisplay(remaining);
                    }
                }
            }
            
            deactivateHellfire() {
                this.hellfireActive = false;
                
                // Notify weapon system
                if (this.weaponSystem) {
                    this.weaponSystem.deactivateHellfire();
                }
                
                // Hide UI
                this.hideHellfireDisplay();
            }
            
            showHellfireNotification() {
                // Create or show Hellfire UI element
                let hellfireUI = document.getElementById('hellfireUI');
                if (!hellfireUI) {
                    hellfireUI = document.createElement('div');
                    hellfireUI.id = 'hellfireUI';
                    hellfireUI.style.cssText = `
                        position: fixed;
                        top: 110px;
                        left: 50%;
                        transform: translateX(-50%);
                        color: #ff6600;
                        font-size: 24px;
                        font-weight: bold;
                        text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 20px rgba(255,165,0,0.7);
                        z-index: 1000;
                        pointer-events: none;
                        animation: fireFlicker 0.3s ease-in-out infinite alternate;
                    `;
                    document.body.appendChild(hellfireUI);
                    
                    // Add fire flicker animation if not already added
                    if (!document.getElementById('hellfireStyle')) {
                        const style = document.createElement('style');
                        style.id = 'hellfireStyle';
                        style.textContent = `
                            @keyframes fireFlicker {
                                from { 
                                    transform: translateX(-50%) scale(1); 
                                    filter: brightness(1);
                                }
                                to { 
                                    transform: translateX(-50%) scale(1.05); 
                                    filter: brightness(1.3);
                                }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                }
                hellfireUI.textContent = 'HELLFIRE';
                hellfireUI.style.display = 'block';
            }
            
            updateHellfireDisplay(timeRemaining) {
                const hellfireUI = document.getElementById('hellfireUI');
                if (hellfireUI) {
                    hellfireUI.textContent = `HELLFIRE [${timeRemaining.toFixed(1)}s]`;
                }
            }
            
            hideHellfireDisplay() {
                const hellfireUI = document.getElementById('hellfireUI');
                if (hellfireUI) {
                    hellfireUI.style.display = 'none';
                }
            }
            
            activateBerserk() {
                this.berserkActive = true;
                this.berserkEndTime = performance.now() / 1000 + this.berserkDuration;
                
                // Play all three activation sounds simultaneously
                if (this.audioManager) {
                    this.audioManager.play('perkBerserk1');
                    this.audioManager.play('perkBerserk2');
                    this.audioManager.play('perkBerserk3');
                }
                
                // Show on-screen notification
                this.showBerserkNotification();
                
                // Notify weapon system
                if (this.weaponSystem) {
                    this.weaponSystem.activateBerserk();
                }
            }
            
            updateBerserk(deltaTime) {
                if (this.berserkActive) {
                    const now = performance.now() / 1000;
                    if (now >= this.berserkEndTime) {
                        this.deactivateBerserk();
                    } else {
                        // Update UI with remaining time
                        const remaining = this.berserkEndTime - now;
                        this.updateBerserkDisplay(remaining);
                    }
                }
            }
            
            deactivateBerserk() {
                this.berserkActive = false;
                this.comboKillCount = 0; // Reset combo
                
                // Notify weapon system
                if (this.weaponSystem) {
                    this.weaponSystem.deactivateBerserk();
                }
                
                // Hide UI
                this.hideBerserkDisplay();
            }
            
            showBerserkNotification() {
                // Create or show BERSERK UI element
                let berserkUI = document.getElementById('berserkUI');
                if (!berserkUI) {
                    berserkUI = document.createElement('div');
                    berserkUI.id = 'berserkUI';
                    berserkUI.style.cssText = `
                        position: fixed;
                        top: 140px;
                        left: 50%;
                        transform: translateX(-50%);
                        color: #ff0000;
                        font-size: 32px;
                        font-weight: bold;
                        text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
                        animation: pulse 0.5s infinite;
                        z-index: 1000;
                    `;
                    document.body.appendChild(berserkUI);
                }
                berserkUI.textContent = 'BERSERK ACTIVATED!';
                berserkUI.style.display = 'block';
                
                // Add pulse animation
                if (!document.getElementById('berserkStyle')) {
                    const style = document.createElement('style');
                    style.id = 'berserkStyle';
                    style.textContent = `
                        @keyframes pulse {
                            0% { transform: translateX(-50%) scale(1); }
                            50% { transform: translateX(-50%) scale(1.1); }
                            100% { transform: translateX(-50%) scale(1); }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }
            
            updateBerserkDisplay(remainingTime) {
                const berserkUI = document.getElementById('berserkUI');
                if (berserkUI) {
                    berserkUI.textContent = `BERSERK! ${remainingTime.toFixed(1)}s`;
                }
            }
            
            hideBerserkDisplay() {
                const berserkUI = document.getElementById('berserkUI');
                if (berserkUI) {
                    berserkUI.style.display = 'none';
                }
            }
            
            registerHeadshot() {
                const now = performance.now() / 1000;
                
                // Add headshot to tracking
                this.headshotTimes.push(now);
                
                // Check for SLOWMO (3 headshots in 3 seconds)
                const recentHeadshots = this.headshotTimes.filter(time => now - time <= this.headshotTimeWindow);
                if (recentHeadshots.length >= this.slowmoHeadshotsRequired && !this.slowmoActive) {
                    this.activateSlowmo();
                    // Reset headshot tracking after activation
                    this.headshotTimes = [];
                }
                
                // Clean up old headshots
                this.headshotTimes = this.headshotTimes.filter(time => now - time <= this.headshotTimeWindow);
            }
            
            activateSlowmo() {
                this.slowmoActive = true;
                this.slowmoEndTime = performance.now() / 1000 + this.slowmoDuration;
                this.timeScale = 0.25; // Slow down to 25% speed (75% reduction)
                
                // Play activation sound
                if (this.audioManager) {
                    this.audioManager.play('perkSlowmo');
                    // Set playback rate for all sounds
                    this.audioManager.setGlobalPlaybackRate(0.25);
                }
                
                // Show on-screen notification
                this.showSlowmoNotification();
            }
            
            updateSlowmo(deltaTime) {
                if (this.slowmoActive) {
                    const now = performance.now() / 1000;
                    if (now >= this.slowmoEndTime) {
                        this.deactivateSlowmo();
                    } else {
                        // Update UI with remaining time
                        const remaining = this.slowmoEndTime - now;
                        this.updateSlowmoDisplay(remaining);
                    }
                }
            }
            
            deactivateSlowmo() {
                this.slowmoActive = false;
                this.timeScale = 1.0; // Return to normal speed
                
                // Reset audio playback rate
                if (this.audioManager) {
                    this.audioManager.setGlobalPlaybackRate(1.0);
                }
                
                // Hide UI
                this.hideSlowmoDisplay();
            }
            
            activateAirstrike() {
                this.airstrikeAvailable = true;
                this.audioManager.play('perkAirstrike');
                
                // Show perk-style popup notification
                this.showAirstrikePopup();
                
                // Give walkie talkie ammo
                if (this.weaponSystem) {
                    this.weaponSystem.weapons.walkieTalkie.currentAmmo = 1;
                }
                
                // Show notification next to health bar (to the right of warthog if available)
                const message = document.createElement('div');
                message.className = 'perk-message airstrike-ready';
                message.innerHTML = '<span style="color: #ff6600; font-size: 14px; font-weight: bold;">AIRSTRIKE [X]</span>';
                const leftOffset = this.warthogStrikeAvailable ? 150 : 30; // Position to the right of warthog if available
                message.style.cssText = `
                    position: fixed;
                    bottom: 60px;
                    left: ${leftOffset}px;
                    z-index: 1000;
                    animation: none;
                    background: rgba(0,0,0,0.7);
                    padding: 5px 10px;
                    border-radius: 5px;
                    border: 1px solid #ff6600;
                `;
                document.body.appendChild(message);
                this.airstrikeMessage = message;
            }
            
            activateWarthogStrike() {
                this.warthogStrikeAvailable = true;
                this.audioManager.play('perkAirstrike'); // Use same sound for now
                
                // Show perk-style popup notification
                this.showWarthogPopup();
                
                // Give warthog strike ammo
                if (this.weaponSystem) {
                    this.weaponSystem.weapons.warthogStrike.currentAmmo = 1;
                }
                
                // Show notification next to health bar (leftmost position)
                const message = document.createElement('div');
                message.className = 'perk-message warthog-ready';
                message.innerHTML = '<span style="color: #00ff00; font-size: 14px; font-weight: bold;">WARTHOG [Z]</span>';
                message.style.cssText = `
                    position: fixed;
                    bottom: 60px;
                    left: 30px;
                    z-index: 1000;
                    animation: none;
                    background: rgba(0,0,0,0.7);
                    padding: 5px 10px;
                    border-radius: 5px;
                    border: 1px solid #00ff00;
                `;
                document.body.appendChild(message);
                this.warthogMessage = message;
                
                // Reposition airstrike notification if it exists
                if (this.airstrikeMessage && this.airstrikeAvailable) {
                    this.airstrikeMessage.style.left = '150px';
                }
            }
            
            showAirstrikePopup() {
                // Create popup notification like perks
                const popup = document.createElement('div');
                popup.style.cssText = `
                    position: fixed;
                    top: 200px;
                    left: 50%;
                    transform: translateX(-50%);
                    color: #ff6600;
                    font-size: 28px;
                    font-weight: bold;
                    text-shadow: 0 0 10px #ff6600, 0 0 20px #ff3300;
                    z-index: 1000;
                    animation: fadeInOut 3s ease-out;
                `;
                popup.textContent = 'AIRSTRIKE READY!';
                document.body.appendChild(popup);
                
                // Add fade animation if not exists
                if (!document.getElementById('airstrikePopupStyle')) {
                    const style = document.createElement('style');
                    style.id = 'airstrikePopupStyle';
                    style.textContent = `
                        @keyframes fadeInOut {
                            0% { opacity: 0; transform: translateX(-50%) scale(0.8); }
                            20% { opacity: 1; transform: translateX(-50%) scale(1.1); }
                            40% { opacity: 1; transform: translateX(-50%) scale(1); }
                            100% { opacity: 0; transform: translateX(-50%) scale(1); }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                // Remove after animation
                setTimeout(() => popup.remove(), 3000);
            }
            
            showWarthogPopup() {
                // Create popup notification like perks
                const popup = document.createElement('div');
                popup.style.cssText = `
                    position: fixed;
                    top: 200px;
                    left: 50%;
                    transform: translateX(-50%);
                    color: #00ff00;
                    font-size: 28px;
                    font-weight: bold;
                    text-shadow: 0 0 10px #00ff00, 0 0 20px #00aa00;
                    z-index: 1000;
                    animation: fadeInOut 3s ease-out;
                `;
                popup.textContent = 'WARTHOG STRIKE READY!';
                document.body.appendChild(popup);
                
                // Add fade animation if not exists (reuse the same animation)
                if (!document.getElementById('airstrikePopupStyle')) {
                    const style = document.createElement('style');
                    style.id = 'airstrikePopupStyle';
                    style.textContent = `
                        @keyframes fadeInOut {
                            0% { opacity: 0; transform: translateX(-50%) scale(0.8); }
                            20% { opacity: 1; transform: translateX(-50%) scale(1.1); }
                            40% { opacity: 1; transform: translateX(-50%) scale(1); }
                            100% { opacity: 0; transform: translateX(-50%) scale(1); }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                // Remove after animation
                setTimeout(() => popup.remove(), 3000);
            }
            
            startAirstrikeTargeting() {
                if (!this.airstrikeAvailable) return;
                
                this.isTargetingAirstrike = true;
                // Don't play sound here - play it when actually calling the airstrike
                
                // Show targeting instructions
                const instructions = document.createElement('div');
                instructions.className = 'airstrike-instructions';
                instructions.innerHTML = 'Click to call airstrike at location';
                instructions.style.cssText = `
                    position: fixed;
                    bottom: 100px;
                    left: 50%;
                    transform: translateX(-50%);
                    color: #ff6600;
                    font-size: 20px;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                    z-index: 1000;
                `;
                document.body.appendChild(instructions);
                this.targetingInstructions = instructions;
            }
            
            cancelAirstrikeTargeting() {
                this.isTargetingAirstrike = false;
                
                // Remove targeting instructions
                if (this.targetingInstructions) {
                    this.targetingInstructions.remove();
                    this.targetingInstructions = null;
                }
                
                // Remove target circle if exists
                if (this.airstrikeTargetCircle) {
                    this.scene.remove(this.airstrikeTargetCircle);
                    this.airstrikeTargetCircle = null;
                }
            }
            
            callAirstrike(targetPosition, bulletPool) {
                if (!this.airstrikeAvailable) return;
                
                // Play walkie talkie fire sound immediately
                this.audioManager.play('walkieTalkieFire');
                
                // Mark airstrike as used
                this.airstrikeAvailable = false;
                this.isTargetingAirstrike = false;
                
                // Start cooldown
                const now = performance.now() / 1000;
                this.airstrikeCooldownEndTime = now + this.airstrikeCooldownTime;
                
                // Remove UI elements
                if (this.airstrikeMessage) {
                    this.airstrikeMessage.remove();
                    this.airstrikeMessage = null;
                }
                if (this.targetingInstructions) {
                    this.targetingInstructions.remove();
                    this.targetingInstructions = null;
                }
                
                // Warthog stays at left: 30px (no need to reposition)
                
                // Remove walkie talkie ammo
                if (this.weaponSystem) {
                    this.weaponSystem.weapons.walkieTalkie.currentAmmo = 0;
                    this.weaponSystem.switchWeapon('smg'); // Auto-switch to SMG
                }
                
                // Create glowing target circle on ground
                const circleGeometry = new THREE.RingGeometry(4.5, 5, 32);
                const circleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff6600, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });
                const targetCircle = new THREE.Mesh(circleGeometry, circleMaterial);
                targetCircle.rotation.x = -Math.PI / 2;
                targetCircle.position.copy(targetPosition);
                targetCircle.position.y = 0.1;
                this.scene.add(targetCircle);
                
                // Pulse animation for circle
                const pulseCircle = () => {
                    if (targetCircle.parent) {
                        targetCircle.material.opacity = 0.4 + Math.sin(Date.now() * 0.005) * 0.4;
                        requestAnimationFrame(pulseCircle);
                    }
                };
                pulseCircle();
                
                // Wait 3 seconds then play airstrike activate sound
                setTimeout(() => {
                    this.audioManager.play('airstrikeActivate');
                    
                    // Wait another 1 second then spawn rockets
                    setTimeout(() => {
                        // Spawn 15 rockets from the sky across wider area
                        for (let i = 0; i < 15; i++) {
                            setTimeout(() => {
                                // Random position within larger target area (3x bigger)
                                const angle = Math.random() * Math.PI * 2;
                                const radius = Math.random() * 12; // Within 12 unit radius (was 4)
                                const xOffset = Math.cos(angle) * radius;
                                const zOffset = Math.sin(angle) * radius;
                                
                                // Start position high in the sky
                                const startPos = new THREE.Vector3(
                                    targetPosition.x + xOffset,
                                    30 + Math.random() * 5, // 30-35 units high
                                    targetPosition.z + zOffset
                                );
                                
                                // Create rocket
                                const bullet = bulletPool ? bulletPool.get() : null;
                                if (bullet) {
                                    bullet.damage = 100;
                                    bullet.speed = 50;
                                    bullet.isRocket = true;
                                    bullet.blastRadius = 6;
                                    bullet.isAirstrikeRocket = true; // Special flag for airstrike rockets
                                    
                                    // Fire straight down with slight spread
                                    const direction = new THREE.Vector3(
                                        (Math.random() - 0.5) * 0.1,
                                        -1,
                                        (Math.random() - 0.5) * 0.1
                                    ).normalize();
                                    
                                    bullet.fire(startPos, direction);
                                }
                            }, i * 100); // Stagger rocket spawns by 100ms
                        }
                        
                        // After all 15 rockets (1.5 seconds), wait 1 more second then drop the hellfire missile
                        setTimeout(() => {
                            // Spawn final hellfire missile dead center
                            const startPos = new THREE.Vector3(
                                targetPosition.x,
                                35, // Start from 35 units high
                                targetPosition.z
                            );
                            
                            // Create hellfire rocket with devastating stats
                            const bullet = bulletPool ? bulletPool.get() : null;
                            if (bullet) {
                                bullet.damage = 99999; // Instakill damage like hellfire perk
                                bullet.speed = 60; // Slightly faster
                                bullet.isRocket = true;
                                bullet.blastRadius = 20; // Same as hellfire perk (2.5x of base 8)
                                bullet.isHellfireRocket = true; // Hellfire flag for fiery smoke and instakill
                                bullet.isAirstrikeRocket = false; // Use hellfire smoke instead
                                
                                // Fire straight down at exact center
                                const direction = new THREE.Vector3(0, -1, 0);
                                
                                bullet.fire(startPos, direction);
                            }
                        }, 2500); // 1.5 seconds for barrage + 1 second wait
                    }, 1000); // Wait 1 second after airstrike activate sound
                    
                    // Remove target circle after 5 seconds total
                    setTimeout(() => {
                        this.scene.remove(targetCircle);
                    }, 3000);
                }, 3000); // Wait 3 seconds before playing airstrike activate
            }
            
            startWarthogStrikeTargeting() {
                if (!this.warthogStrikeAvailable) return;
                
                this.isTargetingWarthogStrike = true;
                
                // Show targeting instructions
                const instructions = document.createElement('div');
                instructions.className = 'warthog-instructions';
                instructions.innerHTML = 'Click to call A10 Warthog gun run';
                instructions.style.cssText = `
                    position: fixed;
                    bottom: 100px;
                    left: 50%;
                    transform: translateX(-50%);
                    color: #00ff00;
                    font-size: 20px;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                    z-index: 1000;
                `;
                document.body.appendChild(instructions);
                this.warthogTargetingInstructions = instructions;
            }
            
            cancelWarthogStrikeTargeting() {
                this.isTargetingWarthogStrike = false;
                
                // Remove targeting instructions
                if (this.warthogTargetingInstructions) {
                    this.warthogTargetingInstructions.remove();
                    this.warthogTargetingInstructions = null;
                }
                
                // Remove target rectangle if exists
                if (this.warthogTargetRectangle) {
                    this.scene.remove(this.warthogTargetRectangle);
                    this.warthogTargetRectangle = null;
                }
            }
            
            callWarthogStrike(targetPosition, targetDirection, bulletPool) {
                if (!this.warthogStrikeAvailable) return;
                
                // Play walkie talkie fire sound immediately
                this.audioManager.play('walkieTalkieFire');
                
                // Mark warthog strike as used
                this.warthogStrikeAvailable = false;
                this.isTargetingWarthogStrike = false;
                
                // Start cooldown
                const now = performance.now() / 1000;
                this.warthogStrikeCooldownEndTime = now + this.warthogStrikeCooldownTime;
                
                // Remove UI elements
                if (this.warthogMessage) {
                    this.warthogMessage.remove();
                    this.warthogMessage = null;
                }
                if (this.warthogTargetingInstructions) {
                    this.warthogTargetingInstructions.remove();
                    this.warthogTargetingInstructions = null;
                }
                
                // Reposition airstrike notification if it exists (move from right to left)
                if (this.airstrikeMessage && this.airstrikeAvailable) {
                    this.airstrikeMessage.style.left = '30px';
                }
                
                // Remove warthog strike ammo
                if (this.weaponSystem) {
                    this.weaponSystem.weapons.warthogStrike.currentAmmo = 0;
                    this.weaponSystem.switchWeapon('smg'); // Auto-switch to SMG
                }
                
                // Calculate corridor perpendicular to player facing direction
                const corridorWidth = 3;
                const corridorLength = 40;
                
                // Get perpendicular direction (left-right relative to player facing)
                const perpVector = new THREE.Vector3(-targetDirection.z, 0, targetDirection.x);
                perpVector.normalize();
                
                // Calculate corridor start and end points
                const corridorStart = targetPosition.clone().add(perpVector.clone().multiplyScalar(-corridorLength / 2));
                const corridorEnd = targetPosition.clone().add(perpVector.clone().multiplyScalar(corridorLength / 2));
                
                // Create visual corridor indicator that shows actual strike angle
                const rectangleGeometry = new THREE.PlaneGeometry(corridorLength, corridorWidth);
                const rectangleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, 
                    transparent: true, 
                    opacity: 0.3,
                    side: THREE.DoubleSide 
                });
                const targetRectangle = new THREE.Mesh(rectangleGeometry, rectangleMaterial);
                targetRectangle.position.copy(targetPosition);
                targetRectangle.position.y = 0.1;
                targetRectangle.rotation.x = -Math.PI / 2;  // Lay flat on ground
                
                // The corridor runs along the perpendicular vector (left-right relative to player)
                // We need to rotate the rectangle to align with this corridor direction
                // The perpVector defines the direction of the strike corridor
                const angle = Math.atan2(perpVector.x, perpVector.z);
                targetRectangle.rotation.z = angle + Math.PI / 2;  // Add 90 degrees since PlaneGeometry default orientation
                
                this.scene.add(targetRectangle);
                
                // Animate corridor
                let pulseTime = 0;
                const pulseInterval = setInterval(() => {
                    pulseTime += 0.1;
                    targetRectangle.material.opacity = 0.2 + Math.sin(pulseTime * 8) * 0.15;
                }, 50);
                
                // Wait 2 seconds then play activation sound
                setTimeout(() => {
                    this.audioManager.play('airstrikeActivate');
                    clearInterval(pulseInterval);
                    
                    // Play warthog flyby sound 4.5 seconds after activation (6.5 seconds total)
                    setTimeout(() => {
                        console.log('Attempting to play warthog_flyby sound...');
                        console.log('Sound exists?', this.audioManager.sounds['warthog_flyby'] ? 'Yes' : 'No');
                        
                        // First boost the volume
                        const sound = this.audioManager.sounds['warthog_flyby'];
                        if (sound) {
                            // Store original volume
                            const originalVolume = sound.baseVolume || 0.8;
                            
                            // Set to 2x volume for all instances before playing
                            if (sound.instances) {
                                sound.instances.forEach(instance => {
                                    instance.volume = Math.min(1.0, originalVolume * 2 * this.audioManager.volume);
                                });
                            }
                            
                            // Now play the sound
                            this.audioManager.play('warthog_flyby');
                            
                            console.log('Warthog flyby sound triggered with 2x volume');
                        } else {
                            console.error('warthog_flyby sound not found in audioManager!');
                        }
                    }, 4500);  // Changed from 2500ms to 4500ms (6.5 seconds total)
                    
                    // Wait another 2 seconds after activation sound before spawning shells (4 seconds total)
                    setTimeout(() => {
                        // Spawn 50 shells in sequence across the corridor
                        const shellCount = 50;
                        const spawnDelay = 50; // 50ms between each shell for rapid A10 gun sound
                        
                        for (let i = 0; i < shellCount; i++) {
                            setTimeout(() => {
                            // Calculate position along corridor
                            const progress = i / (shellCount - 1); // 0 to 1
                            const shellPosition = corridorStart.clone().lerp(corridorEnd, progress);
                            
                            // Add some random spread within corridor width
                            const spreadVector = new THREE.Vector3(targetDirection.x, 0, targetDirection.z);
                            spreadVector.normalize();
                            const randomSpread = (Math.random() - 0.5) * corridorWidth;
                            shellPosition.add(spreadVector.clone().multiplyScalar(randomSpread));
                            
                            // Spawn shell from sky at 45-degree angle
                            const spawnHeight = 50;
                            const spawnPos = shellPosition.clone();
                            spawnPos.y = spawnHeight;
                            spawnPos.add(perpVector.clone().multiplyScalar(-20)); // Start further back for 45-degree approach
                            
                            // Get bullet from pool
                            const bullet = bulletPool.get();
                            if (bullet) {
                                bullet.is30mmShell = true;
                                bullet.damage = 150;
                                bullet.speed = 200;
                                bullet.shellBlastRadius = 5;
                                
                                // 45-degree downward angle toward target
                                const direction = shellPosition.clone().sub(spawnPos).normalize();
                                bullet.fire(spawnPos, direction);
                                
                                // Play flyby sound
                                this.audioManager.play('30mmshell_flyby');
                            }
                        }, i * spawnDelay);
                            }
                        
                        // Remove target rectangle after attack completes
                        setTimeout(() => {
                            this.scene.remove(targetRectangle);
                        }, shellCount * spawnDelay + 2000);
                    }, 2000);  // 2 second delay after activation sound before shells start
                }, 2000);  // Initial 2 second delay before activation sound
            }
            
            showSlowmoNotification() {
                // Create or show SLOWMO UI element
                let slowmoUI = document.getElementById('slowmoUI');
                if (!slowmoUI) {
                    slowmoUI = document.createElement('div');
                    slowmoUI.id = 'slowmoUI';
                    slowmoUI.style.cssText = `
                        position: fixed;
                        top: 170px;
                        left: 50%;
                        transform: translateX(-50%);
                        color: #00ffff;
                        font-size: 24px;
                        font-weight: bold;
                        text-shadow: 0 0 10px #00ffff;
                        z-index: 1000;
                    `;
                    document.body.appendChild(slowmoUI);
                }
                slowmoUI.textContent = 'SLOWMO ACTIVATED!';
                slowmoUI.style.display = 'block';
            }
            
            updateSlowmoDisplay(remainingTime) {
                const slowmoUI = document.getElementById('slowmoUI');
                if (slowmoUI) {
                    slowmoUI.textContent = `SLOWMO [${remainingTime.toFixed(1)}s]`;
                }
            }
            
            hideSlowmoDisplay() {
                const slowmoUI = document.getElementById('slowmoUI');
                if (slowmoUI) {
                    slowmoUI.style.display = 'none';
                }
            }
            
            getTimeScale() {
                return this.timeScale;
            }
        }

        // Wave System
        class WaveSystem {
            constructor(game) {
                this.game = game; // Reference to main game
                this.currentWave = 1;
                this.enemiesPerWave = 10; // Back to original higher count
                this.enemySpawnRate = 1; // Back to faster spawn rate (1 enemy per second)
                this.lastSpawnTime = 0;
                this.enemiesSpawned = 0;
                this.waveActive = false;
                this.waveCompleteTime = 0;
                this.nextWaveDelay = 5; // seconds between waves
            }

            startWave() {
                this.waveActive = true;
                this.enemiesSpawned = 0;
                this.lastSpawnTime = performance.now() / 1000;
                this.updateWaveDisplay();
            }

            update(deltaTime, enemies) {
                if (!this.waveActive) {
                    // Check if we should start next wave
                    const now = performance.now() / 1000;
                    if (enemies.length === 0 && (now - this.waveCompleteTime) >= this.nextWaveDelay) {
                        this.nextWave();
                    }
                    return null;
                }

                // Check if wave is complete
                if (this.enemiesSpawned >= this.getEnemiesForWave() && enemies.length === 0) {
                    this.completeWave();
                    return null;
                }

                // Spawn enemies
                const now = performance.now() / 1000;
                if (this.enemiesSpawned < this.getEnemiesForWave() && 
                    (now - this.lastSpawnTime) >= this.enemySpawnRate) {
                    this.lastSpawnTime = now;
                    this.enemiesSpawned++;
                    return this.getRandomEnemyType();
                }

                return null;
            }

            completeWave() {
                this.waveActive = false;
                this.waveCompleteTime = performance.now() / 1000;
            }

            nextWave() {
                this.currentWave++;
                
                // Check if we've reached wave 10 and switch to hard music
                if (this.currentWave === 10 && this.game && this.game.soundtrackManager) {
                    this.game.soundtrackManager.switchToHard();
                }
                
                this.startWave();
            }

            getEnemiesForWave() {
                // Doubled base (10) plus increased scaling per wave
                return this.enemiesPerWave + Math.floor(this.currentWave * 2);
            }

            getRandomEnemyType() {
                // Higher waves have tougher enemies
                if (this.currentWave >= 5 && Math.random() < 0.3) {
                    return 2; // Strong enemy
                } else if (this.currentWave >= 3 && Math.random() < 0.4) {
                    return 1; // Medium enemy
                } else {
                    return 0; // Basic enemy
                }
            }

            getCurrentWave() {
                return this.currentWave;
            }

            updateWaveDisplay() {
                document.getElementById('waveDisplay').textContent = this.currentWave;
            }
        }

        // Game Manager
        class GameManager {
            constructor() {
                this.score = 0;
                this.highScore = this.loadHighScore();
                this.kills = 0;
                
                this.updateScoreDisplay();
            }

            addScore(points) {
                this.score += points;
                this.updateScoreDisplay();
            }

            addKill() {
                this.kills++;
            }

            getScore() {
                return this.score;
            }

            getKills() {
                return this.kills;
            }

            checkHighScore() {
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    this.saveHighScore();
                    return true;
                }
                return false;
            }

            loadHighScore() {
                const saved = localStorage.getItem('fps_highscore');
                return saved ? parseInt(saved) : 0;
            }

            saveHighScore() {
                localStorage.setItem('fps_highscore', this.highScore.toString());
            }

            updateScoreDisplay() {
                document.getElementById('scoreDisplay').textContent = this.score;
            }

            reset() {
                this.score = 0;
                this.kills = 0;
                this.updateScoreDisplay();
            }
        }

        // UI Manager
        class UIManager {
            constructor() {
                this.killFeed = document.getElementById('killFeed');
                this.showFPS = false;
                this.showDebug = false;
                this.fpsCounter = document.getElementById('fpsCounter');
                this.debugInfo = document.getElementById('debugInfo');
                
                this.frameCount = 0;
                this.lastFPSTime = performance.now();
            }

            addKillMessage(message) {
                const killMessage = document.createElement('div');
                killMessage.className = 'kill-message';
                killMessage.textContent = message;
                
                this.killFeed.appendChild(killMessage);
                
                // Remove message after animation
                setTimeout(() => {
                    if (killMessage.parentNode) {
                        killMessage.parentNode.removeChild(killMessage);
                    }
                }, 4000);
                
                // Limit number of messages
                while (this.killFeed.children.length > 5) {
                    this.killFeed.removeChild(this.killFeed.firstChild);
                }
            }

            updateFPS(deltaTime) {
                if (!this.showFPS) return;

                this.frameCount++;
                const now = performance.now();
                
                if (now - this.lastFPSTime >= 1000) {
                    const fps = Math.round(this.frameCount * 1000 / (now - this.lastFPSTime));
                    this.fpsCounter.textContent = `FPS: ${fps}`;
                    this.frameCount = 0;
                    this.lastFPSTime = now;
                }
            }

            updateDebugInfo(player, enemies, bullets) {
                if (!this.showDebug) return;

                const pos = player.getPosition();
                const debugText = `
Position: ${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}
Health: ${player.health.toFixed(0)} / ${player.maxHealth}
Enemies: ${enemies.length}
Active Bullets: ${bullets.length}
Velocity: ${player.velocity.length().toFixed(2)}
                `.trim();
                
                this.debugInfo.textContent = debugText;
            }

            toggleFPS() {
                this.showFPS = !this.showFPS;
                this.fpsCounter.style.display = this.showFPS ? 'block' : 'none';
            }

            toggleDebug() {
                this.showDebug = !this.showDebug;
                this.debugInfo.style.display = this.showDebug ? 'block' : 'none';
            }

            updateEnemyCount(count) {
                document.getElementById('enemyCount').textContent = count;
            }

            drawMinimap(canvas, player, enemies, pickups) {
                const ctx = canvas.getContext('2d');
                const size = 150;
                const scale = 1; // 1 pixel per unit
                const centerX = size / 2;
                const centerY = size / 2;
                
                // Clear canvas
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, size, size);
                
                // Draw boundaries
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.strokeRect(1, 1, size - 2, size - 2);
                
                // Draw player
                const playerPos = player.getPosition();
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.arc(
                    centerX + playerPos.x * scale,
                    centerY - playerPos.z * scale, // Flip Z for screen coords
                    3, 0, Math.PI * 2
                );
                ctx.fill();
                
                // Draw player direction
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyEuler(new THREE.Euler(0, player.rotation.y, 0));
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX + playerPos.x * scale, centerY - playerPos.z * scale);
                ctx.lineTo(
                    centerX + (playerPos.x + direction.x * 10) * scale,
                    centerY - (playerPos.z + direction.z * 10) * scale
                );
                ctx.stroke();
                
                // Draw enemies
                ctx.fillStyle = '#ff4444';
                for (let enemy of enemies) {
                    if (enemy.active) {
                        const enemyPos = enemy.position;
                        ctx.beginPath();
                        ctx.arc(
                            centerX + enemyPos.x * scale,
                            centerY - enemyPos.z * scale,
                            2, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
                
                // Draw pickups
                ctx.fillStyle = '#ffff00';
                for (let pickup of pickups) {
                    if (pickup.active) {
                        const pickupPos = pickup.getPosition();
                        ctx.beginPath();
                        ctx.arc(
                            centerX + pickupPos.x * scale,
                            centerY - pickupPos.z * scale,
                            1.5, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
            }
        }

        // Main game class
        class FPSGame {
            constructor() {
                this.state = GameState.SPLASH;
                this.shouldStartGame = false; // Track if start button was clicked
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.player = null;
                this.inputManager = null;
                this.audioManager = null;
                this.soundtrackManager = null;
                this.weaponSystem = null;
                this.particleSystem = null;
                this.waveSystem = null;
                this.gameManager = null;
                this.uiManager = null;
                
                this.collisionObjects = [];
                this.enemies = [];
                this.pickups = [];
                
                // Object pools
                this.bulletPool = null;
                
                // Time tracking
                this.clock = new THREE.Clock();
                this.lastTime = 0;
                this.pickupSpawnTimer = 0;
                this.pickupSpawnInterval = 10; // seconds
                
                this.init();
                this.createEnvironment();
                this.setupGameSystems();
                this.bindEvents();
                this.animate();
            }
            
            init() {
                // Create scene
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
                
                // Create camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                
                // Create renderer with performance optimizations
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap at 2x for performance
                this.renderer.setClearColor(0x87CEEB);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFShadowMap; // Use basic PCF for better performance
                document.body.appendChild(this.renderer.domElement);
                
                // Setup lighting
                this.setupLighting();
                
                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
            }

            setupGameSystems() {
                // Create input manager
                this.inputManager = new InputManager();
                
                // Create audio manager
                this.audioManager = new AudioManager();
                
                // Create soundtrack manager (don't start music yet - wait for user interaction)
                this.soundtrackManager = new SoundtrackManager();
                
                // Create player
                this.player = new Player(this.camera, this.scene, this.audioManager);
                
                // Create weapon system
                this.weaponSystem = new WeaponSystem(this.scene, this.camera, this.audioManager);
                
                // Connect player and weapon system for Blood Thirst
                this.player.weaponSystem = this.weaponSystem;
                this.weaponSystem.player = this.player;
                
                // Create particle system
                this.particleSystem = new ParticleSystem(this.scene);
                
                // Store reference for ragdoll blood trails
                window.currentGame = this;
                
                // Create wave system (pass game reference for music switching)
                this.waveSystem = new WaveSystem(this);
                
                // Create game manager
                this.gameManager = new GameManager();
                
                // Create UI manager
                this.uiManager = new UIManager();
                
                // Create bullet pools
                this.bulletPool = new ObjectPool(
                    () => new Bullet(this.scene, this.particleSystem),
                    (bullet) => bullet.reset(),
                    100
                );
                
                // Enemy bullet pool (smaller, red bullets)
                this.enemyBulletPool = new ObjectPool(
                    () => {
                        const bullet = new Bullet(this.scene, this.particleSystem);
                        bullet.mesh.material.color.setHex(0xff0000);
                        return bullet;
                    },
                    (bullet) => bullet.reset(),
                    50
                );
            }

            bindEvents() {
                document.addEventListener('keydown', (e) => {
                    this.handleKeyDown(e.code);
                });
            }

            handleKeyDown(keyCode) {
                switch (keyCode) {
                    case 'Escape':
                        this.handleEscapeKey();
                        break;
                    case 'KeyR':
                        if (this.state === GameState.PLAYING) {
                            if (this.state === GameState.PAUSED) {
                                this.restartGame();
                            } else {
                                this.weaponSystem.startReload();
                            }
                        }
                        break;
                    case 'Space':
                        if (this.state === GameState.GAME_OVER) {
                            this.restartGame();
                        }
                        break;
                    case 'KeyF':
                        this.uiManager.toggleFPS();
                        break;
                    case 'KeyG':
                        this.uiManager.toggleDebug();
                        break;
                    case 'Digit1':
                        if (this.state === GameState.PLAYING) {
                            this.weaponSystem.switchWeapon('smg');
                        }
                        break;
                    case 'Digit2':
                        if (this.state === GameState.PLAYING) {
                            this.weaponSystem.switchWeapon('shotgun');
                        }
                        break;
                    case 'Digit3':
                        if (this.state === GameState.PLAYING) {
                            this.weaponSystem.switchWeapon('rocket');
                        }
                        break;
                    case 'Digit4':
                        if (this.state === GameState.PLAYING) {
                            this.weaponSystem.switchWeapon('autoCannon');
                        }
                        break;
                    case 'KeyX':
                        if (this.state === GameState.PLAYING && this.player.airstrikeAvailable) {
                            this.weaponSystem.switchWeapon('walkieTalkie');
                        }
                        break;
                    case 'Digit5':
                        if (this.state === GameState.PLAYING) {
                            this.weaponSystem.switchWeapon('sword');
                        }
                        break;
                    case 'KeyZ':
                        if (this.state === GameState.PLAYING && this.player.warthogStrikeAvailable) {
                            this.weaponSystem.switchWeapon('warthogStrike');
                        }
                        break;
                }
            }

            handleEscapeKey() {
                switch (this.state) {
                    case GameState.PLAYING:
                        this.pauseGame();
                        break;
                    case GameState.PAUSED:
                        this.resumeGame();
                        break;
                    case GameState.GAME_OVER:
                        this.showMenu();
                        break;
                }
            }

            startGame() {
                this.state = GameState.PLAYING;
                this.hideAllScreens();
                
                // Switch to easy music
                this.soundtrackManager.switchToEasy();
                
                // Reset game state
                this.gameManager.reset();
                this.player.health = this.player.maxHealth;
                this.player.updateHealthDisplay();
                
                // Reset weapon ammo
                this.weaponSystem.weapons.smg.currentAmmo = 30;
                this.weaponSystem.weapons.shotgun.currentAmmo = 6;
                this.weaponSystem.weapons.rocket.currentAmmo = 1;
                this.weaponSystem.reserveAmmo = 90;
                this.weaponSystem.updateAmmoDisplay();
                
                // Clear entities
                this.clearEnemies();
                this.clearPickups();
                this.bulletPool.releaseAll();
                this.enemyBulletPool.releaseAll();
                
                // Start first wave (pass game reference for music switching)
                this.waveSystem = new WaveSystem(this);
                this.waveSystem.startWave();
                
                this.uiManager.updateEnemyCount(this.enemies.length);
            }

            pauseGame() {
                if (this.state !== GameState.PLAYING) return;
                this.state = GameState.PAUSED;
                this.inputManager.releasePointerLock();
                document.getElementById('pauseScreen').style.display = 'flex';
                
                // Pause soundtrack
                if (this.soundtrackManager) {
                    this.soundtrackManager.pause();
                }
            }

            resumeGame() {
                if (this.state !== GameState.PAUSED) return;
                this.state = GameState.PLAYING;
                document.getElementById('pauseScreen').style.display = 'none';
                
                // Request pointer lock again
                this.inputManager.requestPointerLock();
                
                // Resume soundtrack
                if (this.soundtrackManager) {
                    this.soundtrackManager.resume();
                }
            }

            restartGame() {
                this.startGame();
            }

            endGame() {
                this.state = GameState.GAME_OVER;
                this.inputManager.releasePointerLock();
                
                // Switch back to menu music
                this.soundtrackManager.switchToMenu();
                
                const isHighScore = this.gameManager.checkHighScore();
                const finalStats = `
                    <p>Final Score: ${this.gameManager.getScore()}</p>
                    <p>Kills: ${this.gameManager.getKills()}</p>
                    <p>Wave Reached: ${this.waveSystem.getCurrentWave()}</p>
                    ${isHighScore ? '<p style="color: #ffff00;">NEW HIGH SCORE!</p>' : ''}
                    <p>High Score: ${this.gameManager.highScore}</p>
                `;
                
                document.getElementById('finalStats').innerHTML = finalStats;
                document.getElementById('gameOverScreen').style.display = 'flex';
            }

            showMenu() {
                this.state = GameState.MENU;
                this.hideAllScreens();
                document.getElementById('menuScreen').style.display = 'flex';
                
                // Start menu music when entering main menu
                this.soundtrackManager.startMenuMusicIfNeeded();
            }
            
            showSplash() {
                this.state = GameState.SPLASH;
                this.hideAllScreens();
                document.getElementById('splashScreen').style.display = 'flex';
            }

            hideAllScreens() {
                document.getElementById('splashScreen').style.display = 'none';
                document.getElementById('menuScreen').style.display = 'none';
                document.getElementById('gameOverScreen').style.display = 'none';
                document.getElementById('pauseScreen').style.display = 'none';
            }
            
            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                // Directional light (sun)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                
                // Configure shadow properties
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -100;
                directionalLight.shadow.camera.right = 100;
                directionalLight.shadow.camera.top = 100;
                directionalLight.shadow.camera.bottom = -100;
                
                this.scene.add(directionalLight);
            }
            
            createEnvironment() {
                // Ground
                const groundGeometry = new THREE.PlaneGeometry(200, 200);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x4a5d23,
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Create walls and obstacles
                this.createWalls();
                this.createObstacles();
                
                // Add some decorative elements
                this.createDecorations();
            }
            
            createWalls() {
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                
                // Boundary walls
                const walls = [
                    { pos: [0, 2.5, -50], size: [100, 5, 2] },    // North wall
                    { pos: [0, 2.5, 50], size: [100, 5, 2] },     // South wall
                    { pos: [-50, 2.5, 0], size: [2, 5, 100] },    // West wall
                    { pos: [50, 2.5, 0], size: [2, 5, 100] },     // East wall
                ];
                
                walls.forEach(wall => {
                    const geometry = new THREE.BoxGeometry(wall.size[0], wall.size[1], wall.size[2]);
                    const mesh = new THREE.Mesh(geometry, wallMaterial);
                    mesh.position.set(wall.pos[0], wall.pos[1], wall.pos[2]);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    this.scene.add(mesh);
                    this.collisionObjects.push(mesh);
                });
            }
            
            createObstacles() {
                const obstacleMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                
                // Interior walls/obstacles
                const obstacles = [
                    { pos: [20, 2, -20], size: [4, 4, 15] },
                    { pos: [-25, 2, 10], size: [8, 4, 4] },
                    { pos: [15, 2, 25], size: [6, 4, 6] },
                    { pos: [-10, 2, -30], size: [12, 4, 4] },
                    { pos: [30, 1.5, 0], size: [4, 3, 8] },
                ];
                
                obstacles.forEach(obstacle => {
                    const geometry = new THREE.BoxGeometry(obstacle.size[0], obstacle.size[1], obstacle.size[2]);
                    const mesh = new THREE.Mesh(geometry, obstacleMaterial);
                    mesh.position.set(obstacle.pos[0], obstacle.pos[1], obstacle.pos[2]);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    this.scene.add(mesh);
                    this.collisionObjects.push(mesh);
                });
            }
            
            createDecorations() {
                // Add some crates
                const crateMaterial = new THREE.MeshLambertMaterial({ color: 0xDEB887 });
                
                for (let i = 0; i < 10; i++) {
                    const size = 1 + Math.random() * 1.5;
                    const geometry = new THREE.BoxGeometry(size, size, size);
                    const crate = new THREE.Mesh(geometry, crateMaterial);
                    
                    crate.position.set(
                        (Math.random() - 0.5) * 80,
                        size / 2,
                        (Math.random() - 0.5) * 80
                    );
                    
                    crate.rotation.y = Math.random() * Math.PI * 2;
                    crate.castShadow = true;
                    crate.receiveShadow = true;
                    
                    this.scene.add(crate);
                    this.collisionObjects.push(crate);
                }
                
                // Add some pillars
                const pillarMaterial = new THREE.MeshLambertMaterial({ color: 0x708090 });
                
                for (let i = 0; i < 5; i++) {
                    const geometry = new THREE.CylinderGeometry(1, 1.5, 8, 8);
                    const pillar = new THREE.Mesh(geometry, pillarMaterial);
                    
                    pillar.position.set(
                        (Math.random() - 0.5) * 60,
                        4,
                        (Math.random() - 0.5) * 60
                    );
                    
                    pillar.castShadow = true;
                    pillar.receiveShadow = true;
                    
                    this.scene.add(pillar);
                    this.collisionObjects.push(pillar);
                }
            }

            spawnEnemy(type) {
                // Find a spawn position away from player
                const playerPos = this.player.getPosition();
                let spawnPos;
                let attempts = 0;
                
                do {
                    spawnPos = new THREE.Vector3(
                        (Math.random() - 0.5) * 80,
                        0,  // Spawn at ground level
                        (Math.random() - 0.5) * 80
                    );
                    attempts++;
                } while (spawnPos.distanceTo(playerPos) < 15 && attempts < 20);
                
                const enemy = new Enemy(this.scene, spawnPos, type, this.waveSystem.currentWave);
                this.enemies.push(enemy);
                
                // Log enemy weapon type
                let weaponDesc = 'pistol';
                if (enemy.weaponType === 'rocket') weaponDesc = 'ROCKET LAUNCHER';
                else if (enemy.weaponType === 'shotgun') weaponDesc = 'SHOTGUN';
                else if (enemy.weaponType === 'smg') weaponDesc = 'SMG (10-round burst)';
                else if (enemy.isBurstFire) weaponDesc = '3-round burst pistol';
                
                console.log(`Wave ${this.waveSystem.currentWave}: Spawned enemy with ${weaponDesc}`);
                
                this.uiManager.updateEnemyCount(this.enemies.length);
            }

            spawnPickup(type, position) {
                const pickup = new Pickup(this.scene, position, type);
                this.pickups.push(pickup);
            }

            clearEnemies() {
                this.enemies.forEach(enemy => enemy.destroy());
                this.enemies = [];
                this.uiManager.updateEnemyCount(0);
            }

            handleShellExplosion(position, blastRadius, damage) {
                // Play 30mm shell explosion sound globally (no distance falloff)
                this.audioManager.play('30mmshell_explode');
                
                // Create explosion effect with sparks (50% size of rocket)
                this.particleSystem.createExplosion(position, 0xffff00, 25); // Yellow core
                this.particleSystem.createExplosion(position, 0xffaa00, 15); // Orange sparks
                
                // Create spark particles radiating outward
                for (let i = 0; i < 20; i++) {
                    const sparkVelocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 20,
                        Math.random() * 10,
                        (Math.random() - 0.5) * 20
                    );
                    this.particleSystem.createSpark(position.clone(), sparkVelocity, 0xffff00);
                }
                
                // Add smaller shockwave (50% of rocket)
                this.particleSystem.createShockwave(position, false, 0.5);
                
                // Add screen shake (50% of rocket intensity)
                if (this.weaponSystem) {
                    this.weaponSystem.addScreenShake(0.03);
                }
                
                // Check all enemies in blast radius
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    if (!enemy.active) continue;
                    
                    const distance = position.distanceTo(enemy.position);
                    if (distance <= blastRadius) {
                        // Damage falls off with distance
                        const falloff = 1 - (distance / blastRadius) * 0.5;
                        const blastDamage = damage * falloff;
                        
                        // Play hit sound for each enemy in blast
                        this.audioManager.play('enemyHit');
                        this.particleSystem.createExplosion(enemy.position, 0xff4444, 10);
                        
                        const killed = enemy.takeDamage(blastDamage);
                        
                        if (killed) {
                            this.audioManager.play('enemyDie');
                            
                            // Dismemberment on explosive kill
                            enemy.destroy(5, position); // Half the force of rocket
                            if (enemy.shouldPlayExplodeSound) {
                                this.audioManager.play('enemyExplode');
                            }
                            
                            this.gameManager.addScore(enemy.scoreValue);
                            this.gameManager.addKill();
                            this.player.registerKill();
                            this.uiManager.addKillMessage(`Enemy eliminated +${enemy.scoreValue}`);
                            
                            // Chance for pickups
                            if (Math.random() < 0.3) {
                                const pickupType = Math.random() < 0.5 ? 'health' : 'ammo';
                                this.spawnPickup(pickupType, enemy.position.clone());
                            }
                            
                            this.enemies.splice(i, 1);
                        }
                    }
                }
                
                // Update enemy count
                this.uiManager.updateEnemyCount(this.enemies.length);
                
                // Check for wave completion
                if (this.enemies.length === 0) {
                    this.onWaveComplete();
                }
            }
            
            handleRocketExplosion(position, blastRadius, damage, isHellfireBullet = false, isHellfireRocket = false) {
                // Play explosion sound based on projectile type
                if (isHellfireBullet) {
                    // Hellfire bullet explosion uses special sound
                    this.audioManager.play('hellfireBulletExplode');
                } else if (isHellfireRocket) {
                    // Hellfire rocket plays both sounds layered
                    this.audioManager.play('rocketExplosion');
                    this.audioManager.play('hellfireRocketExplode');
                } else {
                    // Normal rocket explosion
                    this.audioManager.play('rocketExplosion');
                }
                
                // Create explosion effect
                if (isHellfireBullet) {
                    // Smaller explosions for Hellfire bullets (25% size)
                    this.particleSystem.createExplosion(position, 0xff6600, 12);
                    this.particleSystem.createExplosion(position, 0xffaa00, 8);
                } else if (isHellfireRocket) {
                    // MASSIVE explosion for Hellfire rockets with dramatic fireball
                    this.particleSystem.createExplosion(position, 0xffff00, 120, true); // Bright yellow core
                    this.particleSystem.createExplosion(position, 0xffaa00, 100, true); // Orange mid layer
                    this.particleSystem.createExplosion(position, 0xff6600, 80, true);  // Red-orange outer
                    this.particleSystem.createExplosion(position, 0xff0000, 60, true);  // Deep red edge
                    // Add massive shockwave for hellfire
                    this.particleSystem.createShockwave(position, true);
                } else {
                    // Normal rocket explosion
                    this.particleSystem.createExplosion(position, 0xff6600, 50);
                    this.particleSystem.createExplosion(position, 0xffaa00, 30);
                    // Add shockwave for normal rockets
                    this.particleSystem.createShockwave(position, false);
                }
                
                // Add screen shake
                if (this.weaponSystem) {
                    if (isHellfireRocket) {
                        // Massive screen shake for Hellfire rockets (4x intensity)
                        this.weaponSystem.addScreenShake(0.24);
                        // Double the duration by setting it after the call
                        if (this.weaponSystem.screenShake) {
                            this.weaponSystem.screenShake.duration = 100; // 100ms instead of 50ms
                        }
                    } else {
                        // Normal screen shake
                        this.weaponSystem.addScreenShake(0.06);
                    }
                }
                
                // Check all enemies in blast radius
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    if (!enemy.active) continue;
                    
                    const distance = position.distanceTo(enemy.position);
                    if (distance <= blastRadius) {
                        // Hellfire rockets instakill everything in blast radius
                        let blastDamage;
                        if (isHellfireRocket) {
                            blastDamage = 99999; // Instakill
                        } else {
                            // Normal damage falls off with distance
                            const falloff = 1 - (distance / blastRadius) * 0.5;
                            blastDamage = damage * falloff;
                        }
                        
                        // Play hit sound for each enemy in blast
                        this.audioManager.play('enemyHit');
                        this.particleSystem.createExplosion(enemy.position, 0xff4444, 10);
                        
                        const killed = enemy.takeDamage(blastDamage);
                        
                        if (killed) {
                            this.audioManager.play('enemyDie');
                            
                            // DISABLED blood mist - focusing on blood trails instead
                            // const enemyPos = enemy.position ? enemy.position.clone() : new THREE.Vector3();
                            // enemyPos.y += 1; // Center of enemy body
                            // this.particleSystem.createLingeringBloodMist(enemyPos);
                            
                            // Always dismember on explosive kills (removed old dismemberment call since enemy.destroy handles it)
                            
                            // Check if enemy should play explode sound
                            enemy.destroy(10, position); // Pass explosion force and position for dismemberment
                            if (enemy.shouldPlayExplodeSound) {
                                this.audioManager.play('enemyExplode');
                            }
                            
                            this.gameManager.addScore(enemy.scoreValue);
                            this.gameManager.addKill();
                            this.player.registerKill(); // Register kill for Blood Thirst
                            this.uiManager.addKillMessage(`Enemy eliminated +${enemy.scoreValue}`);
                            
                            // Chance for pickups
                            if (Math.random() < 0.3) {
                                const pickupType = Math.random() < 0.5 ? 'health' : 'ammo';
                                this.spawnPickup(pickupType, enemy.position.clone());
                            }
                            
                            this.enemies.splice(i, 1);
                            this.uiManager.updateEnemyCount(this.enemies.length);
                        }
                    }
                }
                
                // Check if player is in blast radius
                const playerPos = this.player.getPosition();
                const playerDistance = position.distanceTo(playerPos);
                if (playerDistance <= blastRadius) {
                    // Player takes damage from their own rocket
                    const falloff = 1 - (playerDistance / blastRadius) * 0.5;
                    const blastDamage = damage * falloff * 0.5; // Reduced self-damage
                    this.player.takeDamage(blastDamage);
                }
            }

            clearPickups() {
                this.pickups.forEach(pickup => {
                    if (pickup.active) {
                        pickup.collect(); // This will clean up the mesh
                    }
                });
                this.pickups = [];
            }

            updateGame(deltaTime) {
                if (this.state !== GameState.PLAYING) return;
                
                // Apply time scale for SLOWMO
                const timeScale = this.player.getTimeScale();
                const scaledDeltaTime = deltaTime * timeScale;

                // Update player (always use real deltaTime for player controls)
                this.player.update(deltaTime, this.inputManager, this.collisionObjects);
                
                // Update audio manager with player position for 3D sound
                this.audioManager.setPlayerPosition(this.player.getPosition());
                
                // Update Blood Thirst perk
                this.player.updateBloodThirst(deltaTime);
                
                // Update Hellfire perk
                this.player.updateHellfire(deltaTime);
                
                // Update Adrenaline perk
                this.player.updateAdrenaline(deltaTime);
                
                // Update BERSERK perk
                this.player.updateBerserk(deltaTime);
                
                // Update SLOWMO perk
                this.player.updateSlowmo(deltaTime);
                
                // Update airstrike targeting visual
                if (this.player.isTargetingAirstrike) {
                    // Update target circle position based on where player is looking
                    const raycaster = new THREE.Raycaster();
                    const mouse = new THREE.Vector2(0, 0); // Center of screen
                    
                    raycaster.setFromCamera(mouse, this.camera);
                    
                    // Create a large ground plane for intersection
                    const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                    const targetPoint = new THREE.Vector3();
                    
                    raycaster.ray.intersectPlane(groundPlane, targetPoint);
                    
                    if (targetPoint) {
                        // Create or update target circle (bigger to match strike area)
                        if (!this.player.airstrikeTargetCircle) {
                            const circleGeometry = new THREE.RingGeometry(11.5, 12, 32); // 3x bigger to match strike area
                            const circleMaterial = new THREE.MeshBasicMaterial({ 
                                color: 0xffff00, 
                                side: THREE.DoubleSide,
                                transparent: true,
                                opacity: 0.5
                            });
                            this.player.airstrikeTargetCircle = new THREE.Mesh(circleGeometry, circleMaterial);
                            this.player.airstrikeTargetCircle.rotation.x = -Math.PI / 2;
                            this.scene.add(this.player.airstrikeTargetCircle);
                        }
                        
                        this.player.airstrikeTargetCircle.position.copy(targetPoint);
                        this.player.airstrikeTargetCircle.position.y = 0.1;
                        
                        // Pulse effect
                        this.player.airstrikeTargetCircle.material.opacity = 0.3 + Math.sin(Date.now() * 0.003) * 0.2;
                    }
                } else if (this.player.airstrikeTargetCircle) {
                    // Remove target circle when not targeting
                    this.scene.remove(this.player.airstrikeTargetCircle);
                    this.player.airstrikeTargetCircle = null;
                }
                
                // Update warthog strike targeting visual
                if (this.player.isTargetingWarthogStrike) {
                    // Update target rectangle position based on where player is looking
                    const raycaster = new THREE.Raycaster();
                    const mouse = new THREE.Vector2(0, 0); // Center of screen
                    
                    raycaster.setFromCamera(mouse, this.camera);
                    
                    // Create a large ground plane for intersection
                    const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                    const targetPoint = new THREE.Vector3();
                    
                    raycaster.ray.intersectPlane(groundPlane, targetPoint);
                    
                    if (targetPoint) {
                        // Get player facing direction
                        const direction = new THREE.Vector3();
                        this.camera.getWorldDirection(direction);
                        direction.y = 0; // Keep horizontal
                        direction.normalize();
                        
                        // Create or update target rectangle (corridor preview)
                        if (!this.player.warthogTargetRectangle) {
                            const rectangleGeometry = new THREE.PlaneGeometry(40, 3); // 40 units long, 3 wide
                            const rectangleMaterial = new THREE.MeshBasicMaterial({ 
                                color: 0x00ff00, 
                                side: THREE.DoubleSide,
                                transparent: true,
                                opacity: 0.4
                            });
                            this.player.warthogTargetRectangle = new THREE.Mesh(rectangleGeometry, rectangleMaterial);
                            this.player.warthogTargetRectangle.rotation.x = -Math.PI / 2;
                            this.scene.add(this.player.warthogTargetRectangle);
                        }
                        
                        this.player.warthogTargetRectangle.position.copy(targetPoint);
                        this.player.warthogTargetRectangle.position.y = 0.1;
                        
                        // Orient rectangle perpendicular to player facing direction
                        const perpAngle = Math.atan2(-direction.z, direction.x);
                        this.player.warthogTargetRectangle.rotation.z = perpAngle;
                        
                        // Pulse effect
                        this.player.warthogTargetRectangle.material.opacity = 0.3 + Math.sin(Date.now() * 0.004) * 0.15;
                    }
                } else if (this.player.warthogTargetRectangle) {
                    // Remove target rectangle when not targeting
                    this.scene.remove(this.player.warthogTargetRectangle);
                    this.player.warthogTargetRectangle = null;
                }
                
                // Check if player is dead
                if (this.player.isDead()) {
                    this.endGame();
                    return;
                }

                // Update weapon system (use scaled time for animations)
                this.weaponSystem.update(scaledDeltaTime, this.inputManager);

                // Handle shooting or airstrike targeting
                if (this.inputManager.isMousePressed() && this.inputManager.isPointerLocked) {
                    // Check if targeting airstrike
                    if (this.player.isTargetingAirstrike) {
                        // Cast ray from camera to find ground position
                        const raycaster = new THREE.Raycaster();
                        const mouse = new THREE.Vector2(0, 0); // Center of screen
                        
                        raycaster.setFromCamera(mouse, this.camera);
                        
                        // Create a large ground plane for intersection
                        const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                        const targetPoint = new THREE.Vector3();
                        
                        raycaster.ray.intersectPlane(groundPlane, targetPoint);
                        
                        if (targetPoint) {
                            this.player.callAirstrike(targetPoint, this.bulletPool);
                            this.inputManager.mouse.leftButton = false; // Reset to prevent rapid fire
                        }
                    } else if (this.player.isTargetingWarthogStrike) {
                        // Cast ray from camera to find ground position and get direction
                        const raycaster = new THREE.Raycaster();
                        const mouse = new THREE.Vector2(0, 0); // Center of screen
                        
                        raycaster.setFromCamera(mouse, this.camera);
                        
                        // Create a large ground plane for intersection
                        const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                        const targetPoint = new THREE.Vector3();
                        
                        raycaster.ray.intersectPlane(groundPlane, targetPoint);
                        
                        if (targetPoint) {
                            // Get player facing direction
                            const direction = new THREE.Vector3();
                            this.camera.getWorldDirection(direction);
                            direction.y = 0; // Keep horizontal
                            direction.normalize();
                            
                            this.player.callWarthogStrike(targetPoint, direction, this.bulletPool);
                            this.inputManager.mouse.leftButton = false; // Reset to prevent rapid fire
                        }
                    } else {
                        const bullets = this.weaponSystem.shoot(this.bulletPool, this.particleSystem, true, this.enemies, this.player, this.gameManager, this.uiManager);
                    }
                }
                
                // Handle sword combo system and secondary attacks
                if (this.weaponSystem.currentWeapon === 'sword') {
                    // Track mouse movement for directional attacks (optional feature)
                    const mouseDelta = this.inputManager.getMouseDelta();
                    if (Math.abs(mouseDelta.x) > 2 || Math.abs(mouseDelta.y) > 2) {
                        this.weaponSystem.swordCombo.directionalInput = {
                            x: mouseDelta.x,
                            y: mouseDelta.y
                        };
                    }
                    
                    // Handle combo buffering during swings
                    if (this.weaponSystem.swordCombo.canCombo && this.weaponSystem.isSwinging) {
                        // Buffer light attack on left-click
                        if (this.inputManager.isMousePressed() && !this.weaponSystem.swordCombo.queuedAttack) {
                            this.weaponSystem.swordCombo.queuedAttack = { 
                                type: 'light', 
                                time: performance.now() / 1000,
                                enemies: this.enemies,
                                player: this.player,
                                particleSystem: this.particleSystem,
                                gameManager: this,
                                uiManager: this.uiManager
                            };
                        }
                        // Buffer heavy finisher on right-click (after at least 1 combo hit)
                        else if (this.inputManager.isRightButtonDown() && this.weaponSystem.swordCombo.count >= 1 && !this.weaponSystem.swordCombo.queuedAttack) {
                            this.weaponSystem.swordCombo.queuedAttack = { 
                                type: 'heavy', 
                                time: performance.now() / 1000,
                                enemies: this.enemies,
                                player: this.player,
                                particleSystem: this.particleSystem,
                                gameManager: this,  // This is the FPSGame instance, not GameManager
                                uiManager: this.uiManager
                            };
                            this.weaponSystem.swordCombo.heavyFinisherReady = true;
                        }
                    }
                    
                    // Regular heavy attack (hold right-click when not comboing)
                    if (!this.weaponSystem.isSwinging && !this.weaponSystem.swordCombo.canCombo) {
                        if (this.inputManager.isRightButtonDown() && !this.weaponSystem.isWindingUp && !this.weaponSystem.isAreaSwinging) {
                            this.weaponSystem.startWindUp();
                        }
                        else if (!this.inputManager.isRightButtonDown() && this.weaponSystem.isWindingUp) {
                            this.weaponSystem.performAreaAttack(this.enemies, this.player, this.particleSystem, this, this.uiManager);
                        }
                    }
                    
                    // Reset directional input after use
                    if (!this.weaponSystem.isSwinging) {
                        this.weaponSystem.swordCombo.directionalInput = null;
                    }
                }
                
                // Handle autocannon zoom on right-click
                if (this.weaponSystem.currentWeapon === 'autoCannon') {
                    // Toggle zoom on right-click press (not hold)
                    if (this.inputManager.isRightButtonDown()) {
                        if (!this.weaponSystem.zoomTogglePressed) {
                            this.weaponSystem.toggleZoom();
                            this.weaponSystem.zoomTogglePressed = true;
                        }
                    } else {
                        this.weaponSystem.zoomTogglePressed = false;
                    }
                }

                // Update bullets (use scaled time for movement)
                const activeBullets = this.bulletPool.active.slice();
                for (let bullet of activeBullets) {
                    // Skip bullets that have been deactivated (prevents multiple explosions)
                    if (!bullet.active) {
                        continue;
                    }
                    
                    if (!bullet.update(scaledDeltaTime)) {
                        this.bulletPool.release(bullet);
                        continue;
                    }

                    // Track if this bullet should continue processing (for 30mm shells)
                    let bulletReleased = false;

                    // For fast projectiles (30mm shells), perform multiple collision checks
                    const numChecks = bullet.is30mmShell ? 4 : 1;  // 4 checks for shells, 1 for normal bullets
                    
                    for (let checkStep = 0; checkStep < numChecks && !bulletReleased; checkStep++) {
                        // Calculate intermediate position for this check
                        let bulletPos;
                        if (numChecks > 1 && checkStep > 0) {
                            // Interpolate position between previous and current
                            const t = checkStep / numChecks;
                            const prevPos = bullet.previousPosition || bullet.mesh.position.clone();
                            const currentPos = bullet.is30mmShell && bullet.shellMesh ? 
                                bullet.shellMesh.position : 
                                (bullet.isRocket && bullet.rocketMesh ? 
                                    bullet.rocketMesh.position : bullet.mesh.position);
                            bulletPos = new THREE.Vector3().lerpVectors(prevPos, currentPos, t);
                        } else {
                            bulletPos = bullet.is30mmShell && bullet.shellMesh ? 
                                bullet.shellMesh.position : 
                                (bullet.isRocket && bullet.rocketMesh ? 
                                    bullet.rocketMesh.position : bullet.mesh.position);
                        }

                        // Check bullet-enemy collisions
                        for (let i = this.enemies.length - 1; i >= 0; i--) {
                            const enemy = this.enemies[i];
                            if (!enemy.active) continue;
                        
                        // Check for headshot first (if enemy has head mesh)
                        let isHeadshot = false;
                        let hitDetected = false;
                        let hitPosition = enemy.position.clone();
                        
                        if (enemy.headMesh && enemy.mesh) {
                            // Get world position of head
                            const headWorldPos = new THREE.Vector3();
                            enemy.headMesh.getWorldPosition(headWorldPos);
                            
                            // Check if bullet hits head (50% larger hitbox)
                            const headDistance = bulletPos.distanceTo(headWorldPos);
                            if (headDistance < 0.45 * enemy.size) { // Increased from 0.3 to 0.45 (50% larger)
                                isHeadshot = true;
                                hitDetected = true;
                                hitPosition = headWorldPos;
                            }
                        }
                        
                        // If not headshot, check body hit
                        if (!hitDetected) {
                            // Adjust hit detection for larger enemy models
                            // Enemy position is at ground level, torso is at y=0.8
                            const torsoPos = enemy.position.clone();
                            torsoPos.y += 0.8 * enemy.size;
                            const bodyDistance = bulletPos.distanceTo(torsoPos);
                            // Hit radius should scale with enemy size
                            if (bodyDistance < 0.8 * enemy.size) {
                                hitDetected = true;
                                hitPosition = torsoPos;
                            }
                        }
                        
                        if (hitDetected) {
                            // Handle 30mm shell explosion on enemy impact
                            if (bullet.is30mmShell && bullet.active) {
                                const shellPos = bullet.shellMesh ? 
                                    bullet.shellMesh.position.clone() : bullet.mesh.position.clone();
                                
                                // Process headshot hit first (before explosion)
                                if (isHeadshot) {
                                    // Layer all three headshot sounds (like regular bullets)
                                    this.audioManager.play('enemyHeadshot');
                                    this.audioManager.play('enemyHeadshot2');
                                    this.audioManager.play('enemyHeadshot3');
                                    
                                    // Headshot particle effect (yellow for headshot)
                                    this.particleSystem.createExplosion(hitPosition, 0xffff00, 20);
                                    
                                    // Award headshot bonus points
                                    this.gameManager.addScore(50);
                                    this.uiManager.addKillMessage('HEADSHOT! +50');
                                    
                                    // Register headshot for SLOWMO perk
                                    this.player.registerHeadshot();
                                    
                                    // Apply instant kill damage (autocannon is always lethal)
                                    const killed = enemy.takeDamage(99999);
                                    
                                    if (killed) {
                                        // Apply decapitation effect for autocannon headshot kill
                                        if (enemy.bodyParts && enemy.bodyParts.head) {
                                            // Hide the head
                                            enemy.bodyParts.head.visible = false;
                                            
                                            // Get neck position for gibs
                                            const neckPos = enemy.mesh.position.clone();
                                            neckPos.y += 1.3; // Approximate neck height
                                            
                                            // Create head removal effect (like shotgun)
                                            this.particleSystem.createHeadRemoval(neckPos, shellPos.clone().sub(neckPos).normalize());
                                        }
                                        
                                        // Play death sounds
                                        this.audioManager.play('enemyDie');
                                        if (Math.random() < 1/6) {
                                            this.audioManager.play('enemyDeathGrunt');
                                        }
                                        
                                        // Score and kill registration
                                        this.gameManager.addScore(enemy.scoreValue);
                                        this.gameManager.addKill();
                                        this.player.registerKill();
                                        this.uiManager.addKillMessage(`Enemy eliminated +${enemy.scoreValue}`);
                                        
                                        // Random pickup chance
                                        if (Math.random() < 0.3) {
                                            const pickupType = Math.random() < 0.5 ? 'health' : 'ammo';
                                            this.spawnPickup(pickupType, enemy.position.clone());
                                        }
                                        
                                        // Mark for removal (will be cleaned up after explosion)
                                        enemy.headshotKilled = true;
                                    }
                                }
                                
                                // Immediately deactivate to prevent multiple explosions
                                bullet.active = false;
                                // Hide the shell mesh immediately
                                if (bullet.shellMesh) {
                                    bullet.shellMesh.visible = false;
                                    if (bullet.shellGlow) {
                                        bullet.shellGlow.visible = false;
                                    }
                                    if (bullet.shellCone) {
                                        bullet.shellCone.visible = false;
                                    }
                                }
                                
                                // Create explosion at impact point (this will handle area damage and cleanup)
                                this.handleShellExplosion(shellPos, bullet.shellBlastRadius || 5, bullet.damage);
                                this.bulletPool.release(bullet);
                                bulletReleased = true;
                                break;
                            }
                            // Handle rocket explosion
                            else if (bullet.isRocket) {
                                const explosionPos = bullet.rocketMesh ? 
                                    bullet.rocketMesh.position.clone() : bullet.mesh.position.clone();
                                this.handleRocketExplosion(explosionPos, bullet.blastRadius, bullet.damage, bullet.isHellfireBullet, bullet.isHellfireRocket);
                                this.bulletPool.release(bullet);
                                bulletReleased = true;
                                break;
                            }
                            
                            // Calculate damage (double for headshot)
                            let finalDamage = bullet.damage;
                            
                            // Check if headshot will kill
                            const willKill = (isHeadshot && finalDamage * 2 >= enemy.hp);
                            
                            if (isHeadshot) {
                                finalDamage *= 2;
                                // Headshot effects
                                this.particleSystem.createExplosion(hitPosition, 0xffff00, 20); // Yellow explosion for headshot
                                
                                // Layer all three headshot sounds
                                this.audioManager.play('enemyHeadshot');
                                this.audioManager.play('enemyHeadshot2');
                                this.audioManager.play('enemyHeadshot3');
                                
                                // Create blood jet effect only for non-lethal headshots
                                // (Lethal headshots will use dismemberment effects instead)
                                if (!willKill) {
                                    this.particleSystem.createBloodJet(hitPosition, bulletPos.clone().sub(hitPosition).normalize());
                                }
                                
                                // Award headshot bonus points
                                this.gameManager.addScore(50);
                                this.uiManager.addKillMessage('HEADSHOT! +50');
                                
                                // Register headshot for SLOWMO perk
                                this.player.registerHeadshot();
                            } else {
                                // Normal hit effects
                                this.particleSystem.createExplosion(hitPosition, 0xff4444, 15);
                                this.audioManager.play('enemyHit');
                            }
                            
                            // 10% chance to play grunt sound when hit (body shot only)
                            if (!isHeadshot && Math.random() < 0.1) {
                                this.audioManager.play('enemyGrunt');
                            }
                            
                            const killed = enemy.takeDamage(finalDamage);
                            this.bulletPool.release(bullet);
                            bulletReleased = true;
                            
                            if (killed) {
                                // Enemy killed - play death sound
                                this.audioManager.play('enemyDie');
                                
                                // 1/6 chance to play death grunt
                                if (Math.random() < 1/6) {
                                    this.audioManager.play('enemyDeathGrunt');
                                }
                                
                                // Check for shotgun headshot decapitation
                                if (isHeadshot && bullet.weapon === 'shotgun') {
                                    // Remove head for shotgun headshot kills
                                    if (enemy.bodyParts && enemy.bodyParts.head) {
                                        // Hide the head
                                        enemy.bodyParts.head.visible = false;
                                        
                                        // Get neck position for gibs
                                        const neckPos = enemy.mesh.position.clone();
                                        neckPos.y += 1.3; // Approximate neck height
                                        
                                        // Create head removal effect
                                        this.particleSystem.createHeadRemoval(neckPos, bulletPos.clone().sub(neckPos).normalize());
                                    }
                                }
                                
                                // Check for other dismemberment conditions
                                const distanceToEnemy = bulletPos.distanceTo(enemy.position);
                                const shouldDismember = 
                                    (isHeadshot && bullet.weapon !== 'shotgun') || // Non-shotgun headshots use normal dismemberment
                                    (bullet.weapon === 'shotgun' && distanceToEnemy < 10 && !isHeadshot) || // Close range shotgun body shots
                                    finalDamage >= 150; // Very high damage kills
                                
                                if (shouldDismember) {
                                    try {
                                        // Use hitPosition for headshots, enemy.position for others
                                        const dismemberPosition = isHeadshot && hitPosition ? hitPosition.clone() : 
                                                                 (enemy.position ? enemy.position.clone() : new THREE.Vector3());
                                        const bulletPosition = bulletPos ? bulletPos.clone() : new THREE.Vector3();
                                        const forceDirection = bulletPosition.sub(dismemberPosition).normalize();
                                        const dismemberType = isHeadshot ? 'headshot' : 'ballistic';
                                        this.particleSystem.createDismemberment(dismemberPosition, dismemberType, forceDirection);
                                    } catch (error) {
                                        console.warn('Dismemberment error in bullet kill:', error);
                                    }
                                }
                                
                                this.gameManager.addScore(enemy.scoreValue);
                                this.gameManager.addKill();
                                this.player.registerKill(); // Register kill for Blood Thirst
                                this.uiManager.addKillMessage(`Enemy eliminated +${enemy.scoreValue}`);
                                
                                // Random pickup chance
                                if (Math.random() < 0.3) {
                                    const pickupType = Math.random() < 0.5 ? 'health' : 'ammo';
                                    this.spawnPickup(pickupType, enemy.position.clone());
                                }
                                
                                enemy.destroy();
                                this.enemies.splice(i, 1);
                                this.uiManager.updateEnemyCount(this.enemies.length);
                            }
                            break;
                        }
                    }
                    
                    // Check ground collision (y <= 0)
                    if (!bulletReleased && bulletPos.y <= 0) {
                        // 30mm shells ALWAYS explode on ground impact
                        if (bullet.is30mmShell && bullet.active) {
                            // Immediately deactivate to prevent multiple explosions
                            bullet.active = false;
                            // Hide the shell mesh immediately
                            if (bullet.shellMesh) {
                                bullet.shellMesh.visible = false;
                                if (bullet.shellGlow) {
                                    bullet.shellGlow.visible = false;
                                }
                                if (bullet.shellCone) {
                                    bullet.shellCone.visible = false;
                                }
                            }
                            const explosionPos = new THREE.Vector3(bulletPos.x, 0, bulletPos.z);
                            this.handleShellExplosion(explosionPos, bullet.shellBlastRadius || 5, bullet.damage);
                        }
                        // Handle rocket explosion on ground impact
                        else if (bullet.isRocket) {
                            this.handleRocketExplosion(bulletPos.clone(), bullet.blastRadius, bullet.damage, bullet.isHellfireBullet, bullet.isHellfireRocket);
                        } else if (bullet.isHellfireBullet) {
                            // Hellfire bullet creates small explosion
                            this.handleRocketExplosion(new THREE.Vector3(bulletPos.x, 0, bulletPos.z), bullet.blastRadius, bullet.damage, true, false);
                        } else {
                            this.particleSystem.createExplosion(new THREE.Vector3(bulletPos.x, 0, bulletPos.z), 0x888888, 8);
                            this.audioManager.play('bulletHit'); // Play random bullet hit sound
                        }
                        this.bulletPool.release(bullet);
                        bulletReleased = true;
                    }
                    
                    // Check bullet-wall collisions
                    if (!bulletReleased) {
                        for (let obj of this.collisionObjects) {
                            const box = new THREE.Box3().setFromObject(obj);
                            
                            if (box.containsPoint(bulletPos)) {
                                // 30mm shells ALWAYS explode on wall/obstacle impact
                                if (bullet.is30mmShell && bullet.active) {
                                    // Immediately deactivate to prevent multiple explosions
                                    bullet.active = false;
                                    // Hide shell mesh immediately
                                    if (bullet.shellMesh) {
                                        bullet.shellMesh.visible = false;
                                    }
                                    if (bullet.shellGlow) {
                                        bullet.shellGlow.visible = false;
                                    }
                                    this.handleShellExplosion(bulletPos.clone(), bullet.shellBlastRadius || 5, bullet.damage);
                                }
                                // Handle rocket explosion on wall impact
                                else if (bullet.isRocket) {
                                    this.handleRocketExplosion(bulletPos.clone(), bullet.blastRadius, bullet.damage, bullet.isHellfireBullet, bullet.isHellfireRocket);
                                } else if (bullet.isHellfireBullet) {
                                    // Hellfire bullet creates small explosion
                                    this.handleRocketExplosion(bulletPos.clone(), bullet.blastRadius, bullet.damage, true, false);
                                } else {
                                    this.particleSystem.createExplosion(bulletPos, 0x888888, 8);
                                    this.audioManager.play('bulletHit'); // Play random bullet hit sound
                                }
                                this.bulletPool.release(bullet);
                                bulletReleased = true;
                                break;
                            }
                        }
                    }
                    }  // End of multiple collision check loop
                }  // End of main bullet update loop

                // Update enemies (use scaled time for movement)
                const playerPos = this.player.getPosition();
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    enemy.update(scaledDeltaTime, playerPos, this.enemyBulletPool, this.particleSystem, this.audioManager);
                    
                    // Remove dead enemies from array (important for sword kills)
                    if (!enemy.active || enemy.isDead) {
                        this.enemies.splice(i, 1);
                        this.uiManager.updateEnemyCount(this.enemies.length);
                    }
                }
                
                // Update enemy bullets (use scaled time)
                const activeEnemyBullets = this.enemyBulletPool.active.slice();
                for (let bullet of activeEnemyBullets) {
                    if (!bullet.update(scaledDeltaTime)) {
                        this.enemyBulletPool.release(bullet);
                        continue;
                    }
                    
                    // Check distance to player for whizz sound
                    const bulletPos = bullet.isRocket && bullet.rocketMesh ? 
                        bullet.rocketMesh.position : bullet.mesh.position;
                    const distance = bulletPos.distanceTo(playerPos);
                    
                    // Check ground collision (y <= 0)
                    if (bulletPos.y <= 0) {
                        if (bullet.isRocket) {
                            // Enemy rocket ground explosion (never Hellfire)
                            this.handleRocketExplosion(new THREE.Vector3(bulletPos.x, 0, bulletPos.z), bullet.blastRadius || 5, bullet.damage, false, false);
                        } else {
                            this.particleSystem.createExplosion(new THREE.Vector3(bulletPos.x, 0, bulletPos.z), 0xff4444, 5);
                            this.audioManager.play('bulletHit'); // Play random bullet hit sound
                        }
                        this.enemyBulletPool.release(bullet);
                        continue;
                    }
                    
                    // Play whizz sound when bullet passes near player (within 3 units)
                    if (distance < 3 && !bullet.hasWhizzed) {
                        this.audioManager.play('bulletWhizz');
                        bullet.hasWhizzed = true; // Only play once per bullet
                    }
                    
                    // Check if enemy bullet hits player
                    if (distance < 1) {
                        // Handle enemy rockets
                        if (bullet.isRocket) {
                            // Explosion affects area (never Hellfire)
                            this.handleRocketExplosion(bulletPos.clone(), bullet.blastRadius || 5, bullet.damage, false, false);
                            this.enemyBulletPool.release(bullet);
                        } else {
                            this.player.takeDamage(bullet.damage);
                            this.particleSystem.createExplosion(playerPos, 0xff0000, 10);
                            this.enemyBulletPool.release(bullet);
                        }
                    }
                    
                    // Check bullet-wall collisions
                    for (let obj of this.collisionObjects) {
                        const box = new THREE.Box3().setFromObject(obj);
                        const checkPos = bullet.isRocket && bullet.rocketMesh ? 
                            bullet.rocketMesh.position : bullet.mesh.position;
                        
                        if (box.containsPoint(checkPos)) {
                            if (bullet.isRocket) {
                                // Enemy rocket explosion (never Hellfire)
                                this.handleRocketExplosion(checkPos.clone(), bullet.blastRadius || 5, bullet.damage, false, false);
                            } else {
                                this.particleSystem.createExplosion(checkPos, 0xff4444, 5);
                                this.audioManager.play('bulletHit'); // Play random bullet hit sound
                            }
                            this.enemyBulletPool.release(bullet);
                            break;
                        }
                    }
                }

                // Update pickups
                for (let i = this.pickups.length - 1; i >= 0; i--) {
                    const pickup = this.pickups[i];
                    pickup.update(deltaTime);
                    
                    // Check pickup-player collision
                    if (pickup.getPosition().distanceTo(playerPos) < 2) {
                        const type = pickup.collect();
                        if (type === 'health') {
                            this.player.heal(30);
                            this.uiManager.addKillMessage('Health restored +30');
                        } else if (type === 'ammo') {
                            this.weaponSystem.addAmmo(30);
                            this.uiManager.addKillMessage('Ammo collected +30');
                        }
                        this.audioManager.play('pickup');
                        this.pickups.splice(i, 1);
                    }
                }

                // Update wave system (use scaled time for spawn timing)
                const newEnemyType = this.waveSystem.update(scaledDeltaTime, this.enemies);
                if (newEnemyType !== null) {
                    this.spawnEnemy(newEnemyType);
                }

                // Spawn random pickups
                this.pickupSpawnTimer += deltaTime;
                if (this.pickupSpawnTimer >= this.pickupSpawnInterval) {
                    this.pickupSpawnTimer = 0;
                    if (this.pickups.length < 3 && Math.random() < 0.7) {
                        const pickupType = Math.random() < 0.6 ? 'ammo' : 'health';
                        const spawnPos = new THREE.Vector3(
                            (Math.random() - 0.5) * 80,
                            1,
                            (Math.random() - 0.5) * 80
                        );
                        this.spawnPickup(pickupType, spawnPos);
                    }
                }

                // Update particle system (use scaled time for animations)
                this.particleSystem.update(scaledDeltaTime);
                
                // Update smoke particles
                if (this.particleSystem.updateSmokeParticles) {
                    this.particleSystem.updateSmokeParticles(scaledDeltaTime);
                }

                // Update UI
                this.uiManager.updateDebugInfo(this.player, this.enemies, this.bulletPool.active);
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const currentTime = this.clock.getElapsedTime();
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                // Clamp delta time to prevent large jumps (only clamp if > 100ms)
                const clampedDeltaTime = Math.min(deltaTime, 0.1);
                
                // Handle different game states
                switch (this.state) {
                    case GameState.SPLASH:
                        // Just waiting for user to click
                        break;
                        
                    case GameState.MENU:
                        // Handle menu input - only start if button was clicked
                        if (this.shouldStartGame && this.inputManager.isPointerLocked) {
                            this.shouldStartGame = false; // Reset flag
                            this.startGame();
                        }
                        break;
                    
                    case GameState.PLAYING:
                        this.updateGame(clampedDeltaTime);
                        break;
                    
                    case GameState.PAUSED:
                        // Game is paused, don't update anything
                        break;
                    
                    case GameState.GAME_OVER:
                        // Maybe show some effects or cleanup
                        break;
                }

                // Update UI elements
                this.uiManager.updateFPS(clampedDeltaTime);
                
                // Update minimap
                if (this.state === GameState.PLAYING) {
                    const minimap = document.getElementById('minimap');
                    this.uiManager.drawMinimap(minimap, this.player, this.enemies, this.pickups);
                }
                
                // Always render
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Start the game when page loads
        window.addEventListener('load', () => {
            const game = new FPSGame();
            
            // Handle Splash Screen click
            const splashScreen = document.getElementById('splashScreen');
            if (splashScreen) {
                splashScreen.addEventListener('click', (e) => {
                    if (game.state === GameState.SPLASH) {
                        // Play menu select sound
                        game.audioManager.play('menu_select');
                        // Show main menu
                        game.showMenu();
                    }
                });
            }
            
            // Handle clicking on canvas during gameplay to re-acquire pointer lock
            document.addEventListener('click', (e) => {
                // Only re-acquire pointer lock if game is playing or paused and pointer is not locked
                if ((game.state === GameState.PLAYING || game.state === GameState.PAUSED) && 
                    !game.inputManager.isPointerLocked) {
                    
                    // If paused, resume the game
                    if (game.state === GameState.PAUSED) {
                        game.resumeGame();
                    } else {
                        // Just re-acquire pointer lock
                        game.inputManager.requestPointerLock();
                    }
                }
            });
            
            // Handle Start Game button
            const startButton = document.getElementById('startButton');
            if (startButton) {
                startButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Play menu select sound
                    game.audioManager.play('menu_select');
                    // Set flag to actually start the game when pointer lock is achieved
                    game.shouldStartGame = true;
                    game.inputManager.requestPointerLock();
                });
            }
            
            // Handle Guide button
            const guideButton = document.getElementById('guideButton');
            if (guideButton) {
                guideButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Play menu select sound
                    game.audioManager.play('menu_select');
                    document.getElementById('guideScreen').style.display = 'block';
                });
            }
            
            // Handle Close Guide button
            const closeGuideButton = document.getElementById('closeGuideButton');
            if (closeGuideButton) {
                closeGuideButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Play menu select sound
                    game.audioManager.play('menu_select');
                    document.getElementById('guideScreen').style.display = 'none';
                });
            }
            
            
        });
    </script>
</body>
</html>